// Copyright (c) 2016 Uber Technologies, Inc.
// 版权归Uber Technologies公司所有
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 特此免费授予任何获得本软件副本的人使用、复制、修改、分发等权利
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 上述版权声明和许可声明应包含在软件的所有副本中
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// 本软件"按原样"提供，不提供任何明示或暗示的保证

package zap // zap包：提供快速、结构化、分级日志记录

import (
	"fmt" // fmt包：格式化I/O

	"go.uber.org/zap/zapcore" // zapcore包：核心接口和实现
)

// An Option configures a Logger.
// Option配置Logger的接口。
type Option interface {
	apply(*Logger) // 应用配置到Logger
}

// optionFunc wraps a func so it satisfies the Option interface.
// optionFunc包装函数使其满足Option接口。
type optionFunc func(*Logger)

func (f optionFunc) apply(log *Logger) { // 实现Option接口的apply方法
	f(log) // 调用包装的函数
}

// WrapCore wraps or replaces the Logger's underlying zapcore.Core.
// WrapCore包装或替换Logger的底层zapcore.Core。
func WrapCore(f func(zapcore.Core) zapcore.Core) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.core = f(log.core) // 替换Logger的核心
	})
}

// Hooks registers functions which will be called each time the Logger writes
// out an Entry. Repeated use of Hooks is additive.
//
// Hooks are useful for simple side effects, like capturing metrics for the
// number of emitted logs. More complex side effects, including anything that
// requires access to the Entry's structured fields, should be implemented as
// a zapcore.Core instead. See zapcore.RegisterHooks for details.
// Hooks注册在Logger写入Entry时将被调用的函数。重复使用Hooks是累加的。
//
// Hooks对于简单的副作用很有用，比如捕获发出日志数量的指标。
// 更复杂的副作用，包括任何需要访问Entry结构化字段的操作，
// 应该作为zapcore.Core实现。详见zapcore.RegisterHooks。
func Hooks(hooks ...func(zapcore.Entry) error) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.core = zapcore.RegisterHooks(log.core, hooks...) // 注册钩子函数
	})
}

// Fields adds fields to the Logger.
// Fields向Logger添加字段。
func Fields(fs ...Field) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.core = log.core.With(fs) // 添加字段到Logger的核心
	})
}

// ErrorOutput sets the destination for errors generated by the Logger. Note
// that this option only affects internal errors; for sample code that sends
// error-level logs to a different location from info- and debug-level logs,
// see the package-level AdvancedConfiguration example.
//
// The supplied WriteSyncer must be safe for concurrent use. The Open and
// zapcore.Lock functions are the simplest ways to protect files with a mutex.
// ErrorOutput设置Logger生成的错误的目标。注意此选项仅影响内部错误；
// 对于将错误级别日志发送到与信息和调试级别日志不同位置的示例代码，
// 请参见包级别AdvancedConfiguration示例。
//
// 提供的WriteSyncer必须对并发使用是安全的。Open和zapcore.Lock函数
// 是使用互斥锁保护文件的最简单方法。
func ErrorOutput(w zapcore.WriteSyncer) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.errorOutput = w // 设置错误输出
	})
}

// Development puts the logger in development mode, which makes DPanic-level
// logs panic instead of simply logging an error.
// Development将logger置于开发模式，使DPanic级别的日志panic而不是简单地记录错误。
func Development() Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.development = true // 设置为开发模式
	})
}

// AddCaller configures the Logger to annotate each message with the filename,
// line number, and function name of zap's caller. See also WithCaller.
// AddCaller配置Logger为每个消息添加文件名、行号和zap调用者的函数名。也可参见WithCaller。
func AddCaller() Option {
	return WithCaller(true) // 调用WithCaller启用调用者信息
}

// WithCaller configures the Logger to annotate each message with the filename,
// line number, and function name of zap's caller, or not, depending on the
// value of enabled. This is a generalized form of AddCaller.
// WithCaller根据enabled的值配置Logger是否为每个消息添加文件名、
// 行号和zap调用者的函数名。这是AddCaller的通用形式。
func WithCaller(enabled bool) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.addCaller = enabled // 设置是否添加调用者信息
	})
}

// AddCallerSkip increases the number of callers skipped by caller annotation
// (as enabled by the AddCaller option). When building wrappers around the
// Logger and SugaredLogger, supplying this Option prevents zap from always
// reporting the wrapper code as the caller.
// AddCallerSkip增加调用者注释跳过的调用者数量（由AddCaller选项启用）。
// 在构建Logger和SugaredLogger的包装器时，提供此选项可防止zap
// 始终将包装器代码报告为调用者。
func AddCallerSkip(skip int) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.callerSkip += skip // 增加跳过的调用者数量
	})
}

// AddStacktrace configures the Logger to record a stack trace for all messages at
// or above a given level.
// AddStacktrace配置Logger为所有处于或高于给定级别的消息记录堆栈跟踪。
func AddStacktrace(lvl zapcore.LevelEnabler) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.addStack = lvl // 设置堆栈跟踪级别
	})
}

// IncreaseLevel increase the level of the logger. It has no effect if
// the passed in level tries to decrease the level of the logger.
// IncreaseLevel提高logger的级别。如果传入的级别试图降低logger的级别，则无效果。
func IncreaseLevel(lvl zapcore.LevelEnabler) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		core, err := zapcore.NewIncreaseLevelCore(log.core, lvl) // 创建增强级别的Core
		if err != nil {                                          // 如果创建失败
			_, _ = fmt.Fprintf( // 向错误输出写入错误信息
				log.errorOutput,
				"failed to IncreaseLevel: %v\n",
				err,
			)
		} else {
			log.core = core // 替换Logger的核心
		}
	})
}

// WithPanicHook sets a CheckWriteHook to run on Panic/DPanic logs.
// Zap will call this hook after writing a log statement with a Panic/DPanic level.
//
// For example, the following builds a logger that will exit the current
// goroutine after writing a Panic/DPanic log message, but it will not start a panic.
//
//	zap.New(core, zap.WithPanicHook(zapcore.WriteThenGoexit))
//
// This is useful for testing Panic/DPanic log output.
// WithPanicHook设置在Panic/DPanic日志上运行的CheckWriteHook。
// Zap在写入Panic/DPanic级别的日志语句后将调用此钩子。
//
// 例如，以下代码构建了一个logger，在写入Panic/DPanic日志消息后
// 将退出当前goroutine，但不会开始panic。
//
//	zap.New(core, zap.WithPanicHook(zapcore.WriteThenGoexit))
//
// 这对于测试Panic/DPanic日志输出很有用。
func WithPanicHook(hook zapcore.CheckWriteHook) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.onPanic = hook // 设置panic钩子
	})
}

// OnFatal sets the action to take on fatal logs.
//
// Deprecated: Use [WithFatalHook] instead.
// OnFatal设置在致命日志上采取的操作。
//
// 已弃用：使用[WithFatalHook]代替。
func OnFatal(action zapcore.CheckWriteAction) Option {
	return WithFatalHook(action) // 委托给WithFatalHook
}

// WithFatalHook sets a CheckWriteHook to run on fatal logs.
// Zap will call this hook after writing a log statement with a Fatal level.
//
// For example, the following builds a logger that will exit the current
// goroutine after writing a fatal log message, but it will not exit the
// program.
//
//	zap.New(core, zap.WithFatalHook(zapcore.WriteThenGoexit))
//
// It is important that the provided CheckWriteHook stops the control flow at
// the current statement to meet expectations of callers of the logger.
// We recommend calling os.Exit or runtime.Goexit inside custom hooks at
// minimum.
// WithFatalHook设置在致命日志上运行的CheckWriteHook。
// Zap在写入Fatal级别的日志语句后将调用此钩子。
//
// 例如，以下代码构建了一个logger，在写入致命日志消息后
// 将退出当前goroutine，但不会退出程序。
//
//	zap.New(core, zap.WithFatalHook(zapcore.WriteThenGoexit))
//
// 重要的是，提供的CheckWriteHook必须在当前语句处停止控制流，
// 以满足logger调用者的期望。我们建议在自定义钩子中至少调用
// os.Exit或runtime.Goexit。
func WithFatalHook(hook zapcore.CheckWriteHook) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.onFatal = hook // 设置致命钩子
	})
}

// WithClock specifies the clock used by the logger to determine the current
// time for logged entries. Defaults to the system clock with time.Now.
// WithClock指定logger用于确定日志条目当前时间的时钟。
// 默认为使用time.Now的系统时钟。
func WithClock(clock zapcore.Clock) Option {
	return optionFunc(func(log *Logger) { // 返回选项函数
		log.clock = clock // 设置时钟
	})
}
