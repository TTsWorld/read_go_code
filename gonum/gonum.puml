@startuml
namespace ast {
    class Attr << (S,Aquamarine) >> {
        + Key string
        + Val string

        - isStmt() 

        + String() string

    }
    class AttrStmt << (S,Aquamarine) >> {
        + Kind Kind
        + Attrs []*Attr

        - isStmt() 

        + String() string

    }
    class CompassPoint << (S,Aquamarine) >> {
        + String() string

    }
    class Edge << (S,Aquamarine) >> {
        + Directed bool
        + Vertex Vertex
        + To *Edge

        + String() string

    }
    class EdgeStmt << (S,Aquamarine) >> {
        + From Vertex
        + To *Edge
        + Attrs []*Attr

        - isStmt() 

        + String() string

    }
    class File << (S,Aquamarine) >> {
        + Graphs []*Graph

        + String() string

    }
    class Graph << (S,Aquamarine) >> {
        + Strict bool
        + Directed bool
        + ID string
        + Stmts []Stmt

        + String() string

    }
    class Kind << (S,Aquamarine) >> {
        + String() string

    }
    class Node << (S,Aquamarine) >> {
        + ID string
        + Port *Port

        - isVertex() 

        + String() string

    }
    class NodeStmt << (S,Aquamarine) >> {
        + Node *Node
        + Attrs []*Attr

        - isStmt() 

        + String() string

    }
    class Port << (S,Aquamarine) >> {
        + ID string
        + CompassPoint CompassPoint

        + String() string

    }
    interface Stmt  {
        - isStmt() 

    }
    class Subgraph << (S,Aquamarine) >> {
        + ID string
        + Stmts []Stmt

        - isStmt() 
        - isVertex() 

        + String() string

    }
    interface Vertex  {
        - isVertex() 

    }
    class ast.CompassPoint << (T, #FF7700) >>  {
    }
    class ast.Kind << (T, #FF7700) >>  {
    }
}

"ast.Stmt" <|-- "ast.Attr"
"ast.Stmt" <|-- "ast.AttrStmt"
"ast.Stmt" <|-- "ast.EdgeStmt"
"ast.Vertex" <|-- "ast.Node"
"ast.Stmt" <|-- "ast.NodeStmt"
"ast.Stmt" <|-- "ast.Subgraph"
"ast.Vertex" <|-- "ast.Subgraph"

namespace barneshut {
    interface Particle2  {
        + Coord2() r2.Vec
        + Mass() float64

    }
    interface Particle3  {
        + Coord3() r3.Vec
        + Mass() float64

    }
    class Plane << (S,Aquamarine) >> {
        - root tile

        + Particles []Particle2

        + Reset() error
        + ForceOn(p Particle2, theta float64, f Force2) r2.Vec

    }
    class Volume << (S,Aquamarine) >> {
        - root bucket

        + Particles []Particle3

        + Reset() error
        + ForceOn(p Particle3, theta float64, f Force3) r3.Vec

    }
    class barneshut.Force2 << (T, #FF7700) >>  {
    }
    class barneshut.Force3 << (T, #FF7700) >>  {
    }
    class bucket << (S,Aquamarine) >> {
        - particle Particle3
        - bounds r3.Box
        - nodes []*bucket
        - center r3.Vec
        - mass float64

        - insert(p Particle3) 
        - passDown(p Particle3) 
        - summarize() (r3.Vec, float64)
        - forceOn(p Particle3, pt r3.Vec, m float64, theta float64, f Force3) r3.Vec

    }
    class tile << (S,Aquamarine) >> {
        - particle Particle2
        - bounds r2.Box
        - nodes []*tile
        - center r2.Vec
        - mass float64

        - insert(p Particle2) 
        - passDown(p Particle2) 
        - summarize() (r2.Vec, float64)
        - forceOn(p Particle2, pt r2.Vec, m float64, theta float64, f Force2) r2.Vec

    }
    class "<font color=blue>func</font>(Particle2, Particle2, float64, float64, r2.Vec) r2.Vec" as fontcolorbluefuncfontParticle2Particle2float64float64r2Vecr2Vec {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "<font color=blue>func</font>(Particle3, Particle3, float64, float64, r3.Vec) r3.Vec" as fontcolorbluefuncfontParticle3Particle3float64float64r3Vecr3Vec {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace blas {
    interface Complex128  {
    }
    interface Complex128Level1  {
        + Zdotu(n int, x []complex128, incX int, y []complex128, incY int) complex128
        + Zdotc(n int, x []complex128, incX int, y []complex128, incY int) complex128
        + Dznrm2(n int, x []complex128, incX int) float64
        + Dzasum(n int, x []complex128, incX int) float64
        + Izamax(n int, x []complex128, incX int) int
        + Zswap(n int, x []complex128, incX int, y []complex128, incY int) 
        + Zcopy(n int, x []complex128, incX int, y []complex128, incY int) 
        + Zaxpy(n int, alpha complex128, x []complex128, incX int, y []complex128, incY int) 
        + Zscal(n int, alpha complex128, x []complex128, incX int) 
        + Zdscal(n int, alpha float64, x []complex128, incX int) 

    }
    interface Complex128Level2  {
        + Zgemv(tA Transpose, m int, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zgbmv(tA Transpose, m int, n int, kL int, kU int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Ztrmv(ul Uplo, tA Transpose, d Diag, n int, a []complex128, lda int, x []complex128, incX int) 
        + Ztbmv(ul Uplo, tA Transpose, d Diag, n int, k int, a []complex128, lda int, x []complex128, incX int) 
        + Ztpmv(ul Uplo, tA Transpose, d Diag, n int, ap []complex128, x []complex128, incX int) 
        + Ztrsv(ul Uplo, tA Transpose, d Diag, n int, a []complex128, lda int, x []complex128, incX int) 
        + Ztbsv(ul Uplo, tA Transpose, d Diag, n int, k int, a []complex128, lda int, x []complex128, incX int) 
        + Ztpsv(ul Uplo, tA Transpose, d Diag, n int, ap []complex128, x []complex128, incX int) 
        + Zhemv(ul Uplo, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zhbmv(ul Uplo, n int, k int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zhpmv(ul Uplo, n int, alpha complex128, ap []complex128, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zgeru(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 
        + Zgerc(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 
        + Zher(ul Uplo, n int, alpha float64, x []complex128, incX int, a []complex128, lda int) 
        + Zhpr(ul Uplo, n int, alpha float64, x []complex128, incX int, a []complex128) 
        + Zher2(ul Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 
        + Zhpr2(ul Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, ap []complex128) 

    }
    interface Complex128Level3  {
        + Zgemm(tA Transpose, tB Transpose, m int, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Zsymm(s Side, ul Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Zsyrk(ul Uplo, t Transpose, n int, k int, alpha complex128, a []complex128, lda int, beta complex128, c []complex128, ldc int) 
        + Zsyr2k(ul Uplo, t Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Ztrmm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) 
        + Ztrsm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) 
        + Zhemm(s Side, ul Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Zherk(ul Uplo, t Transpose, n int, k int, alpha float64, a []complex128, lda int, beta float64, c []complex128, ldc int) 
        + Zher2k(ul Uplo, t Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta float64, c []complex128, ldc int) 

    }
    interface Complex64  {
    }
    interface Complex64Level1  {
        + Cdotu(n int, x []complex64, incX int, y []complex64, incY int) complex64
        + Cdotc(n int, x []complex64, incX int, y []complex64, incY int) complex64
        + Scnrm2(n int, x []complex64, incX int) float32
        + Scasum(n int, x []complex64, incX int) float32
        + Icamax(n int, x []complex64, incX int) int
        + Cswap(n int, x []complex64, incX int, y []complex64, incY int) 
        + Ccopy(n int, x []complex64, incX int, y []complex64, incY int) 
        + Caxpy(n int, alpha complex64, x []complex64, incX int, y []complex64, incY int) 
        + Cscal(n int, alpha complex64, x []complex64, incX int) 
        + Csscal(n int, alpha float32, x []complex64, incX int) 

    }
    interface Complex64Level2  {
        + Cgemv(tA Transpose, m int, n int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Cgbmv(tA Transpose, m int, n int, kL int, kU int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Ctrmv(ul Uplo, tA Transpose, d Diag, n int, a []complex64, lda int, x []complex64, incX int) 
        + Ctbmv(ul Uplo, tA Transpose, d Diag, n int, k int, a []complex64, lda int, x []complex64, incX int) 
        + Ctpmv(ul Uplo, tA Transpose, d Diag, n int, ap []complex64, x []complex64, incX int) 
        + Ctrsv(ul Uplo, tA Transpose, d Diag, n int, a []complex64, lda int, x []complex64, incX int) 
        + Ctbsv(ul Uplo, tA Transpose, d Diag, n int, k int, a []complex64, lda int, x []complex64, incX int) 
        + Ctpsv(ul Uplo, tA Transpose, d Diag, n int, ap []complex64, x []complex64, incX int) 
        + Chemv(ul Uplo, n int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Chbmv(ul Uplo, n int, k int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Chpmv(ul Uplo, n int, alpha complex64, ap []complex64, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Cgeru(m int, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) 
        + Cgerc(m int, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) 
        + Cher(ul Uplo, n int, alpha float32, x []complex64, incX int, a []complex64, lda int) 
        + Chpr(ul Uplo, n int, alpha float32, x []complex64, incX int, a []complex64) 
        + Cher2(ul Uplo, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) 
        + Chpr2(ul Uplo, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, ap []complex64) 

    }
    interface Complex64Level3  {
        + Cgemm(tA Transpose, tB Transpose, m int, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Csymm(s Side, ul Uplo, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Csyrk(ul Uplo, t Transpose, n int, k int, alpha complex64, a []complex64, lda int, beta complex64, c []complex64, ldc int) 
        + Csyr2k(ul Uplo, t Transpose, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Ctrmm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int) 
        + Ctrsm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int) 
        + Chemm(s Side, ul Uplo, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Cherk(ul Uplo, t Transpose, n int, k int, alpha float32, a []complex64, lda int, beta float32, c []complex64, ldc int) 
        + Cher2k(ul Uplo, t Transpose, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta float32, c []complex64, ldc int) 

    }
    class DrotmParams << (S,Aquamarine) >> {
        + H []float64

    }
    interface Float32  {
    }
    interface Float32Level1  {
        + Sdsdot(n int, alpha float32, x []float32, incX int, y []float32, incY int) float32
        + Dsdot(n int, x []float32, incX int, y []float32, incY int) float64
        + Sdot(n int, x []float32, incX int, y []float32, incY int) float32
        + Snrm2(n int, x []float32, incX int) float32
        + Sasum(n int, x []float32, incX int) float32
        + Isamax(n int, x []float32, incX int) int
        + Sswap(n int, x []float32, incX int, y []float32, incY int) 
        + Scopy(n int, x []float32, incX int, y []float32, incY int) 
        + Saxpy(n int, alpha float32, x []float32, incX int, y []float32, incY int) 
        + Srotg(a float32, b float32) (float32, float32, float32, float32)
        + Srotmg(d1 float32, d2 float32, b1 float32, b2 float32) (SrotmParams, float32, float32, float32)
        + Srot(n int, x []float32, incX int, y []float32, incY int, c float32, s float32) 
        + Srotm(n int, x []float32, incX int, y []float32, incY int, p SrotmParams) 
        + Sscal(n int, alpha float32, x []float32, incX int) 

    }
    interface Float32Level2  {
        + Sgemv(tA Transpose, m int, n int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Sgbmv(tA Transpose, m int, n int, kL int, kU int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Strmv(ul Uplo, tA Transpose, d Diag, n int, a []float32, lda int, x []float32, incX int) 
        + Stbmv(ul Uplo, tA Transpose, d Diag, n int, k int, a []float32, lda int, x []float32, incX int) 
        + Stpmv(ul Uplo, tA Transpose, d Diag, n int, ap []float32, x []float32, incX int) 
        + Strsv(ul Uplo, tA Transpose, d Diag, n int, a []float32, lda int, x []float32, incX int) 
        + Stbsv(ul Uplo, tA Transpose, d Diag, n int, k int, a []float32, lda int, x []float32, incX int) 
        + Stpsv(ul Uplo, tA Transpose, d Diag, n int, ap []float32, x []float32, incX int) 
        + Ssymv(ul Uplo, n int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Ssbmv(ul Uplo, n int, k int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Sspmv(ul Uplo, n int, alpha float32, ap []float32, x []float32, incX int, beta float32, y []float32, incY int) 
        + Sger(m int, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) 
        + Ssyr(ul Uplo, n int, alpha float32, x []float32, incX int, a []float32, lda int) 
        + Sspr(ul Uplo, n int, alpha float32, x []float32, incX int, ap []float32) 
        + Ssyr2(ul Uplo, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) 
        + Sspr2(ul Uplo, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32) 

    }
    interface Float32Level3  {
        + Sgemm(tA Transpose, tB Transpose, m int, n int, k int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) 
        + Ssymm(s Side, ul Uplo, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) 
        + Ssyrk(ul Uplo, t Transpose, n int, k int, alpha float32, a []float32, lda int, beta float32, c []float32, ldc int) 
        + Ssyr2k(ul Uplo, t Transpose, n int, k int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) 
        + Strmm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int) 
        + Strsm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int) 

    }
    interface Float64  {
    }
    interface Float64Level1  {
        + Ddot(n int, x []float64, incX int, y []float64, incY int) float64
        + Dnrm2(n int, x []float64, incX int) float64
        + Dasum(n int, x []float64, incX int) float64
        + Idamax(n int, x []float64, incX int) int
        + Dswap(n int, x []float64, incX int, y []float64, incY int) 
        + Dcopy(n int, x []float64, incX int, y []float64, incY int) 
        + Daxpy(n int, alpha float64, x []float64, incX int, y []float64, incY int) 
        + Drotg(a float64, b float64) (float64, float64, float64, float64)
        + Drotmg(d1 float64, d2 float64, b1 float64, b2 float64) (DrotmParams, float64, float64, float64)
        + Drot(n int, x []float64, incX int, y []float64, incY int, c float64, s float64) 
        + Drotm(n int, x []float64, incX int, y []float64, incY int, p DrotmParams) 
        + Dscal(n int, alpha float64, x []float64, incX int) 

    }
    interface Float64Level2  {
        + Dgemv(tA Transpose, m int, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dgbmv(tA Transpose, m int, n int, kL int, kU int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dtrmv(ul Uplo, tA Transpose, d Diag, n int, a []float64, lda int, x []float64, incX int) 
        + Dtbmv(ul Uplo, tA Transpose, d Diag, n int, k int, a []float64, lda int, x []float64, incX int) 
        + Dtpmv(ul Uplo, tA Transpose, d Diag, n int, ap []float64, x []float64, incX int) 
        + Dtrsv(ul Uplo, tA Transpose, d Diag, n int, a []float64, lda int, x []float64, incX int) 
        + Dtbsv(ul Uplo, tA Transpose, d Diag, n int, k int, a []float64, lda int, x []float64, incX int) 
        + Dtpsv(ul Uplo, tA Transpose, d Diag, n int, ap []float64, x []float64, incX int) 
        + Dsymv(ul Uplo, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dsbmv(ul Uplo, n int, k int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dspmv(ul Uplo, n int, alpha float64, ap []float64, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dger(m int, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) 
        + Dsyr(ul Uplo, n int, alpha float64, x []float64, incX int, a []float64, lda int) 
        + Dspr(ul Uplo, n int, alpha float64, x []float64, incX int, ap []float64) 
        + Dsyr2(ul Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) 
        + Dspr2(ul Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64) 

    }
    interface Float64Level3  {
        + Dgemm(tA Transpose, tB Transpose, m int, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 
        + Dsymm(s Side, ul Uplo, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 
        + Dsyrk(ul Uplo, t Transpose, n int, k int, alpha float64, a []float64, lda int, beta float64, c []float64, ldc int) 
        + Dsyr2k(ul Uplo, t Transpose, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 
        + Dtrmm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) 
        + Dtrsm(s Side, ul Uplo, tA Transpose, d Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) 

    }
    class SrotmParams << (S,Aquamarine) >> {
        + H []float32

    }
    class blas.Diag << (T, #FF7700) >>  {
    }
    class blas.Flag << (T, #FF7700) >>  {
    }
    class blas.Side << (T, #FF7700) >>  {
    }
    class blas.Transpose << (T, #FF7700) >>  {
    }
    class blas.Uplo << (T, #FF7700) >>  {
    }
}
"blas.Complex128Level1" *-- "blas.Complex128"
"blas.Complex128Level2" *-- "blas.Complex128"
"blas.Complex128Level3" *-- "blas.Complex128"
"blas.Complex64Level1" *-- "blas.Complex64"
"blas.Complex64Level2" *-- "blas.Complex64"
"blas.Complex64Level3" *-- "blas.Complex64"
"blas.Flag" *-- "blas.DrotmParams"
"blas.Float32Level1" *-- "blas.Float32"
"blas.Float32Level2" *-- "blas.Float32"
"blas.Float32Level3" *-- "blas.Float32"
"blas.Float64Level1" *-- "blas.Float64"
"blas.Float64Level2" *-- "blas.Float64"
"blas.Float64Level3" *-- "blas.Float64"
"blas.Flag" *-- "blas.SrotmParams"


namespace blas32 {
    class Band << (S,Aquamarine) >> {
        + Rows int
        + KL int
        + Stride int
        + Data []float32

        + From(a BandCols) 

    }
    class BandCols << (S,Aquamarine) >> {
        + From(a Band) 

    }
    class General << (S,Aquamarine) >> {
        + Rows int
        + Stride int
        + Data []float32

        + From(a GeneralCols) 

    }
    class GeneralCols << (S,Aquamarine) >> {
        + From(a General) 

    }
    class Symmetric << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []float32
        + Uplo blas.Uplo

        + From(a SymmetricCols) 

    }
    class SymmetricBand << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []float32
        + Uplo blas.Uplo

        + From(a SymmetricBandCols) 

    }
    class SymmetricBandCols << (S,Aquamarine) >> {
        + From(a SymmetricBand) 

    }
    class SymmetricCols << (S,Aquamarine) >> {
        + From(a Symmetric) 

    }
    class SymmetricPacked << (S,Aquamarine) >> {
        + N int
        + Data []float32
        + Uplo blas.Uplo

    }
    class Triangular << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []float32
        + Uplo blas.Uplo
        + Diag blas.Diag

        + From(a TriangularCols) 

    }
    class TriangularBand << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []float32
        + Uplo blas.Uplo
        + Diag blas.Diag

        + From(a TriangularBandCols) 

    }
    class TriangularBandCols << (S,Aquamarine) >> {
        + From(a TriangularBand) 

    }
    class TriangularCols << (S,Aquamarine) >> {
        + From(a Triangular) 

    }
    class TriangularPacked << (S,Aquamarine) >> {
        + N int
        + Data []float32
        + Uplo blas.Uplo
        + Diag blas.Diag

    }
    class Vector << (S,Aquamarine) >> {
        + N int
        + Inc int
        + Data []float32

    }
    class blas32.BandCols << (T, #FF7700) >>  {
    }
    class blas32.GeneralCols << (T, #FF7700) >>  {
    }
    class blas32.SymmetricBandCols << (T, #FF7700) >>  {
    }
    class blas32.SymmetricCols << (T, #FF7700) >>  {
    }
    class blas32.TriangularBandCols << (T, #FF7700) >>  {
    }
    class blas32.TriangularCols << (T, #FF7700) >>  {
    }
}


namespace blas64 {
    class Band << (S,Aquamarine) >> {
        + Rows int
        + KL int
        + Data []float64
        + Stride int

        + From(a BandCols) 

    }
    class BandCols << (S,Aquamarine) >> {
        + From(a Band) 

    }
    class General << (S,Aquamarine) >> {
        + Rows int
        + Data []float64
        + Stride int

        + From(a GeneralCols) 

    }
    class GeneralCols << (S,Aquamarine) >> {
        + From(a General) 

    }
    class Symmetric << (S,Aquamarine) >> {
        + Uplo blas.Uplo
        + N int
        + Data []float64
        + Stride int

        + From(a SymmetricCols) 

    }
    class SymmetricBand << (S,Aquamarine) >> {
        + Uplo blas.Uplo
        + N int
        + Data []float64
        + Stride int

        + From(a SymmetricBandCols) 

    }
    class SymmetricBandCols << (S,Aquamarine) >> {
        + From(a SymmetricBand) 

    }
    class SymmetricCols << (S,Aquamarine) >> {
        + From(a Symmetric) 

    }
    class SymmetricPacked << (S,Aquamarine) >> {
        + Uplo blas.Uplo
        + N int
        + Data []float64

    }
    class Triangular << (S,Aquamarine) >> {
        + Uplo blas.Uplo
        + Diag blas.Diag
        + N int
        + Data []float64
        + Stride int

        + From(a TriangularCols) 

    }
    class TriangularBand << (S,Aquamarine) >> {
        + Uplo blas.Uplo
        + Diag blas.Diag
        + N int
        + Data []float64
        + Stride int

        + From(a TriangularBandCols) 

    }
    class TriangularBandCols << (S,Aquamarine) >> {
        + From(a TriangularBand) 

    }
    class TriangularCols << (S,Aquamarine) >> {
        + From(a Triangular) 

    }
    class TriangularPacked << (S,Aquamarine) >> {
        + Uplo blas.Uplo
        + Diag blas.Diag
        + N int
        + Data []float64

    }
    class Vector << (S,Aquamarine) >> {
        + N int
        + Data []float64
        + Inc int

    }
    class blas64.BandCols << (T, #FF7700) >>  {
    }
    class blas64.GeneralCols << (T, #FF7700) >>  {
    }
    class blas64.SymmetricBandCols << (T, #FF7700) >>  {
    }
    class blas64.SymmetricCols << (T, #FF7700) >>  {
    }
    class blas64.TriangularBandCols << (T, #FF7700) >>  {
    }
    class blas64.TriangularCols << (T, #FF7700) >>  {
    }
}


namespace card {
    class HyperLogLog32 << (S,Aquamarine) >> {
        - p uint8
        - m uint32
        - hash hash.Hash32
        - register []uint8

        + Write(b []byte) (int, error)
        + Union(a *HyperLogLog32, b *HyperLogLog32) error
        + SetHash(fn hash.Hash32) error
        + Count() float64
        + Reset() 
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(b []byte) error

    }
    class HyperLogLog64 << (S,Aquamarine) >> {
        - p uint8
        - m uint64
        - hash hash.Hash64
        - register []uint8

        + Write(b []byte) (int, error)
        + Union(a *HyperLogLog64, b *HyperLogLog64) error
        + SetHash(fn hash.Hash64) error
        + Count() float64
        + Reset() 
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(b []byte) error

    }
    class userType << (S,Aquamarine) >> {
        - fn reflect.Value
        - typ reflect.Type

    }
}

"mat.Reseter" <|-- "card.HyperLogLog32"
"mat.Reseter" <|-- "card.HyperLogLog64"

namespace cblas128 {
    class Band << (S,Aquamarine) >> {
        + Rows int
        + KL int
        + Stride int
        + Data []complex128

        + From(a BandCols) 

    }
    class BandCols << (S,Aquamarine) >> {
        + From(a Band) 

    }
    class General << (S,Aquamarine) >> {
        + Rows int
        + Stride int
        + Data []complex128

        + From(a GeneralCols) 

    }
    class GeneralCols << (S,Aquamarine) >> {
        + From(a General) 

    }
    class Hermitian << (S,Aquamarine) >> {
        + From(a HermitianCols) 

    }
    class HermitianBand << (S,Aquamarine) >> {
        + From(a HermitianBandCols) 

    }
    class HermitianBandCols << (S,Aquamarine) >> {
        + From(a HermitianBand) 

    }
    class HermitianCols << (S,Aquamarine) >> {
        + From(a Hermitian) 

    }
    class Symmetric << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex128
        + Uplo blas.Uplo

        + From(a SymmetricCols) 

    }
    class SymmetricBand << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex128
        + Uplo blas.Uplo

        + From(a SymmetricBandCols) 

    }
    class SymmetricBandCols << (S,Aquamarine) >> {
        + From(a SymmetricBand) 

    }
    class SymmetricCols << (S,Aquamarine) >> {
        + From(a Symmetric) 

    }
    class SymmetricPacked << (S,Aquamarine) >> {
        + N int
        + Data []complex128
        + Uplo blas.Uplo

    }
    class Triangular << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex128
        + Uplo blas.Uplo
        + Diag blas.Diag

        + From(a TriangularCols) 

    }
    class TriangularBand << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex128
        + Uplo blas.Uplo
        + Diag blas.Diag

        + From(a TriangularBandCols) 

    }
    class TriangularBandCols << (S,Aquamarine) >> {
        + From(a TriangularBand) 

    }
    class TriangularCols << (S,Aquamarine) >> {
        + From(a Triangular) 

    }
    class TriangularPacked << (S,Aquamarine) >> {
        + N int
        + Data []complex128
        + Uplo blas.Uplo
        + Diag blas.Diag

    }
    class Vector << (S,Aquamarine) >> {
        + N int
        + Inc int
        + Data []complex128

    }
    class cblas128.BandCols << (T, #FF7700) >>  {
    }
    class cblas128.GeneralCols << (T, #FF7700) >>  {
    }
    class cblas128.Hermitian << (T, #FF7700) >>  {
    }
    class cblas128.HermitianBand << (T, #FF7700) >>  {
    }
    class cblas128.HermitianBandCols << (T, #FF7700) >>  {
    }
    class cblas128.HermitianCols << (T, #FF7700) >>  {
    }
    class cblas128.HermitianPacked << (T, #FF7700) >>  {
    }
    class cblas128.SymmetricBandCols << (T, #FF7700) >>  {
    }
    class cblas128.SymmetricCols << (T, #FF7700) >>  {
    }
    class cblas128.TriangularBandCols << (T, #FF7700) >>  {
    }
    class cblas128.TriangularCols << (T, #FF7700) >>  {
    }
}


namespace cblas64 {
    class Band << (S,Aquamarine) >> {
        + Rows int
        + KL int
        + Stride int
        + Data []complex64

        + From(a BandCols) 

    }
    class BandCols << (S,Aquamarine) >> {
        + From(a Band) 

    }
    class General << (S,Aquamarine) >> {
        + Rows int
        + Stride int
        + Data []complex64

        + From(a GeneralCols) 

    }
    class GeneralCols << (S,Aquamarine) >> {
        + From(a General) 

    }
    class Hermitian << (S,Aquamarine) >> {
        + From(a HermitianCols) 

    }
    class HermitianBand << (S,Aquamarine) >> {
        + From(a HermitianBandCols) 

    }
    class HermitianBandCols << (S,Aquamarine) >> {
        + From(a HermitianBand) 

    }
    class HermitianCols << (S,Aquamarine) >> {
        + From(a Hermitian) 

    }
    class Symmetric << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex64
        + Uplo blas.Uplo

    }
    class SymmetricBand << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex64
        + Uplo blas.Uplo

    }
    class SymmetricPacked << (S,Aquamarine) >> {
        + N int
        + Data []complex64
        + Uplo blas.Uplo

    }
    class Triangular << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex64
        + Uplo blas.Uplo
        + Diag blas.Diag

        + From(a TriangularCols) 

    }
    class TriangularBand << (S,Aquamarine) >> {
        + N int
        + Stride int
        + Data []complex64
        + Uplo blas.Uplo
        + Diag blas.Diag

        + From(a TriangularBandCols) 

    }
    class TriangularBandCols << (S,Aquamarine) >> {
        + From(a TriangularBand) 

    }
    class TriangularCols << (S,Aquamarine) >> {
        + From(a Triangular) 

    }
    class TriangularPacked << (S,Aquamarine) >> {
        + N int
        + Data []complex64
        + Uplo blas.Uplo
        + Diag blas.Diag

    }
    class Vector << (S,Aquamarine) >> {
        + N int
        + Inc int
        + Data []complex64

    }
    class cblas64.BandCols << (T, #FF7700) >>  {
    }
    class cblas64.GeneralCols << (T, #FF7700) >>  {
    }
    class cblas64.Hermitian << (T, #FF7700) >>  {
    }
    class cblas64.HermitianBand << (T, #FF7700) >>  {
    }
    class cblas64.HermitianBandCols << (T, #FF7700) >>  {
    }
    class cblas64.HermitianCols << (T, #FF7700) >>  {
    }
    class cblas64.HermitianPacked << (T, #FF7700) >>  {
    }
    class cblas64.TriangularBandCols << (T, #FF7700) >>  {
    }
    class cblas64.TriangularCols << (T, #FF7700) >>  {
    }
}


namespace coloring {
    interface Terminator  {
        + Done() <font color=blue>chan</font> <font color=blue>struct</font>{}
        + Err() error

    }
    class byDescDegree << (S,Aquamarine) >> {
        - nodes []graph.Node
        - degrees []int

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class dSaturColoring << (S,Aquamarine) >> {
        - colors <font color=blue>map</font>[int64]int
        - uncolored set.Int64s

        - color(id int64) 
        - uncolor(id int64) 

    }
    class saturationDegree << (S,Aquamarine) >> {
        - nodes []graph.Node
        - indexOf <font color=blue>map</font>[int64]int
        - degrees []int
        - adjColors []set.Ints
        - g graph.Undirected
        - colors <font color=blue>map</font>[int64]int
        - work []int

        - reset(colors <font color=blue>map</font>[int64]int) 
        - dsatur() int
        - pass() int
        - same(vi set.Ints, vj set.Ints) int

    }
    class saturationDegreeIterator << (S,Aquamarine) >> {
        - cnt int
        - heuristic <font color=blue>func</font>() int

        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 

    }
}
"coloring.saturationDegree" *-- "coloring.saturationDegreeIterator"

"graph.Iterator" <|-- "coloring.saturationDegreeIterator"
"graph.Nodes" <|-- "coloring.saturationDegreeIterator"
"mat.Reseter" <|-- "coloring.saturationDegreeIterator"

namespace combin {
    class CartesianGenerator << (S,Aquamarine) >> {
        - lens []int
        - rows int
        - idx int

        + Next() bool
        + Product(dst []int) []int

    }
    class CombinationGenerator << (S,Aquamarine) >> {
        - n int
        - k int
        - previous []int
        - remaining int

        + Next() bool
        + Combination(dst []int) []int

    }
    class PermutationGenerator << (S,Aquamarine) >> {
        - n int
        - k int
        - nPerm int
        - idx int
        - permutation []int

        + Next() bool
        + Permutation(dst []int) []int

    }
    class sortInts << (S,Aquamarine) >> {
        - data []int
        - idx []int

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
}


namespace community {
    class DirectedLayers << (S,Aquamarine) >> {
        + Nodes() graph.Nodes
        + Depth() int
        + Layer(l int) graph.Directed

    }
    interface DirectedMultiplex  {
        + Layer(l int) graph.Directed

    }
    class Interval << (S,Aquamarine) >> {
        + Low float64
        + Score float64

    }
    interface Multiplex  {
        + Nodes() graph.Nodes
        + Depth() int

    }
    interface Reduced  {
        + Communities() [][]graph.Node

    }
    class ReducedDirected << (S,Aquamarine) >> {
        - nodes []community
        - communities [][]graph.Node
        - parent *ReducedDirected

        - has(id int64) bool

        + Communities() [][]graph.Node
        + Structure() [][]graph.Node
        + Expanded() ReducedGraph
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + From(uid int64) graph.Nodes
        + To(vid int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + Edge(uid int64, vid int64) graph.Edge
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)

    }
    class ReducedDirectedMultiplex << (S,Aquamarine) >> {
        - nodes []multiplexCommunity
        - layers []directedEdges
        - communities [][]graph.Node
        - parent *ReducedDirectedMultiplex

        + Nodes() graph.Nodes
        + Depth() int
        + Layer(l int) graph.Directed
        + Communities() [][]graph.Node
        + Structure() [][]graph.Node
        + Expanded() ReducedMultiplex

    }
    interface ReducedGraph  {
        + Communities() [][]graph.Node
        + Structure() [][]graph.Node
        + Expanded() ReducedGraph

    }
    interface ReducedMultiplex  {
        + Communities() [][]graph.Node
        + Structure() [][]graph.Node
        + Expanded() ReducedMultiplex

    }
    class ReducedUndirected << (S,Aquamarine) >> {
        - nodes []community
        - communities [][]graph.Node
        - parent *ReducedUndirected

        - has(id int64) bool

        + Communities() [][]graph.Node
        + Structure() [][]graph.Node
        + Expanded() ReducedGraph
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + From(uid int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Edge(uid int64, vid int64) graph.Edge
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + EdgeBetween(xid int64, yid int64) graph.Edge
        + WeightedEdgeBetween(xid int64, yid int64) graph.WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)

    }
    class ReducedUndirectedMultiplex << (S,Aquamarine) >> {
        - nodes []multiplexCommunity
        - layers []undirectedEdges
        - communities [][]graph.Node
        - parent *ReducedUndirectedMultiplex

        + Nodes() graph.Nodes
        + Depth() int
        + Layer(l int) graph.Undirected
        + Communities() [][]graph.Node
        + Structure() [][]graph.Node
        + Expanded() ReducedMultiplex

    }
    class UndirectedLayers << (S,Aquamarine) >> {
        + Nodes() graph.Nodes
        + Depth() int
        + Layer(l int) graph.Undirected

    }
    interface UndirectedMultiplex  {
        + Layer(l int) graph.Undirected

    }
    class commIdx << (S,Aquamarine) >> {
        - community int
        - node int

    }
    class community << (S,Aquamarine) >> {
        - id int
        - nodes []graph.Node
        - weight float64

        + ID() int64

    }
    class community.DirectedLayers << (T, #FF7700) >>  {
    }
    class community.UndirectedLayers << (T, #FF7700) >>  {
    }
    class community.node << (T, #FF7700) >>  {
    }
    class community.nonDecreasing << (T, #FF7700) >>  {
    }
    class dense << (S,Aquamarine) >> {
        - pos int
        - n int

        + TakeMin(p *int) bool

    }
    class directedEdges << (S,Aquamarine) >> {
        - edgesFrom [][]int
        - edgesTo [][]int
        - weights <font color=blue>map</font>[[]int]float64

    }
    class directedLayerHandle << (S,Aquamarine) >> {
        - multiplex *ReducedDirectedMultiplex
        - layer int

        - has(id int64) bool

        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + From(uid int64) graph.Nodes
        + To(vid int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + Edge(uid int64, vid int64) graph.Edge
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)

    }
    class directedLocalMover << (S,Aquamarine) >> {
        - g *ReducedDirected
        - nodes []graph.Node
        - edgeWeightsOf []directedWeights
        - m float64
        - weight <font color=blue>func</font>(int64, int64) float64
        - communities [][]graph.Node
        - memberships []int
        - resolution float64
        - moved bool
        - changed bool

        - localMovingHeuristic(rnd <font color=blue>func</font>(int) int) bool
        - shuffle(rnd <font color=blue>func</font>(int) int) 
        - move(dst int, src commIdx) 
        - deltaQ(n graph.Node) (float64, int, commIdx)

    }
    class directedMultiplexLocalMover << (S,Aquamarine) >> {
        - g *ReducedDirectedMultiplex
        - nodes []graph.Node
        - edgeWeightsOf [][]directedWeights
        - m []float64
        - weight []<font color=blue>func</font>(int64, int64) float64
        - communities [][]graph.Node
        - memberships []int
        - resolutions []float64
        - weights []float64
        - searchAll bool
        - moved bool
        - changed bool

        - localMovingHeuristic(rnd <font color=blue>func</font>(int) int) bool
        - shuffle(rnd <font color=blue>func</font>(int) int) 
        - move(dst int, src commIdx) 
        - deltaQ(n graph.Node) (float64, int, commIdx)

    }
    class directedWeights << (S,Aquamarine) >> {
        - out float64

    }
    class edge << (S,Aquamarine) >> {
        - from community
        - weight float64

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge
        + Weight() float64

    }
    interface minTaker  {
        + TakeMin(p *int) bool

    }
    class multiplexCommunity << (S,Aquamarine) >> {
        - id int
        - nodes []graph.Node
        - weights []float64

        + ID() int64

    }
    class multiplexEdge << (S,Aquamarine) >> {
        - from multiplexCommunity
        - weight float64

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge
        + Weight() float64

    }
    class node << (S,Aquamarine) >> {
        + ID() int64

    }
    class nonDecreasing << (S,Aquamarine) >> {
        + Error() string

    }
    class slice << (S,Aquamarine) >> {
        - pos int
        - elems []int

        + TakeMin(p *int) bool

    }
    class undirectedEdges << (S,Aquamarine) >> {
        - edges [][]int
        - weights <font color=blue>map</font>[[]int]float64

    }
    class undirectedLayerHandle << (S,Aquamarine) >> {
        - multiplex *ReducedUndirectedMultiplex
        - layer int

        - has(id int64) bool

        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + From(uid int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Edge(uid int64, vid int64) graph.Edge
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + EdgeBetween(xid int64, yid int64) graph.Edge
        + WeightedEdgeBetween(xid int64, yid int64) graph.WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)

    }
    class undirectedLocalMover << (S,Aquamarine) >> {
        - g *ReducedUndirected
        - nodes []graph.Node
        - edgeWeightOf []float64
        - m2 float64
        - weight <font color=blue>func</font>(int64, int64) float64
        - communities [][]graph.Node
        - memberships []int
        - resolution float64
        - moved bool
        - changed bool

        - localMovingHeuristic(rnd <font color=blue>func</font>(int) int) bool
        - shuffle(rnd <font color=blue>func</font>(int) int) 
        - move(dst int, src commIdx) 
        - deltaQ(n graph.Node) (float64, int, commIdx)

    }
    class undirectedMultiplexLocalMover << (S,Aquamarine) >> {
        - g *ReducedUndirectedMultiplex
        - nodes []graph.Node
        - edgeWeightOf [][]float64
        - m2 []float64
        - weight []<font color=blue>func</font>(int64, int64) float64
        - communities [][]graph.Node
        - memberships []int
        - resolutions []float64
        - weights []float64
        - searchAll bool
        - moved bool
        - changed bool

        - localMovingHeuristic(rnd <font color=blue>func</font>(int) int) bool
        - shuffle(rnd <font color=blue>func</font>(int) int) 
        - move(dst int, src commIdx) 
        - deltaQ(n graph.Node) (float64, int, commIdx)

    }
    class "[]graph.Directed" as graphDirected {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]graph.Undirected" as graphUndirected {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"community.Multiplex" *-- "community.DirectedMultiplex"
"community.Reduced" *-- "community.Interval"
"community.directedEdges" *-- "community.ReducedDirected"
"community.Multiplex" *-- "community.ReducedMultiplex"
"community.undirectedEdges" *-- "community.ReducedUndirected"
"community.Multiplex" *-- "community.UndirectedMultiplex"

"community.DirectedMultiplex" <|-- "community.DirectedLayers"
"community.Multiplex" <|-- "community.DirectedLayers"
"community.Reduced" <|-- "community.ReducedDirected"
"community.ReducedGraph" <|-- "community.ReducedDirected"
"gen.GraphBuilder" <|-- "community.ReducedDirected"
"graph.Directed" <|-- "community.ReducedDirected"
"graph.DirectedMultigraph" <|-- "community.ReducedDirected"
"graph.Graph" <|-- "community.ReducedDirected"
"graph.Weighted" <|-- "community.ReducedDirected"
"graph.WeightedDirected" <|-- "community.ReducedDirected"
"graph.WeightedDirectedMultigraph" <|-- "community.ReducedDirected"
"path.Weighted" <|-- "community.ReducedDirected"
"traverse.Graph" <|-- "community.ReducedDirected"
"community.DirectedMultiplex" <|-- "community.ReducedDirectedMultiplex"
"community.Multiplex" <|-- "community.ReducedDirectedMultiplex"
"community.Reduced" <|-- "community.ReducedDirectedMultiplex"
"community.ReducedMultiplex" <|-- "community.ReducedDirectedMultiplex"
"community.Reduced" <|-- "community.ReducedUndirected"
"community.ReducedGraph" <|-- "community.ReducedUndirected"
"gen.GraphBuilder" <|-- "community.ReducedUndirected"
"graph.Graph" <|-- "community.ReducedUndirected"
"graph.Undirected" <|-- "community.ReducedUndirected"
"graph.Weighted" <|-- "community.ReducedUndirected"
"graph.WeightedUndirected" <|-- "community.ReducedUndirected"
"path.Weighted" <|-- "community.ReducedUndirected"
"traverse.Graph" <|-- "community.ReducedUndirected"
"community.Multiplex" <|-- "community.ReducedUndirectedMultiplex"
"community.Reduced" <|-- "community.ReducedUndirectedMultiplex"
"community.ReducedMultiplex" <|-- "community.ReducedUndirectedMultiplex"
"community.UndirectedMultiplex" <|-- "community.ReducedUndirectedMultiplex"
"community.Multiplex" <|-- "community.UndirectedLayers"
"community.UndirectedMultiplex" <|-- "community.UndirectedLayers"
"graph.Node" <|-- "community.community"
"community.minTaker" <|-- "community.dense"
"gen.GraphBuilder" <|-- "community.directedLayerHandle"
"graph.Directed" <|-- "community.directedLayerHandle"
"graph.DirectedMultigraph" <|-- "community.directedLayerHandle"
"graph.Graph" <|-- "community.directedLayerHandle"
"graph.Weighted" <|-- "community.directedLayerHandle"
"graph.WeightedDirected" <|-- "community.directedLayerHandle"
"graph.WeightedDirectedMultigraph" <|-- "community.directedLayerHandle"
"path.Weighted" <|-- "community.directedLayerHandle"
"traverse.Graph" <|-- "community.directedLayerHandle"
"dot.basicEdge" <|-- "community.edge"
"graph.Edge" <|-- "community.edge"
"graph.WeightedEdge" <|-- "community.edge"
"graph.WeightedLine" <|-- "community.edge"
"testgraph.Edge" <|-- "community.edge"
"graph.Node" <|-- "community.multiplexCommunity"
"dot.basicEdge" <|-- "community.multiplexEdge"
"graph.Edge" <|-- "community.multiplexEdge"
"graph.WeightedEdge" <|-- "community.multiplexEdge"
"graph.WeightedLine" <|-- "community.multiplexEdge"
"testgraph.Edge" <|-- "community.multiplexEdge"
"graph.Node" <|-- "community.node"
"community.minTaker" <|-- "community.slice"
"gen.GraphBuilder" <|-- "community.undirectedLayerHandle"
"graph.Graph" <|-- "community.undirectedLayerHandle"
"graph.Undirected" <|-- "community.undirectedLayerHandle"
"graph.Weighted" <|-- "community.undirectedLayerHandle"
"graph.WeightedUndirected" <|-- "community.undirectedLayerHandle"
"path.Weighted" <|-- "community.undirectedLayerHandle"
"traverse.Graph" <|-- "community.undirectedLayerHandle"

namespace constant {
    class avogadroUnits << (S,Aquamarine) >> {
        + Unit() *unit.Unit
        + Format(fs fmt.State, c rune) 

    }
    class boltzmannUnits << (S,Aquamarine) >> {
        + Unit() *unit.Unit
        + Format(fs fmt.State, c rune) 

    }
    class constant.avogadroUnits << (T, #FF7700) >>  {
    }
    class constant.boltzmannUnits << (T, #FF7700) >>  {
    }
    class constant.electricConstantUnits << (T, #FF7700) >>  {
    }
    class constant.faradayUnits << (T, #FF7700) >>  {
    }
    class constant.gravitationalUnits << (T, #FF7700) >>  {
    }
    class constant.magneticConstantUnits << (T, #FF7700) >>  {
    }
    class constant.planckUnits << (T, #FF7700) >>  {
    }
    class electricConstantUnits << (S,Aquamarine) >> {
        + Unit() *unit.Unit
        + Format(fs fmt.State, c rune) 

    }
    class faradayUnits << (S,Aquamarine) >> {
        + Unit() *unit.Unit
        + Format(fs fmt.State, c rune) 

    }
    class gravitationalUnits << (S,Aquamarine) >> {
        + Unit() *unit.Unit
        + Format(fs fmt.State, c rune) 

    }
    class magneticConstantUnits << (S,Aquamarine) >> {
        + Unit() *unit.Unit
        + Format(fs fmt.State, c rune) 

    }
    class planckUnits << (S,Aquamarine) >> {
        + Unit() *unit.Unit
        + Format(fs fmt.State, c rune) 

    }
}

"unit.Uniter" <|-- "constant.avogadroUnits"
"unit.Uniter" <|-- "constant.boltzmannUnits"
"unit.Uniter" <|-- "constant.electricConstantUnits"
"unit.Uniter" <|-- "constant.faradayUnits"
"unit.Uniter" <|-- "constant.gravitationalUnits"
"unit.Uniter" <|-- "constant.magneticConstantUnits"
"unit.Uniter" <|-- "constant.planckUnits"

namespace cscalar {
    class parseError << (S,Aquamarine) >> {
        - string string
        - state int
        - rune rune

        + Error() string

    }
}


namespace cytoscapejs {
    class Edge << (S,Aquamarine) >> {
        + Data EdgeData
        + Selected bool
        + Selectable bool
        + Classes string
        + Scratch <font color=blue>interface</font>{}

    }
    class EdgeData << (S,Aquamarine) >> {
        + ID string
        + Source string
        + Target string
        + Attributes <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(data []byte) error

    }
    class ElemData << (S,Aquamarine) >> {
        + ID string
        + Source string
        + Target string
        + Parent string
        + Attributes <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(data []byte) error

    }
    class Element << (S,Aquamarine) >> {
        + Group string
        + Data ElemData
        + Position *Position
        + RenderedPosition *Position
        + Selected bool
        + Selectable bool
        + Locked bool
        + Grabbable bool
        + Classes string
        + Scratch <font color=blue>interface</font>{}

        + Type() (ElemType, error)

    }
    class Elements << (S,Aquamarine) >> {
        + Nodes []Node
        + Edges []Edge

    }
    class GraphElem << (S,Aquamarine) >> {
        + Elements []Element
        + Layout <font color=blue>interface</font>{}
        + Style []<font color=blue>interface</font>{}

    }
    class GraphNodeEdge << (S,Aquamarine) >> {
        + Elements Elements
        + Layout <font color=blue>interface</font>{}
        + Style []<font color=blue>interface</font>{}

    }
    class Node << (S,Aquamarine) >> {
        + Data NodeData
        + Position *Position
        + RenderedPosition *Position
        + Selected bool
        + Selectable bool
        + Locked bool
        + Grabbable bool
        + Classes string
        + Scratch <font color=blue>interface</font>{}

    }
    class NodeData << (S,Aquamarine) >> {
        + ID string
        + Parent string
        + Attributes <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(data []byte) error

    }
    class Position << (S,Aquamarine) >> {
        + X float64
        + Y float64

    }
    class cytoscapejs.ElemType << (T, #FF7700) >>  {
    }
}


namespace digraph6 {
    class Graph << (S,Aquamarine) >> {
        + Edge(uid int64, vid int64) graph.Edge
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + To(id int64) graph.Nodes
        + GoString() string

    }
    class d6ForwardIterator << (S,Aquamarine) >> {
        - g Graph
        - from int64
        - to int64

        + Next() bool
        + Len() int
        + Reset() 
        + Node() graph.Node

    }
    class d6ReverseIterator << (S,Aquamarine) >> {
        - g Graph
        - from int64
        - to int64

        + Next() bool
        + Len() int
        + Reset() 
        + Node() graph.Node

    }
    class digraph6.Graph << (T, #FF7700) >>  {
    }
}

"gen.GraphBuilder" <|-- "digraph6.Graph"
"graph.Directed" <|-- "digraph6.Graph"
"graph.DirectedMultigraph" <|-- "digraph6.Graph"
"graph.Graph" <|-- "digraph6.Graph"
"graph.WeightedDirected" <|-- "digraph6.Graph"
"graph.WeightedDirectedMultigraph" <|-- "digraph6.Graph"
"traverse.Graph" <|-- "digraph6.Graph"
"graph.Iterator" <|-- "digraph6.d6ForwardIterator"
"graph.Nodes" <|-- "digraph6.d6ForwardIterator"
"mat.Reseter" <|-- "digraph6.d6ForwardIterator"
"graph.Iterator" <|-- "digraph6.d6ReverseIterator"
"graph.Nodes" <|-- "digraph6.d6ReverseIterator"
"mat.Reseter" <|-- "digraph6.d6ReverseIterator"

namespace distmat {
    class UniformPermutation << (S,Aquamarine) >> {
        - rnd *rand.Rand
        - indices []int

        + PermTo(dst *mat.Dense) 

    }
    class UnitVector << (S,Aquamarine) >> {
        - norm distuv.Normal

        + UnitVecTo(dst *mat.VecDense) 

    }
    class Wishart << (S,Aquamarine) >> {
        - nu float64
        - src rand.Source
        - dim int
        - cholv mat.Cholesky
        - logdetv float64
        - upper mat.TriDense
        - once sync.Once
        - v *mat.SymDense

        - logProbSymChol(cholX *mat.Cholesky) float64
        - setV() 

        + MeanSymTo(dst *mat.SymDense) 
        + ProbSym(x mat.Symmetric) float64
        + LogProbSym(x mat.Symmetric) float64
        + LogProbSymChol(cholX *mat.Cholesky) float64
        + RandSymTo(dst *mat.SymDense) 
        + RandCholTo(dst *mat.Cholesky) 

    }
}


namespace distmv {
    class Bhattacharyya << (S,Aquamarine) >> {
        + DistNormal(l *Normal, r *Normal) float64
        + DistUniform(l *Uniform, r *Uniform) float64

    }
    class CrossEntropy << (S,Aquamarine) >> {
        + DistNormal(l *Normal, r *Normal) float64

    }
    class Dirichlet << (S,Aquamarine) >> {
        - alpha []float64
        - dim int
        - src rand.Source
        - lbeta float64
        - sumAlpha float64

        - genLBeta(alpha []float64) (float64, float64)

        + CovarianceMatrix(dst *mat.SymDense) 
        + Dim() int
        + LogProb(x []float64) float64
        + Mean(x []float64) []float64
        + Prob(x []float64) float64
        + Rand(x []float64) []float64

    }
    class Hellinger << (S,Aquamarine) >> {
        + DistNormal(l *Normal, r *Normal) float64

    }
    class KullbackLeibler << (S,Aquamarine) >> {
        + DistDirichlet(l *Dirichlet, r *Dirichlet) float64
        + DistNormal(l *Normal, r *Normal) float64
        + DistUniform(l *Uniform, r *Uniform) float64

    }
    interface LogProber  {
        + LogProb(x []float64) float64

    }
    class Normal << (S,Aquamarine) >> {
        - mu []float64
        - sigma mat.SymDense
        - chol mat.Cholesky
        - logSqrtDet float64
        - dim int
        - src rand.Source
        - rnd *rand.Rand

        + ConditionNormal(observed []int, values []float64, src rand.Source) (*Normal, bool)
        + CovarianceMatrix(dst *mat.SymDense) 
        + Dim() int
        + Entropy() float64
        + LogProb(x []float64) float64
        + MarginalNormal(vars []int, src rand.Source) (*Normal, bool)
        + MarginalNormalSingle(i int, src rand.Source) distuv.Normal
        + Mean(x []float64) []float64
        + Prob(x []float64) float64
        + Quantile(x []float64, p []float64) []float64
        + Rand(x []float64) []float64
        + ScoreInput(score []float64, x []float64) []float64
        + SetMean(mu []float64) 
        + TransformNormal(dst []float64, normal []float64) []float64

    }
    interface Quantiler  {
        + Quantile(x []float64, p []float64) []float64

    }
    interface RandLogProber  {
    }
    interface Rander  {
        + Rand(x []float64) []float64

    }
    class Renyi << (S,Aquamarine) >> {
        + Alpha float64

        + DistNormal(l *Normal, r *Normal) float64

    }
    class StudentsT << (S,Aquamarine) >> {
        - nu float64
        - mu []float64
        - src rand.Source
        - rnd *rand.Rand
        - sigma mat.SymDense
        - chol mat.Cholesky
        - lower mat.TriDense
        - logSqrtDet float64
        - dim int

        + ConditionStudentsT(observed []int, values []float64, src rand.Source) (*StudentsT, bool)
        + CovarianceMatrix(dst *mat.SymDense) 
        + Dim() int
        + LogProb(y []float64) float64
        + MarginalStudentsT(vars []int, src rand.Source) (*StudentsT, bool)
        + MarginalStudentsTSingle(i int, src rand.Source) distuv.StudentsT
        + Mean(x []float64) []float64
        + Nu() float64
        + Prob(y []float64) float64
        + Rand(x []float64) []float64

    }
    class Uniform << (S,Aquamarine) >> {
        - bounds []r1.Interval
        - dim int
        - rnd *rand.Rand

        + Bounds(bounds []r1.Interval) []r1.Interval
        + CDF(p []float64, x []float64) []float64
        + Dim() int
        + Entropy() float64
        + LogProb(x []float64) float64
        + Mean(x []float64) []float64
        + Prob(x []float64) float64
        + Rand(x []float64) []float64
        + Quantile(x []float64, p []float64) []float64

    }
    class Wasserstein << (S,Aquamarine) >> {
        + DistNormal(l *Normal, r *Normal) float64

    }
}
"distmv.LogProber" *-- "distmv.RandLogProber"
"distmv.Rander" *-- "distmv.RandLogProber"

"distmv.LogProber" <|-- "distmv.Dirichlet"
"distmv.Rander" <|-- "distmv.Dirichlet"
"distmv.LogProber" <|-- "distmv.Normal"
"distmv.Quantiler" <|-- "distmv.Normal"
"distmv.Rander" <|-- "distmv.Normal"
"distmv.LogProber" <|-- "distmv.StudentsT"
"distmv.Rander" <|-- "distmv.StudentsT"
"distmv.LogProber" <|-- "distmv.Uniform"
"distmv.Quantiler" <|-- "distmv.Uniform"
"distmv.Rander" <|-- "distmv.Uniform"

namespace distuv {
    class AlphaStable << (S,Aquamarine) >> {
        + Alpha float64
        + Beta float64
        + C float64
        + Mu float64
        + Src rand.Source

        + ExKurtosis() float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Rand() float64
        + Skewness() float64
        + StdDev() float64
        + Variance() float64

    }
    class Bernoulli << (S,Aquamarine) >> {
        + P float64
        + Src rand.Source

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Beta << (S,Aquamarine) >> {
        + Alpha float64
        + Beta float64
        + Src rand.Source

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Bhattacharyya << (S,Aquamarine) >> {
        + DistBeta(l Beta, r Beta) float64
        + DistNormal(l Normal, r Normal) float64

    }
    class Binomial << (S,Aquamarine) >> {
        + N float64
        + P float64
        + Src rand.Source

        + CDF(x float64) float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Rand() float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Categorical << (S,Aquamarine) >> {
        - weights []float64
        - heap []float64
        - src rand.Source

        - reset() 

        + CDF(x float64) float64
        + Entropy() float64
        + Len() int
        + Mean() float64
        + Prob(x float64) float64
        + LogProb(x float64) float64
        + Rand() float64
        + Reweight(idx int, w float64) 
        + ReweightAll(w []float64) 

    }
    class Chi << (S,Aquamarine) >> {
        + K float64
        + Src rand.Source

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Rand() float64
        + Quantile(p float64) float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class ChiSquared << (S,Aquamarine) >> {
        + K float64
        + Src rand.Source

        + CDF(x float64) float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Rand() float64
        + Quantile(p float64) float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Exponential << (S,Aquamarine) >> {
        + Rate float64
        + Src rand.Source

        - setParameters(p []Parameter) 
        - parameters(p []Parameter) []Parameter

        + CDF(x float64) float64
        + ConjugateUpdate(suffStat []float64, nSamples float64, priorStrength []float64) 
        + Entropy() float64
        + ExKurtosis() float64
        + Fit(samples []float64, weights []float64) 
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + NumSuffStat() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Score(deriv []float64, x float64) []float64
        + ScoreInput(x float64) float64
        + Skewness() float64
        + StdDev() float64
        + SuffStat(suffStat []float64, samples []float64, weights []float64) float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class F << (S,Aquamarine) >> {
        + D1 float64
        + D2 float64
        + Src rand.Source

        + CDF(x float64) float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Gamma << (S,Aquamarine) >> {
        + Alpha float64
        + Beta float64
        + Src rand.Source

        + CDF(x float64) float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Survival(x float64) float64
        + StdDev() float64
        + Variance() float64

    }
    class GumbelRight << (S,Aquamarine) >> {
        + Mu float64
        + Beta float64
        + Src rand.Source

        - z(x float64) float64

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Hellinger << (S,Aquamarine) >> {
        + DistBeta(l Beta, r Beta) float64
        + DistNormal(l Normal, r Normal) float64

    }
    class InverseGamma << (S,Aquamarine) >> {
        + Alpha float64
        + Beta float64
        + Src rand.Source

        + CDF(x float64) float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Survival(x float64) float64
        + StdDev() float64
        + Variance() float64

    }
    class KullbackLeibler << (S,Aquamarine) >> {
        + DistBeta(l Beta, r Beta) float64
        + DistNormal(l Normal, r Normal) float64

    }
    class Laplace << (S,Aquamarine) >> {
        + Mu float64
        + Scale float64
        + Src rand.Source

        - parameters(p []Parameter) []Parameter
        - setParameters(p []Parameter) 

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + Fit(samples []float64, weights []float64) 
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Quantile(p float64) float64
        + Prob(x float64) float64
        + Rand() float64
        + Score(deriv []float64, x float64) []float64
        + ScoreInput(x float64) float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class LogNormal << (S,Aquamarine) >> {
        + Mu float64
        + Sigma float64
        + Src rand.Source

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    interface LogProber  {
        + LogProb(x float64) float64

    }
    class Logistic << (S,Aquamarine) >> {
        + Mu float64
        + S float64

        + CDF(x float64) float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Mode() float64
        + Median() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Normal << (S,Aquamarine) >> {
        + Mu float64
        + Sigma float64
        + Src rand.Source

        - setParameters(p []Parameter) 
        - parameters(p []Parameter) []Parameter

        + CDF(x float64) float64
        + ConjugateUpdate(suffStat []float64, nSamples float64, priorStrength []float64) 
        + Entropy() float64
        + ExKurtosis() float64
        + Fit(samples []float64, weights []float64) 
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + NumSuffStat() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Score(deriv []float64, x float64) []float64
        + ScoreInput(x float64) float64
        + Skewness() float64
        + StdDev() float64
        + SuffStat(suffStat []float64, samples []float64, weights []float64) float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Parameter << (S,Aquamarine) >> {
        + Name string
        + Value float64

    }
    class Pareto << (S,Aquamarine) >> {
        + Xm float64
        + Alpha float64
        + Src rand.Source

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(prob float64) float64
        + Rand() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Poisson << (S,Aquamarine) >> {
        + Lambda float64
        + Src rand.Source

        + CDF(x float64) float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Rand() float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    interface Quantiler  {
        + Quantile(p float64) float64

    }
    interface RandLogProber  {
    }
    interface Rander  {
        + Rand() float64

    }
    class StudentsT << (S,Aquamarine) >> {
        + Mu float64
        + Sigma float64
        + Nu float64
        + Src rand.Source

        + CDF(x float64) float64
        + LogProb(x float64) float64
        + Mean() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Triangle << (S,Aquamarine) >> {
        - a float64
        - src rand.Source

        - parameters(p []Parameter) []Parameter
        - setParameters(p []Parameter) 

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Score(deriv []float64, x float64) []float64
        + ScoreInput(x float64) float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Uniform << (S,Aquamarine) >> {
        + Min float64
        + Max float64
        + Src rand.Source

        - parameters(p []Parameter) []Parameter
        - setParameters(p []Parameter) 

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + Mean() float64
        + Median() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Score(deriv []float64, x float64) []float64
        + ScoreInput(x float64) float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
    class Weibull << (S,Aquamarine) >> {
        + K float64
        + Lambda float64
        + Src rand.Source

        - gammaIPow(i float64, pow float64) float64
        - setParameters(p []Parameter) 
        - parameters(p []Parameter) []Parameter

        + CDF(x float64) float64
        + Entropy() float64
        + ExKurtosis() float64
        + LogProb(x float64) float64
        + LogSurvival(x float64) float64
        + Mean() float64
        + Median() float64
        + Mode() float64
        + NumParameters() int
        + Prob(x float64) float64
        + Quantile(p float64) float64
        + Rand() float64
        + Score(deriv []float64, x float64) []float64
        + ScoreInput(x float64) float64
        + Skewness() float64
        + StdDev() float64
        + Survival(x float64) float64
        + Variance() float64

    }
}
"distuv.LogProber" *-- "distuv.RandLogProber"
"distuv.Rander" *-- "distuv.RandLogProber"

"distuv.Rander" <|-- "distuv.AlphaStable"
"distuv.LogProber" <|-- "distuv.Bernoulli"
"distuv.Quantiler" <|-- "distuv.Bernoulli"
"distuv.Rander" <|-- "distuv.Bernoulli"
"distuv.LogProber" <|-- "distuv.Beta"
"distuv.Quantiler" <|-- "distuv.Beta"
"distuv.Rander" <|-- "distuv.Beta"
"distuv.LogProber" <|-- "distuv.Binomial"
"distuv.Rander" <|-- "distuv.Binomial"
"distuv.LogProber" <|-- "distuv.Categorical"
"distuv.Rander" <|-- "distuv.Categorical"
"distuv.LogProber" <|-- "distuv.Chi"
"distuv.Quantiler" <|-- "distuv.Chi"
"distuv.Rander" <|-- "distuv.Chi"
"distuv.LogProber" <|-- "distuv.ChiSquared"
"distuv.Quantiler" <|-- "distuv.ChiSquared"
"distuv.Rander" <|-- "distuv.ChiSquared"
"distuv.LogProber" <|-- "distuv.Exponential"
"distuv.Quantiler" <|-- "distuv.Exponential"
"distuv.Rander" <|-- "distuv.Exponential"
"distuv.LogProber" <|-- "distuv.F"
"distuv.Quantiler" <|-- "distuv.F"
"distuv.Rander" <|-- "distuv.F"
"distuv.LogProber" <|-- "distuv.Gamma"
"distuv.Quantiler" <|-- "distuv.Gamma"
"distuv.Rander" <|-- "distuv.Gamma"
"distuv.LogProber" <|-- "distuv.GumbelRight"
"distuv.Quantiler" <|-- "distuv.GumbelRight"
"distuv.Rander" <|-- "distuv.GumbelRight"
"distuv.LogProber" <|-- "distuv.InverseGamma"
"distuv.Quantiler" <|-- "distuv.InverseGamma"
"distuv.Rander" <|-- "distuv.InverseGamma"
"distuv.LogProber" <|-- "distuv.Laplace"
"distuv.Quantiler" <|-- "distuv.Laplace"
"distuv.Rander" <|-- "distuv.Laplace"
"distuv.LogProber" <|-- "distuv.LogNormal"
"distuv.Quantiler" <|-- "distuv.LogNormal"
"distuv.Rander" <|-- "distuv.LogNormal"
"distuv.LogProber" <|-- "distuv.Logistic"
"distuv.Quantiler" <|-- "distuv.Logistic"
"distuv.LogProber" <|-- "distuv.Normal"
"distuv.Quantiler" <|-- "distuv.Normal"
"distuv.Rander" <|-- "distuv.Normal"
"distuv.LogProber" <|-- "distuv.Pareto"
"distuv.Quantiler" <|-- "distuv.Pareto"
"distuv.Rander" <|-- "distuv.Pareto"
"distuv.LogProber" <|-- "distuv.Poisson"
"distuv.Rander" <|-- "distuv.Poisson"
"distuv.LogProber" <|-- "distuv.StudentsT"
"distuv.Quantiler" <|-- "distuv.StudentsT"
"distuv.Rander" <|-- "distuv.StudentsT"
"distuv.LogProber" <|-- "distuv.Triangle"
"distuv.Quantiler" <|-- "distuv.Triangle"
"distuv.Rander" <|-- "distuv.Triangle"
"distuv.LogProber" <|-- "distuv.Uniform"
"distuv.Quantiler" <|-- "distuv.Uniform"
"distuv.Rander" <|-- "distuv.Uniform"
"distuv.LogProber" <|-- "distuv.Weibull"
"distuv.Quantiler" <|-- "distuv.Weibull"
"distuv.Rander" <|-- "distuv.Weibull"

namespace dot {
    interface AttributeSetters  {
        + DOTAttributeSetters() (encoding.AttributeSetter, encoding.AttributeSetter, encoding.AttributeSetter)

    }
    interface Attributers  {
        + DOTAttributers() (encoding.Attributer, encoding.Attributer, encoding.Attributer)

    }
    interface DOTIDSetter  {
        + SetDOTID(id string) 

    }
    interface Graph  {
        + DOTID() string

    }
    interface MultiStructurer  {
        + Structure() []Multigraph

    }
    interface MultiSubgrapher  {
        + Subgraph() graph.Multigraph

    }
    interface Multigraph  {
        + DOTID() string

    }
    interface Node  {
        + DOTID() string

    }
    interface PortSetter  {
        + SetFromPort(port string, compass string) error
        + SetToPort(port string, compass string) error

    }
    interface Porter  {
        + FromPort() (string, string)
        + ToPort() (string, string)

    }
    interface Structurer  {
        + Structure() []Graph

    }
    interface Subgrapher  {
        + Subgraph() graph.Graph

    }
    interface basicEdge  {
        + From() graph.Node
        + To() graph.Node

    }
    class edge << (S,Aquamarine) >> {
        - inGraph string
        - from int64

    }
    class generator << (S,Aquamarine) >> {
        - directed bool
        - ids <font color=blue>map</font>[string]graph.Node
        - subNodes []graph.Node
        - subStart []int
        - graphAttr encoding.AttributeSetter

        - node(dst graph.NodeAdder, id string) graph.Node
        - pushSubgraph() 
        - popSubgraph() []graph.Node
        - isInSubgraph() bool
        - appendSubgraphNode(n graph.Node) 

    }
    class line << (S,Aquamarine) >> {
        - inGraph string
        - from int64
        - to int64
        - id int64

    }
    class multiGraph << (S,Aquamarine) >> {
        - addStmt(dst encoding.MultiBuilder, stmt ast.Stmt) 
        - addEdgeStmt(dst encoding.MultiBuilder, stmt *ast.EdgeStmt) 
        - addVertex(dst encoding.MultiBuilder, v ast.Vertex) []graph.Node
        - addLine(dst encoding.MultiBuilder, to *ast.Edge, attrs []*ast.Attr) []graph.Node

    }
    class multiGraphPrinter << (S,Aquamarine) >> {
        - visited <font color=blue>map</font>[line]bool

        - print(g graph.Multigraph, name string, needsIndent bool, isSubgraph bool) error

    }
    class printer << (S,Aquamarine) >> {
        - buf bytes.Buffer
        - prefix string
        - indent string
        - depth int

        - printFrontMatter(name string, needsIndent bool, isSubgraph bool, isDirected bool, isStrict bool) 
        - writeNode(n graph.Node) 
        - writePorts(port string, cp string) 
        - writeAttributeList(a encoding.Attributer) 
        - writeAttributeComplex(ca Attributers) 
        - newline() 
        - openBlock(b string) 
        - closeBlock(b string) 

    }
    class simpleGraph << (S,Aquamarine) >> {
        - addStmt(dst encoding.Builder, stmt ast.Stmt) 
        - addEdgeStmt(dst encoding.Builder, stmt *ast.EdgeStmt) 
        - addVertex(dst encoding.Builder, v ast.Vertex) []graph.Node
        - addEdge(dst encoding.Builder, to *ast.Edge, attrs []*ast.Attr) []graph.Node

    }
    class simpleGraphPrinter << (S,Aquamarine) >> {
        - visited <font color=blue>map</font>[edge]bool

        - print(g graph.Graph, name string, needsIndent bool, isSubgraph bool) error

    }
}
"dot.generator" *-- "dot.multiGraph"
"dot.printer" *-- "dot.multiGraphPrinter"
"dot.generator" *-- "dot.simpleGraph"
"dot.printer" *-- "dot.simpleGraphPrinter"


namespace dual {
    class Number << (S,Aquamarine) >> {
        + Real float64

        + Format(fs fmt.State, c rune) 

    }
}


namespace dualcmplx {
    class Number << (S,Aquamarine) >> {
        + Real complex128

        + Format(fs fmt.State, c rune) 

    }
}


namespace dualquat {
    class Number << (S,Aquamarine) >> {
        + Real quat.Number

        + Format(fs fmt.State, c rune) 

    }
}


namespace dynamic {
    class DStarLite << (S,Aquamarine) >> {
        - s *dStarLiteNode
        - last *dStarLiteNode
        - model WorldModel
        - queue dStarLiteQueue
        - keyModifier float64
        - weight path.Weighting
        - heuristic path.Heuristic

        - keyFor(s *dStarLiteNode) key
        - update(u *dStarLiteNode) 
        - findShortestPath() 
        - worldNodeFor(n graph.Node) *dStarLiteNode

        + Step() bool
        + MoveTo(n graph.Node) 
        + UpdateWorld(changes []graph.Edge) 
        + Here() graph.Node
        + Path() ([]graph.Node, float64)

    }
    interface WorldModel  {
    }
    class dStarLiteNode << (S,Aquamarine) >> {
        - key key
        - idx int
        - rhs float64
        - g float64

        - inQueue() bool

    }
    class dStarLiteQueue << (S,Aquamarine) >> {
        - top() *dStarLiteNode
        - insert(u *dStarLiteNode, k key) 
        - update(n *dStarLiteNode, k key) 
        - remove(n *dStarLiteNode) 

        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Len() int
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class dynamic.dStarLiteQueue << (T, #FF7700) >>  {
    }
    class dynamic.key << (T, #FF7700) >>  {
    }
    class key << (S,Aquamarine) >> {
        - isBadKey() bool
        - less(other key) bool

    }
}
"graph.Node" *-- "dynamic.dStarLiteNode"


namespace encoding {
    class Attribute << (S,Aquamarine) >> {
        + Key string

    }
    interface AttributeSetter  {
        + SetAttribute( Attribute) error

    }
    interface Attributer  {
        + Attributes() []Attribute

    }
    class Attributes << (S,Aquamarine) >> {
        + Attributes() []Attribute
        + SetAttribute(attr Attribute) error

    }
    interface Builder  {
    }
    interface MultiBuilder  {
    }
    class encoding.Attributes << (T, #FF7700) >>  {
    }
}

"encoding.AttributeSetter" <|-- "encoding.Attributes"
"encoding.Attributer" <|-- "encoding.Attributes"

namespace errors {
    class Error << (S,Aquamarine) >> {
        + Err error
        + ErrorToken *token.Token
        + ErrorSymbols []ErrorSymbol
        + ExpectedTokens []string
        + StackTop int

        + String() string
        + Error() string

    }
    interface ErrorSymbol  {
    }
}


namespace fd {
    class Formula << (S,Aquamarine) >> {
        + Stencil []Point
        + Derivative int
        + Step float64

        - isZero() bool

    }
    class JacobianSettings << (S,Aquamarine) >> {
        + Formula Formula
        + OriginValue []float64
        + Step float64
        + Concurrent bool

    }
    class Point << (S,Aquamarine) >> {
        + Loc float64
        + Coeff float64

    }
    class Settings << (S,Aquamarine) >> {
        + Formula Formula
        + Step float64
        + OriginKnown bool
        + OriginValue float64
        + Concurrent bool

    }
    class fdrun << (S,Aquamarine) >> {
        - idx int
        - pt Point
        - result float64

    }
    class jacJob << (S,Aquamarine) >> {
        - j int
        - pt Point

    }
}


namespace fftpack {
    class threeArray << (S,Aquamarine) >> {
        - i int
        - jStride int
        - data []float64
        - jStride int
        - data []float64

        - at(i int, j int, k int) float64
        - atCmplx(i int, j int, k int) complex128
        - set(i int, j int, k int, v float64) 
        - setCmplx(i int, j int, k int, v complex128) 
        - at(i int, j int, k int) float64
        - atCmplx(i int, j int, k int) complex128
        - set(i int, j int, k int, v float64) 
        - setCmplx(i int, j int, k int, v complex128) 

    }
    class twoArray << (S,Aquamarine) >> {
        - i int
        - jStride int
        - data []float64
        - jStride int
        - data []float64

        - at(i int, j int) float64
        - atCmplx(i int, j int) complex128
        - set(i int, j int, v float64) 
        - setCmplx(i int, j int, v complex128) 
        - add(i int, j int, v float64) 
        - at(i int, j int) float64
        - atCmplx(i int, j int) complex128
        - set(i int, j int, v float64) 
        - setCmplx(i int, j int, v complex128) 
        - add(i int, j int, v float64) 

    }
}


namespace floats {
    class argsort << (S,Aquamarine) >> {
        - s []float64
        - inds []int

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
}


namespace flow {
    class DominatorTree << (S,Aquamarine) >> {
        - root graph.Node
        - dominatorOf <font color=blue>map</font>[int64]graph.Node
        - dominatedBy <font color=blue>map</font>[int64][]graph.Node

        + Root() graph.Node
        + DominatorOf(id int64) graph.Node
        + DominatedBy(id int64) []graph.Node

    }
    class lengauerTarjan << (S,Aquamarine) >> {
        - nodes []*ltNode
        - indexOf <font color=blue>map</font>[int64]int

        - dfs(g graph.Directed, v graph.Node) 
        - compress(v *ltNode) 
        - eval(v *ltNode) *ltNode
        - link(v *ltNode, w *ltNode) 

    }
    class ltNode << (S,Aquamarine) >> {
        - node graph.Node
        - parent *ltNode
        - pred []*ltNode
        - semi int
        - bucket <font color=blue>map</font>[*ltNode]<font color=blue>struct</font>{}
        - dom *ltNode
        - ancestor *ltNode
        - label *ltNode

    }
    class sLengauerTarjan << (S,Aquamarine) >> {
        - nodes []*sltNode
        - indexOf <font color=blue>map</font>[int64]int
        - base sltNode

        - dfs(g graph.Directed, v graph.Node) 
        - compress(v *sltNode) 
        - eval(v *sltNode) *sltNode
        - link(v *sltNode, w *sltNode) 

    }
    class sltNode << (S,Aquamarine) >> {
        - node graph.Node
        - parent *sltNode
        - pred []*sltNode
        - semi int
        - size int
        - child *sltNode
        - bucket <font color=blue>map</font>[*sltNode]<font color=blue>struct</font>{}
        - dom *sltNode
        - ancestor *sltNode
        - label *sltNode

    }
}


namespace fourier {
    class CmplxFFT << (S,Aquamarine) >> {
        - work []float64
        - ifac []int
        - real []float64

        + Len() int
        + Reset(n int) 
        + Coefficients(dst []complex128, seq []complex128) []complex128
        + Sequence(dst []complex128, coeff []complex128) []complex128
        + Freq(i int) float64
        + ShiftIdx(i int) int
        + UnshiftIdx(i int) int

    }
    class DCT << (S,Aquamarine) >> {
        - work []float64
        - ifac []int

        + Len() int
        + Reset(n int) 
        + Transform(dst []float64, src []float64) []float64

    }
    class DST << (S,Aquamarine) >> {
        - work []float64
        - ifac []int

        + Len() int
        + Reset(n int) 
        + Transform(dst []float64, src []float64) []float64

    }
    class FFT << (S,Aquamarine) >> {
        - work []float64
        - ifac []int
        - real []float64

        + Len() int
        + Reset(n int) 
        + Coefficients(dst []complex128, seq []float64) []complex128
        + Sequence(dst []float64, coeff []complex128) []float64
        + Freq(i int) float64

    }
    class QuarterWaveFFT << (S,Aquamarine) >> {
        - work []float64
        - ifac []int

        + Len() int
        + Reset(n int) 
        + CosCoefficients(dst []float64, seq []float64) []float64
        + CosSequence(dst []float64, coeff []float64) []float64
        + SinCoefficients(dst []float64, seq []float64) []float64
        + SinSequence(dst []float64, coeff []float64) []float64

    }
}


namespace functions {
    class Ackley << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Beale << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Hess(dst *mat.SymDense, x []float64) 
        + Minima() []Minimum

    }
    class BiggsEXP2 << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class BiggsEXP3 << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class BiggsEXP4 << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class BiggsEXP5 << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class BiggsEXP6 << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class Box3D << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class BraninHoo << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Minima() []Minimum

    }
    class BrownAndDennis << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Hess(dst *mat.SymDense, x []float64) 
        + Minima() []Minimum

    }
    class BrownBadlyScaled << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Hess(dst *mat.SymDense, x []float64) 
        + Minima() []Minimum

    }
    class Bukin6 << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class CamelSix << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class CamelThree << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class ConcaveLeft << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 

    }
    class ConcaveRight << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 

    }
    class CrossInTray << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class DixonPrice << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class DropWave << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Eggholder << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class ExtendedPowellSingular << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class ExtendedRosenbrock << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class Gaussian << (S,Aquamarine) >> {
        - y(i int) float64

        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class GramacyLee << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Griewank << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class GulfResearchAndDevelopment << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class HelicalValley << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class HolderTable << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Langermann2 << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Levy << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Levy13 << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Linear << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) []float64

    }
    class MinimalSurface << (S,Aquamarine) >> {
        - bottom []float64
        - left []float64
        - origin []float64

        - x(i int) float64
        - y(j int) float64
        - at(i int, j int, x []float64) float64
        - index(i int, j int) int
        - initBoundary(b []float64, startX float64, startY float64, hx float64, hy float64) 

        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) []float64
        + InitX() []float64
        + ExactX() []float64
        + ExactSolution(x float64, y float64) float64
        + Dims() (int, int)
        + Steps() (float64, float64)

    }
    class Minimum << (S,Aquamarine) >> {
        + X []float64
        + F float64
        + Global bool

    }
    class PenaltyI << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class PenaltyII << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class Plassmann << (S,Aquamarine) >> {
        + L float64
        + Beta float64

        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 

    }
    class PowellBadlyScaled << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Hess(dst *mat.SymDense, x []float64) 
        + Minima() []Minimum

    }
    class Rastrigin << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Schaffer2 << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Schaffer4 << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Schwefel << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Shubert << (S,Aquamarine) >> {
        + Func(x []float64) float64

    }
    class Trigonometric << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class VariablyDimensioned << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Minima() []Minimum

    }
    class Watson << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Hess(dst *mat.SymDense, x []float64) 
        + Minima() []Minimum

    }
    class Wood << (S,Aquamarine) >> {
        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 
        + Hess(dst *mat.SymDense, x []float64) 
        + Minima() []Minimum

    }
    class YanaiOzawaKaneko << (S,Aquamarine) >> {
        + Beta1 float64
        + Beta2 float64

        + Func(x []float64) float64
        + Grad(grad []float64, x []float64) 

    }
    class funcTest << (S,Aquamarine) >> {
        + X []float64
        + F float64
        + Gradient []float64

    }
    interface function  {
        + Func(x []float64) float64

    }
    interface gradient  {
        + Grad(grad []float64, x []float64) []float64

    }
    interface minimumer  {
        + Minima() []Minimum

    }
}
"functions.function" *-- "functions.minimumer"

"functions.function" <|-- "functions.Ackley"
"functions.function" <|-- "functions.Beale"
"functions.minimumer" <|-- "functions.Beale"
"functions.function" <|-- "functions.BiggsEXP2"
"functions.minimumer" <|-- "functions.BiggsEXP2"
"functions.function" <|-- "functions.BiggsEXP3"
"functions.minimumer" <|-- "functions.BiggsEXP3"
"functions.function" <|-- "functions.BiggsEXP4"
"functions.minimumer" <|-- "functions.BiggsEXP4"
"functions.function" <|-- "functions.BiggsEXP5"
"functions.minimumer" <|-- "functions.BiggsEXP5"
"functions.function" <|-- "functions.BiggsEXP6"
"functions.minimumer" <|-- "functions.BiggsEXP6"
"functions.function" <|-- "functions.Box3D"
"functions.minimumer" <|-- "functions.Box3D"
"functions.function" <|-- "functions.BraninHoo"
"functions.minimumer" <|-- "functions.BraninHoo"
"functions.function" <|-- "functions.BrownAndDennis"
"functions.minimumer" <|-- "functions.BrownAndDennis"
"functions.function" <|-- "functions.BrownBadlyScaled"
"functions.minimumer" <|-- "functions.BrownBadlyScaled"
"functions.function" <|-- "functions.Bukin6"
"functions.function" <|-- "functions.CamelSix"
"functions.function" <|-- "functions.CamelThree"
"functions.function" <|-- "functions.ConcaveLeft"
"functions.function" <|-- "functions.ConcaveRight"
"functions.function" <|-- "functions.CrossInTray"
"functions.function" <|-- "functions.DixonPrice"
"functions.function" <|-- "functions.DropWave"
"functions.function" <|-- "functions.Eggholder"
"functions.function" <|-- "functions.ExtendedPowellSingular"
"functions.minimumer" <|-- "functions.ExtendedPowellSingular"
"functions.function" <|-- "functions.ExtendedRosenbrock"
"functions.minimumer" <|-- "functions.ExtendedRosenbrock"
"functions.function" <|-- "functions.Gaussian"
"functions.minimumer" <|-- "functions.Gaussian"
"functions.function" <|-- "functions.GramacyLee"
"functions.function" <|-- "functions.Griewank"
"functions.function" <|-- "functions.GulfResearchAndDevelopment"
"functions.minimumer" <|-- "functions.GulfResearchAndDevelopment"
"functions.function" <|-- "functions.HelicalValley"
"functions.minimumer" <|-- "functions.HelicalValley"
"functions.function" <|-- "functions.HolderTable"
"functions.function" <|-- "functions.Langermann2"
"functions.function" <|-- "functions.Levy"
"functions.function" <|-- "functions.Levy13"
"functions.function" <|-- "functions.Linear"
"functions.gradient" <|-- "functions.Linear"
"functions.function" <|-- "functions.MinimalSurface"
"functions.gradient" <|-- "functions.MinimalSurface"
"functions.function" <|-- "functions.PenaltyI"
"functions.minimumer" <|-- "functions.PenaltyI"
"functions.function" <|-- "functions.PenaltyII"
"functions.minimumer" <|-- "functions.PenaltyII"
"functions.function" <|-- "functions.Plassmann"
"functions.function" <|-- "functions.PowellBadlyScaled"
"functions.minimumer" <|-- "functions.PowellBadlyScaled"
"functions.function" <|-- "functions.Rastrigin"
"functions.function" <|-- "functions.Schaffer2"
"functions.function" <|-- "functions.Schaffer4"
"functions.function" <|-- "functions.Schwefel"
"functions.function" <|-- "functions.Shubert"
"functions.function" <|-- "functions.Trigonometric"
"functions.minimumer" <|-- "functions.Trigonometric"
"functions.function" <|-- "functions.VariablyDimensioned"
"functions.minimumer" <|-- "functions.VariablyDimensioned"
"functions.function" <|-- "functions.Watson"
"functions.minimumer" <|-- "functions.Watson"
"functions.function" <|-- "functions.Wood"
"functions.minimumer" <|-- "functions.Wood"
"functions.function" <|-- "functions.YanaiOzawaKaneko"

namespace gen {
    interface GraphBuilder  {
        + HasEdgeBetween(xid int64, yid int64) bool

    }
    class IDRange << (S,Aquamarine) >> {
        + First int64

        + Len() int
        + ID(i int) int64

    }
    class IDSet << (S,Aquamarine) >> {
        + Len() int
        + ID(i int) int64

    }
    interface IDer  {
        + Len() int
        + ID( int) int64

    }
    interface NodeIDGraphBuilder  {
    }
    interface UndirectedMutator  {
    }
    class gen.IDSet << (T, #FF7700) >>  {
    }
}

"gen.IDer" <|-- "gen.IDRange"
"gen.IDer" <|-- "gen.IDSet"

namespace gexf12 {
    class AttValue << (S,Aquamarine) >> {
        + For string
        + Value string
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class AttValues << (S,Aquamarine) >> {
        + AttValues []AttValue

    }
    class Attribute << (S,Aquamarine) >> {
        + ID string
        + Title string
        + Type string
        + Default string
        + Options string

    }
    class Attributes << (S,Aquamarine) >> {
        + Attributes []Attribute
        + Class string
        + Mode string
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class Color << (S,Aquamarine) >> {
        + Spells *Spells
        + R byte
        + G byte
        + B byte
        + A float64
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class Content << (S,Aquamarine) >> {
        + XMLName xml.Name
        + Meta *Meta
        + Graph Graph
        + Version string
        + Variant string

    }
    class Edge << (S,Aquamarine) >> {
        + ID string
        + AttValues *AttValues
        + Spells *Spells
        + Color *Color
        + Thickness *Thickness
        + Shape *Edgeshape
        + Start string
        + StartOpen string
        + End string
        + EndOpen string
        + Type string
        + Label string
        + Source string
        + Target string
        + Weight float64

    }
    class Edges << (S,Aquamarine) >> {
        + Count int
        + Edges []Edge

    }
    class Edgeshape << (S,Aquamarine) >> {
        + Shape string
        + Spells *Spells
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class Graph << (S,Aquamarine) >> {
        + Attributes []Attributes
        + Nodes Nodes
        + Edges Edges
        + TimeFormat string
        + Start string
        + StartOpen string
        + End string
        + EndOpen string
        + DefaultEdgeType string
        + IDType string
        + Mode string

    }
    class Meta << (S,Aquamarine) >> {
        + Creator string
        + Keywords string
        + Description string
        + LastModified time.Time

        + MarshalXML(e *xml.Encoder, start xml.StartElement) error
        + UnmarshalXML(d *xml.Decoder, start xml.StartElement) error

    }
    class Node << (S,Aquamarine) >> {
        + ID string
        + Label string
        + AttValues *AttValues
        + Spells *Spells
        + Nodes *Nodes
        + Edges *Edges
        + ParentID string
        + Parents *Parents
        + Color *Color
        + Position *Position
        + Size *Size
        + Shape *NodeShape
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class NodeShape << (S,Aquamarine) >> {
        + Spells *Spells
        + Shape string
        + URI string
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class Nodes << (S,Aquamarine) >> {
        + Count int
        + Nodes []Node

    }
    class Parent << (S,Aquamarine) >> {
        + For string

    }
    class Parents << (S,Aquamarine) >> {
        + Parents []Parent

    }
    class Position << (S,Aquamarine) >> {
        + X float64
        + Y float64
        + Z float64
        + Spells *Spells
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class Size << (S,Aquamarine) >> {
        + Value float64
        + Spells *Spells
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class Spell << (S,Aquamarine) >> {
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class Spells << (S,Aquamarine) >> {
        + Spells []Spell

    }
    class Thickness << (S,Aquamarine) >> {
        + Value float64
        + Spells *Spells
        + Start string
        + StartOpen string
        + End string
        + EndOpen string

    }
    class gexf12.xsdDate << (T, #FF7700) >>  {
    }
    class xsdDate << (S,Aquamarine) >> {
        + UnmarshalText(text []byte) error
        + MarshalText() ([]byte, error)
        + MarshalXML(e *xml.Encoder, start xml.StartElement) error
        + MarshalXMLAttr(name xml.Name) (xml.Attr, error)

    }
    class "time.Time" as timeTime {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace gonum {
    class Implementation << (S,Aquamarine) >> {
        + Dgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 
        + Dzasum(n int, x []complex128, incX int) float64
        + Dznrm2(n int, x []complex128, incX int) float64
        + Izamax(n int, x []complex128, incX int) int
        + Zaxpy(n int, alpha complex128, x []complex128, incX int, y []complex128, incY int) 
        + Zcopy(n int, x []complex128, incX int, y []complex128, incY int) 
        + Zdotc(n int, x []complex128, incX int, y []complex128, incY int) complex128
        + Zdotu(n int, x []complex128, incX int, y []complex128, incY int) complex128
        + Zdscal(n int, alpha float64, x []complex128, incX int) 
        + Zscal(n int, alpha complex128, x []complex128, incX int) 
        + Zswap(n int, x []complex128, incX int, y []complex128, incY int) 
        + Scasum(n int, x []complex64, incX int) float32
        + Scnrm2(n int, x []complex64, incX int) float32
        + Icamax(n int, x []complex64, incX int) int
        + Caxpy(n int, alpha complex64, x []complex64, incX int, y []complex64, incY int) 
        + Ccopy(n int, x []complex64, incX int, y []complex64, incY int) 
        + Cdotc(n int, x []complex64, incX int, y []complex64, incY int) complex64
        + Cdotu(n int, x []complex64, incX int, y []complex64, incY int) complex64
        + Csscal(n int, alpha float32, x []complex64, incX int) 
        + Cscal(n int, alpha complex64, x []complex64, incX int) 
        + Cswap(n int, x []complex64, incX int, y []complex64, incY int) 
        + Snrm2(n int, x []float32, incX int) float32
        + Sasum(n int, x []float32, incX int) float32
        + Isamax(n int, x []float32, incX int) int
        + Sswap(n int, x []float32, incX int, y []float32, incY int) 
        + Scopy(n int, x []float32, incX int, y []float32, incY int) 
        + Saxpy(n int, alpha float32, x []float32, incX int, y []float32, incY int) 
        + Srotg(a float32, b float32) (float32, float32, float32, float32)
        + Srotmg(d1 float32, d2 float32, x1 float32, y1 float32) (blas.SrotmParams, float32, float32, float32)
        + Srot(n int, x []float32, incX int, y []float32, incY int, c float32, s float32) 
        + Srotm(n int, x []float32, incX int, y []float32, incY int, p blas.SrotmParams) 
        + Sscal(n int, alpha float32, x []float32, incX int) 
        + Dsdot(n int, x []float32, incX int, y []float32, incY int) float64
        + Sdot(n int, x []float32, incX int, y []float32, incY int) float32
        + Sdsdot(n int, alpha float32, x []float32, incX int, y []float32, incY int) float32
        + Dnrm2(n int, x []float64, incX int) float64
        + Dasum(n int, x []float64, incX int) float64
        + Idamax(n int, x []float64, incX int) int
        + Dswap(n int, x []float64, incX int, y []float64, incY int) 
        + Dcopy(n int, x []float64, incX int, y []float64, incY int) 
        + Daxpy(n int, alpha float64, x []float64, incX int, y []float64, incY int) 
        + Drotg(a float64, b float64) (float64, float64, float64, float64)
        + Drotmg(d1 float64, d2 float64, x1 float64, y1 float64) (blas.DrotmParams, float64, float64, float64)
        + Drot(n int, x []float64, incX int, y []float64, incY int, c float64, s float64) 
        + Drotm(n int, x []float64, incX int, y []float64, incY int, p blas.DrotmParams) 
        + Dscal(n int, alpha float64, x []float64, incX int) 
        + Ddot(n int, x []float64, incX int, y []float64, incY int) float64
        + Zgbmv(trans blas.Transpose, m int, n int, kL int, kU int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zgemv(trans blas.Transpose, m int, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zgerc(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 
        + Zgeru(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 
        + Zhbmv(uplo blas.Uplo, n int, k int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zhemv(uplo blas.Uplo, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zher(uplo blas.Uplo, n int, alpha float64, x []complex128, incX int, a []complex128, lda int) 
        + Zher2(uplo blas.Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 
        + Zhpmv(uplo blas.Uplo, n int, alpha complex128, ap []complex128, x []complex128, incX int, beta complex128, y []complex128, incY int) 
        + Zhpr(uplo blas.Uplo, n int, alpha float64, x []complex128, incX int, ap []complex128) 
        + Zhpr2(uplo blas.Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, ap []complex128) 
        + Ztbmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, k int, a []complex128, lda int, x []complex128, incX int) 
        + Ztbsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, k int, a []complex128, lda int, x []complex128, incX int) 
        + Ztpmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, ap []complex128, x []complex128, incX int) 
        + Ztpsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, ap []complex128, x []complex128, incX int) 
        + Ztrmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, a []complex128, lda int, x []complex128, incX int) 
        + Ztrsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, a []complex128, lda int, x []complex128, incX int) 
        + Cgbmv(trans blas.Transpose, m int, n int, kL int, kU int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Cgemv(trans blas.Transpose, m int, n int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Cgerc(m int, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) 
        + Cgeru(m int, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) 
        + Chbmv(uplo blas.Uplo, n int, k int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Chemv(uplo blas.Uplo, n int, alpha complex64, a []complex64, lda int, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Cher(uplo blas.Uplo, n int, alpha float32, x []complex64, incX int, a []complex64, lda int) 
        + Cher2(uplo blas.Uplo, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, a []complex64, lda int) 
        + Chpmv(uplo blas.Uplo, n int, alpha complex64, ap []complex64, x []complex64, incX int, beta complex64, y []complex64, incY int) 
        + Chpr(uplo blas.Uplo, n int, alpha float32, x []complex64, incX int, ap []complex64) 
        + Chpr2(uplo blas.Uplo, n int, alpha complex64, x []complex64, incX int, y []complex64, incY int, ap []complex64) 
        + Ctbmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, k int, a []complex64, lda int, x []complex64, incX int) 
        + Ctbsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, k int, a []complex64, lda int, x []complex64, incX int) 
        + Ctpmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, ap []complex64, x []complex64, incX int) 
        + Ctpsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, ap []complex64, x []complex64, incX int) 
        + Ctrmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, a []complex64, lda int, x []complex64, incX int) 
        + Ctrsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, a []complex64, lda int, x []complex64, incX int) 
        + Sger(m int, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) 
        + Sgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Sgemv(tA blas.Transpose, m int, n int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Strmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float32, lda int, x []float32, incX int) 
        + Strsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float32, lda int, x []float32, incX int) 
        + Ssymv(ul blas.Uplo, n int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Stbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float32, lda int, x []float32, incX int) 
        + Stpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float32, x []float32, incX int) 
        + Stbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float32, lda int, x []float32, incX int) 
        + Ssbmv(ul blas.Uplo, n int, k int, alpha float32, a []float32, lda int, x []float32, incX int, beta float32, y []float32, incY int) 
        + Ssyr(ul blas.Uplo, n int, alpha float32, x []float32, incX int, a []float32, lda int) 
        + Ssyr2(ul blas.Uplo, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) 
        + Stpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float32, x []float32, incX int) 
        + Sspmv(ul blas.Uplo, n int, alpha float32, ap []float32, x []float32, incX int, beta float32, y []float32, incY int) 
        + Sspr(ul blas.Uplo, n int, alpha float32, x []float32, incX int, ap []float32) 
        + Sspr2(ul blas.Uplo, n int, alpha float32, x []float32, incX int, y []float32, incY int, ap []float32) 
        + Dger(m int, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) 
        + Dgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dgemv(tA blas.Transpose, m int, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dtrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) 
        + Dtrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) 
        + Dsymv(ul blas.Uplo, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dtbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float64, lda int, x []float64, incX int) 
        + Dtpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float64, x []float64, incX int) 
        + Dtbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float64, lda int, x []float64, incX int) 
        + Dsbmv(ul blas.Uplo, n int, k int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dsyr(ul blas.Uplo, n int, alpha float64, x []float64, incX int, a []float64, lda int) 
        + Dsyr2(ul blas.Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) 
        + Dtpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float64, x []float64, incX int) 
        + Dspmv(ul blas.Uplo, n int, alpha float64, ap []float64, x []float64, incX int, beta float64, y []float64, incY int) 
        + Dspr(ul blas.Uplo, n int, alpha float64, x []float64, incX int, ap []float64) 
        + Dspr2(ul blas.Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, ap []float64) 
        + Zgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Zhemm(side blas.Side, uplo blas.Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Zherk(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha float64, a []complex128, lda int, beta float64, c []complex128, ldc int) 
        + Zher2k(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta float64, c []complex128, ldc int) 
        + Zsymm(side blas.Side, uplo blas.Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Zsyrk(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, beta complex128, c []complex128, ldc int) 
        + Zsyr2k(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 
        + Ztrmm(side blas.Side, uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) 
        + Ztrsm(side blas.Side, uplo blas.Uplo, transA blas.Transpose, diag blas.Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) 
        + Cgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Chemm(side blas.Side, uplo blas.Uplo, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Cherk(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha float32, a []complex64, lda int, beta float32, c []complex64, ldc int) 
        + Cher2k(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta float32, c []complex64, ldc int) 
        + Csymm(side blas.Side, uplo blas.Uplo, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Csyrk(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex64, a []complex64, lda int, beta complex64, c []complex64, ldc int) 
        + Csyr2k(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex64, a []complex64, lda int, b []complex64, ldb int, beta complex64, c []complex64, ldc int) 
        + Ctrmm(side blas.Side, uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int) 
        + Ctrsm(side blas.Side, uplo blas.Uplo, transA blas.Transpose, diag blas.Diag, m int, n int, alpha complex64, a []complex64, lda int, b []complex64, ldb int) 
        + Strsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int) 
        + Ssymm(s blas.Side, ul blas.Uplo, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) 
        + Ssyrk(ul blas.Uplo, tA blas.Transpose, n int, k int, alpha float32, a []float32, lda int, beta float32, c []float32, ldc int) 
        + Ssyr2k(ul blas.Uplo, tA blas.Transpose, n int, k int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) 
        + Strmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float32, a []float32, lda int, b []float32, ldb int) 
        + Dtrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) 
        + Dsymm(s blas.Side, ul blas.Uplo, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 
        + Dsyrk(ul blas.Uplo, tA blas.Transpose, n int, k int, alpha float64, a []float64, lda int, beta float64, c []float64, ldc int) 
        + Dsyr2k(ul blas.Uplo, tA blas.Transpose, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 
        + Dtrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) 
        + Sgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha float32, a []float32, lda int, b []float32, ldb int, beta float32, c []float32, ldc int) 
        + Dbdsqr(uplo blas.Uplo, n int, ncvt int, nru int, ncc int, d []float64, e []float64, vt []float64, ldvt int, u []float64, ldu int, c []float64, ldc int, work []float64) bool
        + Dgebak(job lapack.BalanceJob, side lapack.EVSide, n int, ilo int, ihi int, scale []float64, m int, v []float64, ldv int) 
        + Dgebal(job lapack.BalanceJob, n int, a []float64, lda int, scale []float64) (int, int)
        + Dgebd2(m int, n int, a []float64, lda int, d []float64, e []float64, tauQ []float64, tauP []float64, work []float64) 
        + Dgebrd(m int, n int, a []float64, lda int, d []float64, e []float64, tauQ []float64, tauP []float64, work []float64, lwork int) 
        + Dgecon(norm lapack.MatrixNorm, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64
        + Dgeev(jobvl lapack.LeftEVJob, jobvr lapack.RightEVJob, n int, a []float64, lda int, wr []float64, wi []float64, vl []float64, ldvl int, vr []float64, ldvr int, work []float64, lwork int) int
        + Dgehd2(n int, ilo int, ihi int, a []float64, lda int, tau []float64, work []float64) 
        + Dgehrd(n int, ilo int, ihi int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dgelq2(m int, n int, a []float64, lda int, tau []float64, work []float64) 
        + Dgelqf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dgels(trans blas.Transpose, m int, n int, nrhs int, a []float64, lda int, b []float64, ldb int, work []float64, lwork int) bool
        + Dgeql2(m int, n int, a []float64, lda int, tau []float64, work []float64) 
        + Dgeqp3(m int, n int, a []float64, lda int, jpvt []int, tau []float64, work []float64, lwork int) 
        + Dgeqr2(m int, n int, a []float64, lda int, tau []float64, work []float64) 
        + Dgeqrf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dgerq2(m int, n int, a []float64, lda int, tau []float64, work []float64) 
        + Dgerqf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dgesc2(n int, a []float64, lda int, rhs []float64, ipiv []int, jpiv []int) float64
        + Dgesv(n int, nrhs int, a []float64, lda int, ipiv []int, b []float64, ldb int) bool
        + Dgesvd(jobU lapack.SVDJob, jobVT lapack.SVDJob, m int, n int, a []float64, lda int, s []float64, u []float64, ldu int, vt []float64, ldvt int, work []float64, lwork int) bool
        + Dgetc2(n int, a []float64, lda int, ipiv []int, jpiv []int) int
        + Dgetf2(m int, n int, a []float64, lda int, ipiv []int) bool
        + Dgetrf(m int, n int, a []float64, lda int, ipiv []int) bool
        + Dgetri(n int, a []float64, lda int, ipiv []int, work []float64, lwork int) bool
        + Dgetrs(trans blas.Transpose, n int, nrhs int, a []float64, lda int, ipiv []int, b []float64, ldb int) 
        + Dggsvd3(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, n int, p int, a []float64, lda int, b []float64, ldb int, alpha []float64, beta []float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, work []float64, lwork int, iwork []int) (int, int, bool)
        + Dggsvp3(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, p int, n int, a []float64, lda int, b []float64, ldb int, tola float64, tolb float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, iwork []int, tau []float64, work []float64, lwork int) (int, int)
        + Dgtsv(n int, nrhs int, dl []float64, d []float64, du []float64, b []float64, ldb int) bool
        + Dhseqr(job lapack.SchurJob, compz lapack.SchurComp, n int, ilo int, ihi int, h []float64, ldh int, wr []float64, wi []float64, z []float64, ldz int, work []float64, lwork int) int
        + Dlabrd(m int, n int, nb int, a []float64, lda int, d []float64, e []float64, tauQ []float64, tauP []float64, x []float64, ldx int, y []float64, ldy int) 
        + Dlacn2(n int, v []float64, x []float64, isgn []int, est float64, kase int, isave *[]int) (float64, int)
        + Dlacpy(uplo blas.Uplo, m int, n int, a []float64, lda int, b []float64, ldb int) 
        + Dlae2(a float64, b float64, c float64) (float64, float64)
        + Dlaev2(a float64, b float64, c float64) (float64, float64, float64, float64)
        + Dlaexc(wantq bool, n int, t []float64, ldt int, q []float64, ldq int, j1 int, n1 int, n2 int, work []float64) bool
        + Dlag2(a []float64, lda int, b []float64, ldb int) (float64, float64, float64, float64, float64)
        + Dlags2(upper bool, a1 float64, a2 float64, a3 float64, b1 float64, b2 float64, b3 float64) (float64, float64, float64, float64, float64, float64)
        + Dlagtm(trans blas.Transpose, m int, n int, alpha float64, dl []float64, d []float64, du []float64, b []float64, ldb int, beta float64, c []float64, ldc int) 
        + Dlahqr(wantt bool, wantz bool, n int, ilo int, ihi int, h []float64, ldh int, wr []float64, wi []float64, iloz int, ihiz int, z []float64, ldz int) int
        + Dlahr2(n int, k int, nb int, a []float64, lda int, tau []float64, t []float64, ldt int, y []float64, ldy int) 
        + Dlaln2(trans bool, na int, nw int, smin float64, ca float64, a []float64, lda int, d1 float64, d2 float64, b []float64, ldb int, wr float64, wi float64, x []float64, ldx int) (float64, float64, bool)
        + Dlangb(norm lapack.MatrixNorm, m int, n int, kl int, ku int, ab []float64, ldab int) float64
        + Dlange(norm lapack.MatrixNorm, m int, n int, a []float64, lda int, work []float64) float64
        + Dlangt(norm lapack.MatrixNorm, n int, dl []float64, d []float64, du []float64) float64
        + Dlansb(norm lapack.MatrixNorm, uplo blas.Uplo, n int, kd int, ab []float64, ldab int, work []float64) float64
        + Dlanst(norm lapack.MatrixNorm, n int, d []float64, e []float64) float64
        + Dlansy(norm lapack.MatrixNorm, uplo blas.Uplo, n int, a []float64, lda int, work []float64) float64
        + Dlantb(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, n int, k int, a []float64, lda int, work []float64) float64
        + Dlantr(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, m int, n int, a []float64, lda int, work []float64) float64
        + Dlanv2(a float64, b float64, c float64, d float64) (float64, float64, float64, float64, float64, float64, float64, float64, float64, float64)
        + Dlapll(n int, x []float64, incX int, y []float64, incY int) float64
        + Dlapmr(forward bool, m int, n int, x []float64, ldx int, k []int) 
        + Dlapmt(forward bool, m int, n int, x []float64, ldx int, k []int) 
        + Dlapy2(x float64, y float64) float64
        + Dlaqp2(m int, n int, offset int, a []float64, lda int, jpvt []int, tau []float64, vn1 []float64, vn2 []float64, work []float64) 
        + Dlaqps(m int, n int, offset int, nb int, a []float64, lda int, jpvt []int, tau []float64, vn1 []float64, vn2 []float64, auxv []float64, f []float64, ldf int) int
        + Dlaqr04(wantt bool, wantz bool, n int, ilo int, ihi int, h []float64, ldh int, wr []float64, wi []float64, iloz int, ihiz int, z []float64, ldz int, work []float64, lwork int, recur int) int
        + Dlaqr1(n int, h []float64, ldh int, sr1 float64, si1 float64, sr2 float64, si2 float64, v []float64) 
        + Dlaqr23(wantt bool, wantz bool, n int, ktop int, kbot int, nw int, h []float64, ldh int, iloz int, ihiz int, z []float64, ldz int, sr []float64, si []float64, v []float64, ldv int, nh int, t []float64, ldt int, nv int, wv []float64, ldwv int, work []float64, lwork int, recur int) (int, int)
        + Dlaqr5(wantt bool, wantz bool, kacc22 int, n int, ktop int, kbot int, nshfts int, sr []float64, si []float64, h []float64, ldh int, iloz int, ihiz int, z []float64, ldz int, v []float64, ldv int, u []float64, ldu int, nv int, wv []float64, ldwv int, nh int, wh []float64, ldwh int) 
        + Dlarf(side blas.Side, m int, n int, v []float64, incv int, tau float64, c []float64, ldc int, work []float64) 
        + Dlarfb(side blas.Side, trans blas.Transpose, direct lapack.Direct, store lapack.StoreV, m int, n int, k int, v []float64, ldv int, t []float64, ldt int, c []float64, ldc int, work []float64, ldwork int) 
        + Dlarfg(n int, alpha float64, x []float64, incX int) (float64, float64)
        + Dlarft(direct lapack.Direct, store lapack.StoreV, n int, k int, v []float64, ldv int, tau []float64, t []float64, ldt int) 
        + Dlarfx(side blas.Side, m int, n int, v []float64, tau float64, c []float64, ldc int, work []float64) 
        + Dlartg(f float64, g float64) (float64, float64, float64)
        + Dlas2(f float64, g float64, h float64) (float64, float64)
        + Dlascl(kind lapack.MatrixType, kl int, ku int, cfrom float64, cto float64, m int, n int, a []float64, lda int) 
        + Dlaset(uplo blas.Uplo, m int, n int, alpha float64, beta float64, a []float64, lda int) 
        + Dlasq1(n int, d []float64, e []float64, work []float64) int
        + Dlasq2(n int, z []float64) int
        + Dlasq3(i0 int, n0 int, z []float64, pp int, dmin float64, sigma float64, desig float64, qmax float64, nFail int, iter int, nDiv int, ttype int, dmin1 float64, dmin2 float64, dn float64, dn1 float64, dn2 float64, g float64, tau float64) (int, int, int, float64, float64, float64, float64, int, int, int, int, float64, float64, float64, float64, float64, float64, float64)
        + Dlasq4(i0 int, n0 int, z []float64, pp int, n0in int, dmin float64, dmin1 float64, dmin2 float64, dn float64, dn1 float64, dn2 float64, tau float64, ttype int, g float64) (float64, int, float64)
        + Dlasq5(i0 int, n0 int, z []float64, pp int, tau float64, sigma float64) (int, int, int, float64, float64, float64, float64, float64, float64, float64, float64)
        + Dlasq6(i0 int, n0 int, z []float64, pp int) (float64, float64, float64, float64, float64, float64)
        + Dlasr(side blas.Side, pivot lapack.Pivot, direct lapack.Direct, m int, n int, c []float64, s []float64, a []float64, lda int) 
        + Dlasrt(s lapack.Sort, n int, d []float64) 
        + Dlassq(n int, x []float64, incx int, scale float64, sumsq float64) (float64, float64)
        + Dlasv2(f float64, g float64, h float64) (float64, float64, float64, float64, float64, float64)
        + Dlaswp(n int, a []float64, lda int, k1 int, k2 int, ipiv []int, incX int) 
        + Dlasy2(tranl bool, tranr bool, isgn int, n1 int, n2 int, tl []float64, ldtl int, tr []float64, ldtr int, b []float64, ldb int, x []float64, ldx int) (float64, float64, bool)
        + Dlatbs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, normin bool, n int, kd int, ab []float64, ldab int, x []float64, cnorm []float64) float64
        + Dlatdf(job lapack.MaximizeNormXJob, n int, z []float64, ldz int, rhs []float64, rdsum float64, rdscal float64, ipiv []int, jpiv []int) (float64, float64)
        + Dlatrd(uplo blas.Uplo, n int, nb int, a []float64, lda int, e []float64, tau []float64, w []float64, ldw int) 
        + Dlatrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, normin bool, n int, a []float64, lda int, x []float64, cnorm []float64) float64
        + Dlauu2(uplo blas.Uplo, n int, a []float64, lda int) 
        + Dlauum(uplo blas.Uplo, n int, a []float64, lda int) 
        + Dorg2l(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 
        + Dorg2r(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 
        + Dorgbr(vect lapack.GenOrtho, m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorghr(n int, ilo int, ihi int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorgl2(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 
        + Dorglq(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorgql(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorgqr(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorgr2(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 
        + Dorgtr(uplo blas.Uplo, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorm2r(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64) 
        + Dormbr(vect lapack.ApplyOrtho, side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 
        + Dormhr(side blas.Side, trans blas.Transpose, m int, n int, ilo int, ihi int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 
        + Dorml2(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64) 
        + Dormlq(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 
        + Dormqr(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 
        + Dormr2(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64) 
        + Dpbcon(uplo blas.Uplo, n int, kd int, ab []float64, ldab int, anorm float64, work []float64, iwork []int) float64
        + Dpbtf2(uplo blas.Uplo, n int, kd int, ab []float64, ldab int) bool
        + Dpbtrf(uplo blas.Uplo, n int, kd int, ab []float64, ldab int) bool
        + Dpbtrs(uplo blas.Uplo, n int, kd int, nrhs int, ab []float64, ldab int, b []float64, ldb int) 
        + Dpocon(uplo blas.Uplo, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64
        + Dpotf2(ul blas.Uplo, n int, a []float64, lda int) bool
        + Dpotrf(ul blas.Uplo, n int, a []float64, lda int) bool
        + Dpotri(uplo blas.Uplo, n int, a []float64, lda int) bool
        + Dpotrs(uplo blas.Uplo, n int, nrhs int, a []float64, lda int, b []float64, ldb int) 
        + Dpstf2(uplo blas.Uplo, n int, a []float64, lda int, piv []int, tol float64, work []float64) (int, bool)
        + Dpstrf(uplo blas.Uplo, n int, a []float64, lda int, piv []int, tol float64, work []float64) (int, bool)
        + Drscl(n int, a float64, x []float64, incX int) 
        + Dsteqr(compz lapack.EVComp, n int, d []float64, e []float64, z []float64, ldz int, work []float64) bool
        + Dsterf(n int, d []float64, e []float64) bool
        + Dsyev(jobz lapack.EVJob, uplo blas.Uplo, n int, a []float64, lda int, w []float64, work []float64, lwork int) bool
        + Dsytd2(uplo blas.Uplo, n int, a []float64, lda int, d []float64, e []float64, tau []float64) 
        + Dsytrd(uplo blas.Uplo, n int, a []float64, lda int, d []float64, e []float64, tau []float64, work []float64, lwork int) 
        + Dtbtrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, kd int, nrhs int, a []float64, lda int, b []float64, ldb int) bool
        + Dtgsja(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, p int, n int, k int, l int, a []float64, lda int, b []float64, ldb int, tola float64, tolb float64, alpha []float64, beta []float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, work []float64) (int, bool)
        + Dtrcon(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int, work []float64, iwork []int) float64
        + Dtrevc3(side lapack.EVSide, howmny lapack.EVHowMany, selected []bool, n int, t []float64, ldt int, vl []float64, ldvl int, vr []float64, ldvr int, mm int, work []float64, lwork int) int
        + Dtrexc(compq lapack.UpdateSchurComp, n int, t []float64, ldt int, q []float64, ldq int, ifst int, ilst int, work []float64) (int, int, bool)
        + Dtrti2(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) 
        + Dtrtri(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) bool
        + Dtrtrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, nrhs int, a []float64, lda int, b []float64, ldb int) bool
        + Iladlc(m int, n int, a []float64, lda int) int
        + Iladlr(m int, n int, a []float64, lda int) int
        + Ilaenv(ispec int, name string, opts string, n1 int, n2 int, n3 int, n4 int) int
        + Iparmq(ispec int, name string, opts string, n int, ilo int, ihi int, lwork int) int

    }
}

"blas.Complex128Level1" <|-- "gonum.Implementation"
"blas.Complex128Level2" <|-- "gonum.Implementation"
"blas.Complex128Level3" <|-- "gonum.Implementation"
"blas.Complex64Level1" <|-- "gonum.Implementation"
"blas.Complex64Level2" <|-- "gonum.Implementation"
"blas.Complex64Level3" <|-- "gonum.Implementation"
"blas.Float32Level1" <|-- "gonum.Implementation"
"blas.Float32Level2" <|-- "gonum.Implementation"
"blas.Float32Level3" <|-- "gonum.Implementation"
"blas.Float64Level1" <|-- "gonum.Implementation"
"blas.Float64Level2" <|-- "gonum.Implementation"
"blas.Float64Level3" <|-- "gonum.Implementation"
"lapack.Float64" <|-- "gonum.Implementation"
"testblas.Dasumer" <|-- "gonum.Implementation"
"testblas.Daxpyer" <|-- "gonum.Implementation"
"testblas.Dcopier" <|-- "gonum.Implementation"
"testblas.Ddotter" <|-- "gonum.Implementation"
"testblas.Dgbmver" <|-- "gonum.Implementation"
"testblas.Dgemmer" <|-- "gonum.Implementation"
"testblas.Dgemver" <|-- "gonum.Implementation"
"testblas.Dgerer" <|-- "gonum.Implementation"
"testblas.Dnrm2er" <|-- "gonum.Implementation"
"testblas.Droter" <|-- "gonum.Implementation"
"testblas.Drotger" <|-- "gonum.Implementation"
"testblas.Drotmer" <|-- "gonum.Implementation"
"testblas.Drotmger" <|-- "gonum.Implementation"
"testblas.Dsbmver" <|-- "gonum.Implementation"
"testblas.Dscaler" <|-- "gonum.Implementation"
"testblas.Dspmver" <|-- "gonum.Implementation"
"testblas.Dspr2er" <|-- "gonum.Implementation"
"testblas.Dsprer" <|-- "gonum.Implementation"
"testblas.Dswapper" <|-- "gonum.Implementation"
"testblas.Dsyker" <|-- "gonum.Implementation"
"testblas.Dsymmer" <|-- "gonum.Implementation"
"testblas.Dsymver" <|-- "gonum.Implementation"
"testblas.Dsyr2er" <|-- "gonum.Implementation"
"testblas.Dsyr2ker" <|-- "gonum.Implementation"
"testblas.Dsyrer" <|-- "gonum.Implementation"
"testblas.Dtbmver" <|-- "gonum.Implementation"
"testblas.Dtbsver" <|-- "gonum.Implementation"
"testblas.Dtpmver" <|-- "gonum.Implementation"
"testblas.Dtpsver" <|-- "gonum.Implementation"
"testblas.Dtrmmer" <|-- "gonum.Implementation"
"testblas.Dtrmver" <|-- "gonum.Implementation"
"testblas.Dtrsmer" <|-- "gonum.Implementation"
"testblas.Dtrsver" <|-- "gonum.Implementation"
"testblas.Dtxmver" <|-- "gonum.Implementation"
"testblas.Dzasumer" <|-- "gonum.Implementation"
"testblas.Dznrm2er" <|-- "gonum.Implementation"
"testblas.Idamaxer" <|-- "gonum.Implementation"
"testblas.Izamaxer" <|-- "gonum.Implementation"
"testblas.Sgerer" <|-- "gonum.Implementation"
"testblas.Zaxpyer" <|-- "gonum.Implementation"
"testblas.Zcopyer" <|-- "gonum.Implementation"
"testblas.Zdotcer" <|-- "gonum.Implementation"
"testblas.Zdotuer" <|-- "gonum.Implementation"
"testblas.Zdscaler" <|-- "gonum.Implementation"
"testblas.Zgbmver" <|-- "gonum.Implementation"
"testblas.Zgemmer" <|-- "gonum.Implementation"
"testblas.Zgemver" <|-- "gonum.Implementation"
"testblas.Zgercer" <|-- "gonum.Implementation"
"testblas.Zgeruer" <|-- "gonum.Implementation"
"testblas.Zhbmver" <|-- "gonum.Implementation"
"testblas.Zhemmer" <|-- "gonum.Implementation"
"testblas.Zhemver" <|-- "gonum.Implementation"
"testblas.Zher2er" <|-- "gonum.Implementation"
"testblas.Zher2ker" <|-- "gonum.Implementation"
"testblas.Zherer" <|-- "gonum.Implementation"
"testblas.Zherker" <|-- "gonum.Implementation"
"testblas.Zhpmver" <|-- "gonum.Implementation"
"testblas.Zhpr2er" <|-- "gonum.Implementation"
"testblas.Zhprer" <|-- "gonum.Implementation"
"testblas.Zscaler" <|-- "gonum.Implementation"
"testblas.Zswaper" <|-- "gonum.Implementation"
"testblas.Zsymmer" <|-- "gonum.Implementation"
"testblas.Zsyr2ker" <|-- "gonum.Implementation"
"testblas.Zsyrker" <|-- "gonum.Implementation"
"testblas.Ztbmver" <|-- "gonum.Implementation"
"testblas.Ztbsver" <|-- "gonum.Implementation"
"testblas.Ztpmver" <|-- "gonum.Implementation"
"testblas.Ztpsver" <|-- "gonum.Implementation"
"testblas.Ztrmmer" <|-- "gonum.Implementation"
"testblas.Ztrmver" <|-- "gonum.Implementation"
"testblas.Ztrsmer" <|-- "gonum.Implementation"
"testblas.Ztrsver" <|-- "gonum.Implementation"
"testlapack.Dbdsqrer" <|-- "gonum.Implementation"
"testlapack.Dgebaker" <|-- "gonum.Implementation"
"testlapack.Dgebaler" <|-- "gonum.Implementation"
"testlapack.Dgebd2er" <|-- "gonum.Implementation"
"testlapack.Dgebrder" <|-- "gonum.Implementation"
"testlapack.Dgeconer" <|-- "gonum.Implementation"
"testlapack.Dgeever" <|-- "gonum.Implementation"
"testlapack.Dgehd2er" <|-- "gonum.Implementation"
"testlapack.Dgehrder" <|-- "gonum.Implementation"
"testlapack.Dgelq2er" <|-- "gonum.Implementation"
"testlapack.Dgelqfer" <|-- "gonum.Implementation"
"testlapack.Dgelser" <|-- "gonum.Implementation"
"testlapack.Dgeql2er" <|-- "gonum.Implementation"
"testlapack.Dgeqp3er" <|-- "gonum.Implementation"
"testlapack.Dgeqr2er" <|-- "gonum.Implementation"
"testlapack.Dgeqrfer" <|-- "gonum.Implementation"
"testlapack.Dgerq2er" <|-- "gonum.Implementation"
"testlapack.Dgerqfer" <|-- "gonum.Implementation"
"testlapack.Dgesc2er" <|-- "gonum.Implementation"
"testlapack.Dgesvder" <|-- "gonum.Implementation"
"testlapack.Dgesver" <|-- "gonum.Implementation"
"testlapack.Dgetc2er" <|-- "gonum.Implementation"
"testlapack.Dgetf2er" <|-- "gonum.Implementation"
"testlapack.Dgetrfer" <|-- "gonum.Implementation"
"testlapack.Dgetrier" <|-- "gonum.Implementation"
"testlapack.Dgetrser" <|-- "gonum.Implementation"
"testlapack.Dggsvd3er" <|-- "gonum.Implementation"
"testlapack.Dggsvp3er" <|-- "gonum.Implementation"
"testlapack.Dgtsver" <|-- "gonum.Implementation"
"testlapack.Dhseqrer" <|-- "gonum.Implementation"
"testlapack.Dlabrder" <|-- "gonum.Implementation"
"testlapack.Dlacn2er" <|-- "gonum.Implementation"
"testlapack.Dlacpyer" <|-- "gonum.Implementation"
"testlapack.Dlae2er" <|-- "gonum.Implementation"
"testlapack.Dlaev2er" <|-- "gonum.Implementation"
"testlapack.Dlaexcer" <|-- "gonum.Implementation"
"testlapack.Dlag2er" <|-- "gonum.Implementation"
"testlapack.Dlags2er" <|-- "gonum.Implementation"
"testlapack.Dlagtmer" <|-- "gonum.Implementation"
"testlapack.Dlahqrer" <|-- "gonum.Implementation"
"testlapack.Dlahr2er" <|-- "gonum.Implementation"
"testlapack.Dlaln2er" <|-- "gonum.Implementation"
"testlapack.Dlangber" <|-- "gonum.Implementation"
"testlapack.Dlanger" <|-- "gonum.Implementation"
"testlapack.Dlangter" <|-- "gonum.Implementation"
"testlapack.Dlansber" <|-- "gonum.Implementation"
"testlapack.Dlanster" <|-- "gonum.Implementation"
"testlapack.Dlansyer" <|-- "gonum.Implementation"
"testlapack.Dlantber" <|-- "gonum.Implementation"
"testlapack.Dlantrer" <|-- "gonum.Implementation"
"testlapack.Dlanv2er" <|-- "gonum.Implementation"
"testlapack.Dlapller" <|-- "gonum.Implementation"
"testlapack.Dlapmrer" <|-- "gonum.Implementation"
"testlapack.Dlapmter" <|-- "gonum.Implementation"
"testlapack.Dlapy2er" <|-- "gonum.Implementation"
"testlapack.Dlaqp2er" <|-- "gonum.Implementation"
"testlapack.Dlaqpser" <|-- "gonum.Implementation"
"testlapack.Dlaqr04er" <|-- "gonum.Implementation"
"testlapack.Dlaqr1er" <|-- "gonum.Implementation"
"testlapack.Dlaqr23er" <|-- "gonum.Implementation"
"testlapack.Dlaqr5er" <|-- "gonum.Implementation"
"testlapack.Dlarfber" <|-- "gonum.Implementation"
"testlapack.Dlarfer" <|-- "gonum.Implementation"
"testlapack.Dlarfger" <|-- "gonum.Implementation"
"testlapack.Dlarfter" <|-- "gonum.Implementation"
"testlapack.Dlarfxer" <|-- "gonum.Implementation"
"testlapack.Dlartger" <|-- "gonum.Implementation"
"testlapack.Dlas2er" <|-- "gonum.Implementation"
"testlapack.Dlascler" <|-- "gonum.Implementation"
"testlapack.Dlaseter" <|-- "gonum.Implementation"
"testlapack.Dlasq1er" <|-- "gonum.Implementation"
"testlapack.Dlasq2er" <|-- "gonum.Implementation"
"testlapack.Dlasrer" <|-- "gonum.Implementation"
"testlapack.Dlasrter" <|-- "gonum.Implementation"
"testlapack.Dlassqer" <|-- "gonum.Implementation"
"testlapack.Dlasv2er" <|-- "gonum.Implementation"
"testlapack.Dlaswper" <|-- "gonum.Implementation"
"testlapack.Dlasy2er" <|-- "gonum.Implementation"
"testlapack.Dlatbser" <|-- "gonum.Implementation"
"testlapack.Dlatrder" <|-- "gonum.Implementation"
"testlapack.Dlatrser" <|-- "gonum.Implementation"
"testlapack.Dlauu2er" <|-- "gonum.Implementation"
"testlapack.Dlauumer" <|-- "gonum.Implementation"
"testlapack.Dorg2ler" <|-- "gonum.Implementation"
"testlapack.Dorg2rer" <|-- "gonum.Implementation"
"testlapack.Dorgbrer" <|-- "gonum.Implementation"
"testlapack.Dorghrer" <|-- "gonum.Implementation"
"testlapack.Dorgl2er" <|-- "gonum.Implementation"
"testlapack.Dorglqer" <|-- "gonum.Implementation"
"testlapack.Dorgqler" <|-- "gonum.Implementation"
"testlapack.Dorgqrer" <|-- "gonum.Implementation"
"testlapack.Dorgr2er" <|-- "gonum.Implementation"
"testlapack.Dorgtrer" <|-- "gonum.Implementation"
"testlapack.Dorm2rer" <|-- "gonum.Implementation"
"testlapack.Dormbrer" <|-- "gonum.Implementation"
"testlapack.Dormhrer" <|-- "gonum.Implementation"
"testlapack.Dorml2er" <|-- "gonum.Implementation"
"testlapack.Dormlqer" <|-- "gonum.Implementation"
"testlapack.Dormqrer" <|-- "gonum.Implementation"
"testlapack.Dormr2er" <|-- "gonum.Implementation"
"testlapack.Dpbconer" <|-- "gonum.Implementation"
"testlapack.Dpbtf2er" <|-- "gonum.Implementation"
"testlapack.Dpbtrfer" <|-- "gonum.Implementation"
"testlapack.Dpbtrser" <|-- "gonum.Implementation"
"testlapack.Dpoconer" <|-- "gonum.Implementation"
"testlapack.Dpotf2er" <|-- "gonum.Implementation"
"testlapack.Dpotrfer" <|-- "gonum.Implementation"
"testlapack.Dpotrier" <|-- "gonum.Implementation"
"testlapack.Dpotrser" <|-- "gonum.Implementation"
"testlapack.Dpstf2er" <|-- "gonum.Implementation"
"testlapack.Dpstrfer" <|-- "gonum.Implementation"
"testlapack.Drscler" <|-- "gonum.Implementation"
"testlapack.Dsteqrer" <|-- "gonum.Implementation"
"testlapack.Dsterfer" <|-- "gonum.Implementation"
"testlapack.Dsyever" <|-- "gonum.Implementation"
"testlapack.Dsytd2er" <|-- "gonum.Implementation"
"testlapack.Dsytrder" <|-- "gonum.Implementation"
"testlapack.Dtbtrser" <|-- "gonum.Implementation"
"testlapack.Dtgsjaer" <|-- "gonum.Implementation"
"testlapack.Dtrconer" <|-- "gonum.Implementation"
"testlapack.Dtrevc3er" <|-- "gonum.Implementation"
"testlapack.Dtrexcer" <|-- "gonum.Implementation"
"testlapack.Dtrti2er" <|-- "gonum.Implementation"
"testlapack.Dtrtrier" <|-- "gonum.Implementation"
"testlapack.Dtrtrser" <|-- "gonum.Implementation"
"testlapack.Iladlcer" <|-- "gonum.Implementation"
"testlapack.Iladlrer" <|-- "gonum.Implementation"

namespace graph {
    interface Builder  {
    }
    class Complement << (S,Aquamarine) >> {
        + Edge(uid int64, vid int64) Edge
        + From(uid int64) Nodes
        + HasEdgeBetween(xid int64, yid int64) bool

    }
    interface Directed  {
        + HasEdgeFromTo(uid int64, vid int64) bool
        + To(id int64) Nodes

    }
    interface DirectedBuilder  {
    }
    interface DirectedMultigraph  {
        + HasEdgeFromTo(uid int64, vid int64) bool
        + To(id int64) Nodes

    }
    interface DirectedMultigraphBuilder  {
    }
    interface DirectedWeightedBuilder  {
    }
    interface DirectedWeightedMultigraphBuilder  {
    }
    interface Edge  {
        + From() Node
        + To() Node
        + ReversedEdge() Edge

    }
    interface EdgeAdder  {
        + NewEdge(from Node, to Node) Edge
        + SetEdge(e Edge) 

    }
    class EdgePair << (S,Aquamarine) >> {
        + From() Node
        + To() Node
        + ReversedEdge() Edge

    }
    interface EdgeRemover  {
        + RemoveEdge(fid int64, tid int64) 

    }
    interface EdgeSlicer  {
        + EdgeSlice() []Edge

    }
    interface Edges  {
        + Edge() Edge

    }
    interface Graph  {
        + Node(id int64) Node
        + Nodes() Nodes
        + From(id int64) Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Edge(uid int64, vid int64) Edge

    }
    interface Iterator  {
        + Next() bool
        + Len() int
        + Reset() 

    }
    interface Line  {
        + From() Node
        + To() Node
        + ReversedLine() Line
        + ID() int64

    }
    interface LineAdder  {
        + NewLine(from Node, to Node) Line
        + SetLine(l Line) 

    }
    interface LineRemover  {
        + RemoveLine(fid int64, tid int64, id int64) 

    }
    interface LineSlicer  {
        + LineSlice() []Line

    }
    interface Lines  {
        + Line() Line

    }
    interface Multigraph  {
        + Node(id int64) Node
        + Nodes() Nodes
        + From(id int64) Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Lines(uid int64, vid int64) Lines

    }
    interface MultigraphBuilder  {
    }
    interface Node  {
        + ID() int64

    }
    interface NodeAdder  {
        + NewNode() Node
        + AddNode( Node) 

    }
    interface NodeRemover  {
        + RemoveNode(id int64) 

    }
    interface NodeSlicer  {
        + NodeSlice() []Node

    }
    interface NodeWithIDer  {
        + NodeWithID(id int64) (Node, bool)

    }
    interface Nodes  {
        + Node() Node

    }
    class Undirect << (S,Aquamarine) >> {
        + G Directed

        + Node(id int64) Node
        + Nodes() Nodes
        + From(uid int64) Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Edge(uid int64, vid int64) Edge
        + EdgeBetween(xid int64, yid int64) Edge

    }
    class UndirectWeighted << (S,Aquamarine) >> {
        + G WeightedDirected
        + Absent float64
        + Merge <font color=blue>func</font>(float64, float64, Edge, Edge) float64

        + Node(id int64) Node
        + Nodes() Nodes
        + From(uid int64) Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Edge(uid int64, vid int64) Edge
        + WeightedEdge(uid int64, vid int64) WeightedEdge
        + EdgeBetween(xid int64, yid int64) Edge
        + WeightedEdgeBetween(xid int64, yid int64) WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)

    }
    interface Undirected  {
        + EdgeBetween(xid int64, yid int64) Edge

    }
    interface UndirectedBuilder  {
    }
    interface UndirectedMultigraph  {
        + LinesBetween(xid int64, yid int64) Lines

    }
    interface UndirectedMultigraphBuilder  {
    }
    interface UndirectedWeightedBuilder  {
    }
    interface UndirectedWeightedMultigraphBuilder  {
    }
    interface Weighted  {
        + WeightedEdge(uid int64, vid int64) WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)

    }
    interface WeightedBuilder  {
    }
    interface WeightedDirected  {
        + HasEdgeFromTo(uid int64, vid int64) bool
        + To(id int64) Nodes

    }
    interface WeightedDirectedMultigraph  {
        + HasEdgeFromTo(uid int64, vid int64) bool
        + To(id int64) Nodes

    }
    interface WeightedEdge  {
        + Weight() float64

    }
    interface WeightedEdgeAdder  {
        + NewWeightedEdge(from Node, to Node, weight float64) WeightedEdge
        + SetWeightedEdge(e WeightedEdge) 

    }
    class WeightedEdgePair << (S,Aquamarine) >> {
        + W float64

        + ReversedEdge() Edge
        + Weight() float64

    }
    interface WeightedEdgeSlicer  {
        + WeightedEdgeSlice() []WeightedEdge

    }
    interface WeightedEdges  {
        + WeightedEdge() WeightedEdge

    }
    interface WeightedLine  {
        + Weight() float64

    }
    interface WeightedLineAdder  {
        + NewWeightedLine(from Node, to Node, weight float64) WeightedLine
        + SetWeightedLine(l WeightedLine) 

    }
    interface WeightedLineSlicer  {
        + WeightedLineSlice() []WeightedLine

    }
    interface WeightedLines  {
        + WeightedLine() WeightedLine

    }
    interface WeightedMultigraph  {
        + WeightedLines(uid int64, vid int64) WeightedLines

    }
    interface WeightedMultigraphBuilder  {
    }
    interface WeightedUndirected  {
        + WeightedEdgeBetween(xid int64, yid int64) WeightedEdge

    }
    interface WeightedUndirectedMultigraph  {
        + WeightedLinesBetween(xid int64, yid int64) WeightedLines

    }
    class empty << (S,Aquamarine) >> {
        + Next() bool
        + Len() int
        + Reset() 
        + Node() Node
        + NodeSlice() []Node
        + Edge() Edge
        + EdgeSlice() []Edge
        + WeightedEdge() WeightedEdge
        + WeightedEdgeSlice() []WeightedEdge
        + Line() Line
        + LineSlice() []Line
        + WeightedLine() WeightedLine
        + WeightedLineSlice() []WeightedLine
        + String() string
        + GoString() string

    }
    class graph.EdgePair << (T, #FF7700) >>  {
    }
    class graph.empty << (T, #FF7700) >>  {
    }
    class nodeFilterIterator << (S,Aquamarine) >> {
        - src Nodes
        - filter <font color=blue>map</font>[int64]bool

        + Len() int
        + Next() bool
        + Node() Node
        + Reset() 

    }
    class nodeIteratorPair << (S,Aquamarine) >> {
        - a Nodes
        - curr Node
        - idx int
        - unique <font color=blue>map</font>[int64]bool

        + Len() int
        + Next() bool
        + Node() Node
        + Reset() 

    }
    class shadow << (S,Aquamarine) >> {
        + F Node

        + From() Node
        + To() Node
        + ReversedEdge() Edge

    }
}
"graph.EdgeAdder" *-- "graph.Builder"
"graph.NodeAdder" *-- "graph.Builder"
"graph.Graph" *-- "graph.Complement"
"graph.Graph" *-- "graph.Directed"
"graph.Builder" *-- "graph.DirectedBuilder"
"graph.Directed" *-- "graph.DirectedBuilder"
"graph.Multigraph" *-- "graph.DirectedMultigraph"
"graph.DirectedMultigraph" *-- "graph.DirectedMultigraphBuilder"
"graph.MultigraphBuilder" *-- "graph.DirectedMultigraphBuilder"
"graph.Directed" *-- "graph.DirectedWeightedBuilder"
"graph.WeightedBuilder" *-- "graph.DirectedWeightedBuilder"
"graph.DirectedMultigraph" *-- "graph.DirectedWeightedMultigraphBuilder"
"graph.WeightedMultigraphBuilder" *-- "graph.DirectedWeightedMultigraphBuilder"
"graph.Iterator" *-- "graph.Edges"
"graph.Iterator" *-- "graph.Lines"
"graph.LineAdder" *-- "graph.MultigraphBuilder"
"graph.NodeAdder" *-- "graph.MultigraphBuilder"
"graph.Iterator" *-- "graph.Nodes"
"graph.Graph" *-- "graph.Undirected"
"graph.Builder" *-- "graph.UndirectedBuilder"
"graph.Undirected" *-- "graph.UndirectedBuilder"
"graph.Multigraph" *-- "graph.UndirectedMultigraph"
"graph.MultigraphBuilder" *-- "graph.UndirectedMultigraphBuilder"
"graph.UndirectedMultigraph" *-- "graph.UndirectedMultigraphBuilder"
"graph.Undirected" *-- "graph.UndirectedWeightedBuilder"
"graph.WeightedBuilder" *-- "graph.UndirectedWeightedBuilder"
"graph.UndirectedMultigraph" *-- "graph.UndirectedWeightedMultigraphBuilder"
"graph.WeightedMultigraphBuilder" *-- "graph.UndirectedWeightedMultigraphBuilder"
"graph.Graph" *-- "graph.Weighted"
"graph.NodeAdder" *-- "graph.WeightedBuilder"
"graph.WeightedEdgeAdder" *-- "graph.WeightedBuilder"
"graph.Weighted" *-- "graph.WeightedDirected"
"graph.WeightedMultigraph" *-- "graph.WeightedDirectedMultigraph"
"graph.Edge" *-- "graph.WeightedEdge"
"graph.EdgePair" *-- "graph.WeightedEdgePair"
"graph.Iterator" *-- "graph.WeightedEdges"
"graph.Line" *-- "graph.WeightedLine"
"graph.Iterator" *-- "graph.WeightedLines"
"graph.Multigraph" *-- "graph.WeightedMultigraph"
"graph.NodeAdder" *-- "graph.WeightedMultigraphBuilder"
"graph.WeightedLineAdder" *-- "graph.WeightedMultigraphBuilder"
"graph.Weighted" *-- "graph.WeightedUndirected"
"graph.WeightedMultigraph" *-- "graph.WeightedUndirectedMultigraph"

"gen.GraphBuilder" <|-- "graph.Complement"
"traverse.Graph" <|-- "graph.Complement"
"dot.basicEdge" <|-- "graph.EdgePair"
"graph.Edge" <|-- "graph.EdgePair"
"testgraph.Edge" <|-- "graph.EdgePair"
"gen.GraphBuilder" <|-- "graph.Undirect"
"graph.Graph" <|-- "graph.Undirect"
"graph.Undirected" <|-- "graph.Undirect"
"traverse.Graph" <|-- "graph.Undirect"
"gen.GraphBuilder" <|-- "graph.UndirectWeighted"
"graph.Graph" <|-- "graph.UndirectWeighted"
"graph.Undirected" <|-- "graph.UndirectWeighted"
"graph.Weighted" <|-- "graph.UndirectWeighted"
"graph.WeightedUndirected" <|-- "graph.UndirectWeighted"
"path.Weighted" <|-- "graph.UndirectWeighted"
"traverse.Graph" <|-- "graph.UndirectWeighted"
"graph.WeightedEdge" <|-- "graph.WeightedEdgePair"
"graph.WeightedLine" <|-- "graph.WeightedEdgePair"
"graph.EdgeSlicer" <|-- "graph.empty"
"graph.Edges" <|-- "graph.empty"
"graph.Iterator" <|-- "graph.empty"
"graph.LineSlicer" <|-- "graph.empty"
"graph.Lines" <|-- "graph.empty"
"graph.NodeSlicer" <|-- "graph.empty"
"graph.Nodes" <|-- "graph.empty"
"graph.WeightedEdgeSlicer" <|-- "graph.empty"
"graph.WeightedEdges" <|-- "graph.empty"
"graph.WeightedLineSlicer" <|-- "graph.empty"
"graph.WeightedLines" <|-- "graph.empty"
"mat.Reseter" <|-- "graph.empty"
"graph.Iterator" <|-- "graph.nodeFilterIterator"
"graph.Nodes" <|-- "graph.nodeFilterIterator"
"mat.Reseter" <|-- "graph.nodeFilterIterator"
"graph.Iterator" <|-- "graph.nodeIteratorPair"
"graph.Nodes" <|-- "graph.nodeIteratorPair"
"mat.Reseter" <|-- "graph.nodeIteratorPair"
"dot.basicEdge" <|-- "graph.shadow"
"graph.Edge" <|-- "graph.shadow"
"testgraph.Edge" <|-- "graph.shadow"

namespace graph6 {
    class Graph << (S,Aquamarine) >> {
        + Edge(uid int64, vid int64) graph.Edge
        + EdgeBetween(xid int64, yid int64) graph.Edge
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + GoString() string

    }
    class g6Iterator << (S,Aquamarine) >> {
        - g Graph
        - from int64
        - to int64

        + Next() bool
        + Len() int
        + Reset() 
        + Node() graph.Node

    }
    class graph6.Graph << (T, #FF7700) >>  {
    }
}

"gen.GraphBuilder" <|-- "graph6.Graph"
"graph.Graph" <|-- "graph6.Graph"
"graph.Undirected" <|-- "graph6.Graph"
"traverse.Graph" <|-- "graph6.Graph"
"graph.Iterator" <|-- "graph6.g6Iterator"
"graph.Nodes" <|-- "graph6.g6Iterator"
"mat.Reseter" <|-- "graph6.g6Iterator"

namespace graphql {
    interface LabelSetter  {
        + SetLabel( string) 

    }
    interface StringIDSetter  {
        + SetIDFromString(uid string) error

    }
    class generator << (S,Aquamarine) >> {
        - dst encoding.Builder
        - uidName string
        - nodes <font color=blue>map</font>[string]graph.Node

        - walk(src json.RawMessage, node graph.Node, attr string) error

    }
}


namespace hyperdual {
    class Number << (S,Aquamarine) >> {
        + Real float64

        + Format(fs fmt.State, c rune) 

    }
}


namespace interp {
    class AkimaSpline << (S,Aquamarine) >> {
        - cubic PiecewiseCubic

        + Predict(x float64) float64
        + PredictDerivative(x float64) float64
        + Fit(xs []float64, ys []float64) error

    }
    class ClampedCubic << (S,Aquamarine) >> {
        - cubic PiecewiseCubic

        + Predict(x float64) float64
        + PredictDerivative(x float64) float64
        + Fit(xs []float64, ys []float64) error

    }
    class Constant << (S,Aquamarine) >> {
        + Predict(x float64) float64

    }
    interface DerivativePredictor  {
        + PredictDerivative(x float64) float64

    }
    interface FittablePredictor  {
    }
    interface Fitter  {
        + Fit(xs []float64, ys []float64) error

    }
    class FritschButland << (S,Aquamarine) >> {
        - cubic PiecewiseCubic

        + Predict(x float64) float64
        + PredictDerivative(x float64) float64
        + Fit(xs []float64, ys []float64) error

    }
    class Function << (S,Aquamarine) >> {
        + Predict(x float64) float64

    }
    class NaturalCubic << (S,Aquamarine) >> {
        - cubic PiecewiseCubic

        + Predict(x float64) float64
        + PredictDerivative(x float64) float64
        + Fit(xs []float64, ys []float64) error

    }
    class NotAKnotCubic << (S,Aquamarine) >> {
        - cubic PiecewiseCubic

        + Predict(x float64) float64
        + PredictDerivative(x float64) float64
        + Fit(xs []float64, ys []float64) error

    }
    class PiecewiseConstant << (S,Aquamarine) >> {
        - xs []float64
        - ys []float64

        + Fit(xs []float64, ys []float64) error
        + Predict(x float64) float64

    }
    class PiecewiseCubic << (S,Aquamarine) >> {
        - xs []float64
        - coeffs mat.Dense
        - lastY float64
        - lastDyDx float64

        - fitWithSecondDerivatives(xs []float64, ys []float64, d2ydx2s []float64) 

        + Predict(x float64) float64
        + PredictDerivative(x float64) float64
        + FitWithDerivatives(xs []float64, ys []float64, dydxs []float64) 

    }
    class PiecewiseLinear << (S,Aquamarine) >> {
        - xs []float64
        - ys []float64
        - slopes []float64

        + Fit(xs []float64, ys []float64) error
        + Predict(x float64) float64

    }
    interface Predictor  {
        + Predict(x float64) float64

    }
    class interp.Constant << (T, #FF7700) >>  {
    }
    class interp.Function << (T, #FF7700) >>  {
    }
}
"interp.Predictor" *-- "interp.DerivativePredictor"
"interp.Fitter" *-- "interp.FittablePredictor"
"interp.Predictor" *-- "interp.FittablePredictor"

"interp.DerivativePredictor" <|-- "interp.AkimaSpline"
"interp.Fitter" <|-- "interp.AkimaSpline"
"interp.Predictor" <|-- "interp.AkimaSpline"
"interp.DerivativePredictor" <|-- "interp.ClampedCubic"
"interp.Fitter" <|-- "interp.ClampedCubic"
"interp.Predictor" <|-- "interp.ClampedCubic"
"interp.Predictor" <|-- "interp.Constant"
"interp.DerivativePredictor" <|-- "interp.FritschButland"
"interp.Fitter" <|-- "interp.FritschButland"
"interp.Predictor" <|-- "interp.FritschButland"
"interp.Predictor" <|-- "interp.Function"
"interp.DerivativePredictor" <|-- "interp.NaturalCubic"
"interp.Fitter" <|-- "interp.NaturalCubic"
"interp.Predictor" <|-- "interp.NaturalCubic"
"interp.DerivativePredictor" <|-- "interp.NotAKnotCubic"
"interp.Fitter" <|-- "interp.NotAKnotCubic"
"interp.Predictor" <|-- "interp.NotAKnotCubic"
"interp.Fitter" <|-- "interp.PiecewiseConstant"
"interp.Predictor" <|-- "interp.PiecewiseConstant"
"interp.DerivativePredictor" <|-- "interp.PiecewiseCubic"
"interp.Predictor" <|-- "interp.PiecewiseCubic"
"interp.Fitter" <|-- "interp.PiecewiseLinear"
"interp.Predictor" <|-- "interp.PiecewiseLinear"

namespace iterator {
    class ImplicitNodes << (S,Aquamarine) >> {
        - beg int
        - curr int
        - newNode <font color=blue>func</font>(int) graph.Node

        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 
        + NodeSlice() []graph.Node

    }
    class LazyOrderedNodes << (S,Aquamarine) >> {
        - iter OrderedNodes
        - nodes <font color=blue>map</font>[int64]graph.Node

        - fillSlice() 

        + Len() int
        + Next() bool
        + Node() graph.Node
        + NodeSlice() []graph.Node
        + Reset() 

    }
    class LazyOrderedNodesByEdge << (S,Aquamarine) >> {
        - iter OrderedNodes
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges <font color=blue>map</font>[int64]graph.Edge

        - fillSlice() 

        + Len() int
        + Next() bool
        + Node() graph.Node
        + NodeSlice() []graph.Node
        + Reset() 

    }
    class LazyOrderedNodesByLines << (S,Aquamarine) >> {
        - iter OrderedNodes
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Line

        - fillSlice() 

        + Len() int
        + Next() bool
        + Node() graph.Node
        + NodeSlice() []graph.Node
        + Reset() 

    }
    class LazyOrderedNodesByWeightedEdge << (S,Aquamarine) >> {
        - iter OrderedNodes
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges <font color=blue>map</font>[int64]graph.WeightedEdge

        - fillSlice() 

        + Len() int
        + Next() bool
        + Node() graph.Node
        + NodeSlice() []graph.Node
        + Reset() 

    }
    class LazyOrderedNodesByWeightedLines << (S,Aquamarine) >> {
        - iter OrderedNodes
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.WeightedLine

        - fillSlice() 

        + Len() int
        + Next() bool
        + Node() graph.Node
        + NodeSlice() []graph.Node
        + Reset() 

    }
    class Lines << (S,Aquamarine) >> {
        - lines int
        - iter *mapIter
        - pos int
        - curr graph.Line
        - lines reflect.Value
        - iter *reflect.MapIter
        - pos int
        - curr graph.Line

        + Len() int
        + Next() bool
        + Line() graph.Line
        + Reset() 
        + LineSlice() []graph.Line
        + Len() int
        + Next() bool
        + Line() graph.Line
        + Reset() 
        + LineSlice() []graph.Line

    }
    class Nodes << (S,Aquamarine) >> {
        - nodes int
        - iter *mapIter
        - pos int
        - curr graph.Node
        - nodes reflect.Value
        - iter *reflect.MapIter
        - pos int
        - curr graph.Node

        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 
        + NodeSlice() []graph.Node
        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 
        + NodeSlice() []graph.Node

    }
    class NodesByEdge << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges int
        - iter *mapIter
        - pos int
        - curr graph.Node
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges reflect.Value
        - iter *reflect.MapIter
        - pos int
        - curr graph.Node

        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 
        + NodeSlice() []graph.Node
        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 
        + NodeSlice() []graph.Node

    }
    class OrderedEdges << (S,Aquamarine) >> {
        - idx int
        - edges []graph.Edge

        + Len() int
        + Next() bool
        + Edge() graph.Edge
        + EdgeSlice() []graph.Edge
        + Reset() 

    }
    class OrderedLines << (S,Aquamarine) >> {
        - idx int
        - lines []graph.Line

        + Len() int
        + Next() bool
        + Line() graph.Line
        + LineSlice() []graph.Line
        + Reset() 

    }
    class OrderedNodes << (S,Aquamarine) >> {
        - idx int
        - nodes []graph.Node

        + Len() int
        + Next() bool
        + Node() graph.Node
        + NodeSlice() []graph.Node
        + Reset() 

    }
    class OrderedWeightedEdges << (S,Aquamarine) >> {
        - idx int
        - edges []graph.WeightedEdge

        + Len() int
        + Next() bool
        + WeightedEdge() graph.WeightedEdge
        + WeightedEdgeSlice() []graph.WeightedEdge
        + Reset() 

    }
    class OrderedWeightedLines << (S,Aquamarine) >> {
        - idx int
        - lines []graph.WeightedLine

        + Len() int
        + Next() bool
        + WeightedLine() graph.WeightedLine
        + WeightedLineSlice() []graph.WeightedLine
        + Reset() 

    }
    class WeightedLines << (S,Aquamarine) >> {
        - lines int
        - iter *mapIter
        - pos int
        - curr graph.WeightedLine
        - lines reflect.Value
        - iter *reflect.MapIter
        - pos int
        - curr graph.WeightedLine

        + Len() int
        + Next() bool
        + WeightedLine() graph.WeightedLine
        + Reset() 
        + WeightedLineSlice() []graph.WeightedLine
        + Len() int
        + Next() bool
        + WeightedLine() graph.WeightedLine
        + Reset() 
        + WeightedLineSlice() []graph.WeightedLine

    }
    class emptyInterface << (S,Aquamarine) >> {
        - typ unsafe.Pointer

    }
    class hiter << (S,Aquamarine) >> {
        - key unsafe.Pointer
        - elem unsafe.Pointer
        - t unsafe.Pointer
        - h unsafe.Pointer
        - buckets unsafe.Pointer
        - bptr unsafe.Pointer
        - overflow *[]unsafe.Pointer
        - oldoverflow *[]unsafe.Pointer
        - startBucket uintptr
        - offset uint8
        - wrapped bool
        - i uint8
        - bucket uintptr
        - checkBucket uintptr

        + B uint8

        - initialized() bool

    }
    class mapIter << (S,Aquamarine) >> {
        - m *emptyInterface
        - hiter hiter

        - id() int64
        - node() graph.Node
        - line() graph.Line
        - weightedLine() graph.WeightedLine
        - next() bool

    }
}

"graph.Iterator" <|-- "iterator.ImplicitNodes"
"graph.NodeSlicer" <|-- "iterator.ImplicitNodes"
"graph.Nodes" <|-- "iterator.ImplicitNodes"
"mat.Reseter" <|-- "iterator.ImplicitNodes"
"graph.Iterator" <|-- "iterator.LazyOrderedNodes"
"graph.NodeSlicer" <|-- "iterator.LazyOrderedNodes"
"graph.Nodes" <|-- "iterator.LazyOrderedNodes"
"mat.Reseter" <|-- "iterator.LazyOrderedNodes"
"graph.Iterator" <|-- "iterator.LazyOrderedNodesByEdge"
"graph.NodeSlicer" <|-- "iterator.LazyOrderedNodesByEdge"
"graph.Nodes" <|-- "iterator.LazyOrderedNodesByEdge"
"mat.Reseter" <|-- "iterator.LazyOrderedNodesByEdge"
"graph.Iterator" <|-- "iterator.LazyOrderedNodesByLines"
"graph.NodeSlicer" <|-- "iterator.LazyOrderedNodesByLines"
"graph.Nodes" <|-- "iterator.LazyOrderedNodesByLines"
"mat.Reseter" <|-- "iterator.LazyOrderedNodesByLines"
"graph.Iterator" <|-- "iterator.LazyOrderedNodesByWeightedEdge"
"graph.NodeSlicer" <|-- "iterator.LazyOrderedNodesByWeightedEdge"
"graph.Nodes" <|-- "iterator.LazyOrderedNodesByWeightedEdge"
"mat.Reseter" <|-- "iterator.LazyOrderedNodesByWeightedEdge"
"graph.Iterator" <|-- "iterator.LazyOrderedNodesByWeightedLines"
"graph.NodeSlicer" <|-- "iterator.LazyOrderedNodesByWeightedLines"
"graph.Nodes" <|-- "iterator.LazyOrderedNodesByWeightedLines"
"mat.Reseter" <|-- "iterator.LazyOrderedNodesByWeightedLines"
"graph.Iterator" <|-- "iterator.Lines"
"graph.LineSlicer" <|-- "iterator.Lines"
"graph.Lines" <|-- "iterator.Lines"
"mat.Reseter" <|-- "iterator.Lines"
"graph.Iterator" <|-- "iterator.Nodes"
"graph.NodeSlicer" <|-- "iterator.Nodes"
"graph.Nodes" <|-- "iterator.Nodes"
"mat.Reseter" <|-- "iterator.Nodes"
"graph.Iterator" <|-- "iterator.NodesByEdge"
"graph.NodeSlicer" <|-- "iterator.NodesByEdge"
"graph.Nodes" <|-- "iterator.NodesByEdge"
"mat.Reseter" <|-- "iterator.NodesByEdge"
"graph.EdgeSlicer" <|-- "iterator.OrderedEdges"
"graph.Edges" <|-- "iterator.OrderedEdges"
"graph.Iterator" <|-- "iterator.OrderedEdges"
"mat.Reseter" <|-- "iterator.OrderedEdges"
"graph.Iterator" <|-- "iterator.OrderedLines"
"graph.LineSlicer" <|-- "iterator.OrderedLines"
"graph.Lines" <|-- "iterator.OrderedLines"
"mat.Reseter" <|-- "iterator.OrderedLines"
"graph.Iterator" <|-- "iterator.OrderedNodes"
"graph.NodeSlicer" <|-- "iterator.OrderedNodes"
"graph.Nodes" <|-- "iterator.OrderedNodes"
"mat.Reseter" <|-- "iterator.OrderedNodes"
"graph.Iterator" <|-- "iterator.OrderedWeightedEdges"
"graph.WeightedEdgeSlicer" <|-- "iterator.OrderedWeightedEdges"
"graph.WeightedEdges" <|-- "iterator.OrderedWeightedEdges"
"mat.Reseter" <|-- "iterator.OrderedWeightedEdges"
"graph.Iterator" <|-- "iterator.OrderedWeightedLines"
"graph.WeightedLineSlicer" <|-- "iterator.OrderedWeightedLines"
"graph.WeightedLines" <|-- "iterator.OrderedWeightedLines"
"mat.Reseter" <|-- "iterator.OrderedWeightedLines"
"graph.Iterator" <|-- "iterator.WeightedLines"
"graph.WeightedLineSlicer" <|-- "iterator.WeightedLines"
"graph.WeightedLines" <|-- "iterator.WeightedLines"
"mat.Reseter" <|-- "iterator.WeightedLines"

namespace kdtree {
    interface Bounder  {
        + Bounds() *Bounding

    }
    class Bounding << (S,Aquamarine) >> {
        + Min Comparable

        + Contains(c Comparable) bool

    }
    interface Comparable  {
        + Compare( Comparable,  Dim) float64
        + Dims() int
        + Distance( Comparable) float64

    }
    class ComparableDist << (S,Aquamarine) >> {
        + Comparable Comparable
        + Dist float64

    }
    class DistKeeper << (S,Aquamarine) >> {
        + Keep(c ComparableDist) 

    }
    interface Extender  {
        + Extend( *Bounding) *Bounding

    }
    class Heap << (S,Aquamarine) >> {
        + Max() ComparableDist
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    interface Interface  {
        + Index(i int) Comparable
        + Len() int
        + Pivot( Dim) int
        + Slice(start int, end int) Interface

    }
    interface Keeper  {
        + Keep( ComparableDist) 
        + Max() ComparableDist

    }
    class NKeeper << (S,Aquamarine) >> {
        + Keep(c ComparableDist) 

    }
    class Node << (S,Aquamarine) >> {
        + Point Comparable
        + Plane Dim
        + Left *Node

        - insert(c Comparable, d Dim) *Node
        - insertBounded(c Extender, d Dim, bounding bool) *Node
        - search(q Comparable, dist float64) (*Node, float64)
        - searchSet(q Comparable, k Keeper) 
        - do(fn Operation, depth int) bool
        - doBounded(fn Operation, b *Bounding, depth int) bool

        + String() string

    }
    class Plane << (S,Aquamarine) >> {
        + Less(i int, j int) bool
        + Pivot() int
        + Slice(start int, end int) SortSlicer
        + Swap(i int, j int) 

    }
    class Point << (S,Aquamarine) >> {
        + Compare(c Comparable, d Dim) float64
        + Dims() int
        + Distance(c Comparable) float64
        + Extend(b *Bounding) *Bounding

    }
    class Points << (S,Aquamarine) >> {
        + Bounds() *Bounding
        + Index(i int) Comparable
        + Len() int
        + Pivot(d Dim) int
        + Slice(start int, end int) Interface

    }
    interface SortSlicer  {
        + Slice(start int, end int) SortSlicer

    }
    class Tree << (S,Aquamarine) >> {
        + Root *Node
        + Count int

        + Insert(c Comparable, bounding bool) 
        + Len() int
        + Contains(c Comparable) bool
        + Nearest(q Comparable) (Comparable, float64)
        + NearestSet(k Keeper, q Comparable) 
        + Do(fn Operation) bool
        + DoBounded(b *Bounding, fn Operation) bool

    }
    interface bounder  {
    }
    class kdtree.Dim << (T, #FF7700) >>  {
    }
    class kdtree.Heap << (T, #FF7700) >>  {
    }
    class kdtree.Operation << (T, #FF7700) >>  {
    }
    class kdtree.Point << (T, #FF7700) >>  {
    }
    class kdtree.Points << (T, #FF7700) >>  {
    }
}
"kdtree.Heap" *-- "kdtree.DistKeeper"
"kdtree.Comparable" *-- "kdtree.Extender"
"kdtree.Heap" *-- "kdtree.NKeeper"
"kdtree.Bounding" *-- "kdtree.Node"
"kdtree.Dim" *-- "kdtree.Plane"
"kdtree.Points" *-- "kdtree.Plane"
"kdtree.Bounder" *-- "kdtree.bounder"
"kdtree.Interface" *-- "kdtree.bounder"

"kdtree.SortSlicer" <|-- "kdtree.Plane"
"kdtree.Comparable" <|-- "kdtree.Point"
"kdtree.Extender" <|-- "kdtree.Point"
"kdtree.Bounder" <|-- "kdtree.Points"
"kdtree.Interface" <|-- "kdtree.Points"

namespace lapack {
    interface Complex128  {
    }
    interface Float64  {
        + Dgecon(norm MatrixNorm, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64
        + Dgeev(jobvl LeftEVJob, jobvr RightEVJob, n int, a []float64, lda int, wr []float64, wi []float64, vl []float64, ldvl int, vr []float64, ldvr int, work []float64, lwork int) int
        + Dgels(trans blas.Transpose, m int, n int, nrhs int, a []float64, lda int, b []float64, ldb int, work []float64, lwork int) bool
        + Dgelqf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dgeqrf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dgesvd(jobU SVDJob, jobVT SVDJob, m int, n int, a []float64, lda int, s []float64, u []float64, ldu int, vt []float64, ldvt int, work []float64, lwork int) bool
        + Dgetrf(m int, n int, a []float64, lda int, ipiv []int) bool
        + Dgetri(n int, a []float64, lda int, ipiv []int, work []float64, lwork int) bool
        + Dgetrs(trans blas.Transpose, n int, nrhs int, a []float64, lda int, ipiv []int, b []float64, ldb int) 
        + Dggsvd3(jobU GSVDJob, jobV GSVDJob, jobQ GSVDJob, m int, n int, p int, a []float64, lda int, b []float64, ldb int, alpha []float64, beta []float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, work []float64, lwork int, iwork []int) (int, int, bool)
        + Dlantr(norm MatrixNorm, uplo blas.Uplo, diag blas.Diag, m int, n int, a []float64, lda int, work []float64) float64
        + Dlange(norm MatrixNorm, m int, n int, a []float64, lda int, work []float64) float64
        + Dlansy(norm MatrixNorm, uplo blas.Uplo, n int, a []float64, lda int, work []float64) float64
        + Dlapmr(forward bool, m int, n int, x []float64, ldx int, k []int) 
        + Dlapmt(forward bool, m int, n int, x []float64, ldx int, k []int) 
        + Dormqr(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 
        + Dormlq(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 
        + Dpbcon(uplo blas.Uplo, n int, kd int, ab []float64, ldab int, anorm float64, work []float64, iwork []int) float64
        + Dpbtrf(uplo blas.Uplo, n int, kd int, ab []float64, ldab int) bool
        + Dpbtrs(uplo blas.Uplo, n int, kd int, nrhs int, ab []float64, ldab int, b []float64, ldb int) 
        + Dpocon(uplo blas.Uplo, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64
        + Dpotrf(ul blas.Uplo, n int, a []float64, lda int) bool
        + Dpotri(ul blas.Uplo, n int, a []float64, lda int) bool
        + Dpotrs(ul blas.Uplo, n int, nrhs int, a []float64, lda int, b []float64, ldb int) 
        + Dpstrf(uplo blas.Uplo, n int, a []float64, lda int, piv []int, tol float64, work []float64) (int, bool)
        + Dsyev(jobz EVJob, uplo blas.Uplo, n int, a []float64, lda int, w []float64, work []float64, lwork int) bool
        + Dtbtrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, kd int, nrhs int, a []float64, lda int, b []float64, ldb int) bool
        + Dtrcon(norm MatrixNorm, uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int, work []float64, iwork []int) float64
        + Dtrtri(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) bool
        + Dtrtrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, nrhs int, a []float64, lda int, b []float64, ldb int) bool

    }
    class lapack.ApplyOrtho << (T, #FF7700) >>  {
    }
    class lapack.BalanceJob << (T, #FF7700) >>  {
    }
    class lapack.Direct << (T, #FF7700) >>  {
    }
    class lapack.EVComp << (T, #FF7700) >>  {
    }
    class lapack.EVHowMany << (T, #FF7700) >>  {
    }
    class lapack.EVJob << (T, #FF7700) >>  {
    }
    class lapack.EVSide << (T, #FF7700) >>  {
    }
    class lapack.GSVDJob << (T, #FF7700) >>  {
    }
    class lapack.GenOrtho << (T, #FF7700) >>  {
    }
    class lapack.LeftEVJob << (T, #FF7700) >>  {
    }
    class lapack.MatrixNorm << (T, #FF7700) >>  {
    }
    class lapack.MatrixType << (T, #FF7700) >>  {
    }
    class lapack.MaximizeNormXJob << (T, #FF7700) >>  {
    }
    class lapack.Pivot << (T, #FF7700) >>  {
    }
    class lapack.RightEVJob << (T, #FF7700) >>  {
    }
    class lapack.SVDJob << (T, #FF7700) >>  {
    }
    class lapack.SchurComp << (T, #FF7700) >>  {
    }
    class lapack.SchurJob << (T, #FF7700) >>  {
    }
    class lapack.Sort << (T, #FF7700) >>  {
    }
    class lapack.StoreV << (T, #FF7700) >>  {
    }
    class lapack.UpdateSchurComp << (T, #FF7700) >>  {
    }
}


namespace lapack64 {
    class Tridiagonal << (S,Aquamarine) >> {
        + N int
        + DL []float64
        + D []float64
        + DU []float64

    }
}


namespace layout {
    class EadesR2 << (S,Aquamarine) >> {
        - nodes graph.Nodes
        - indexOf <font color=blue>map</font>[int64]int
        - particles []barneshut.Particle2
        - forces []r2.Vec

        + Updates int
        + Repulsion float64
        + Rate float64
        + Theta float64
        + Src rand.Source

        + Update(g graph.Graph, layout LayoutR2) bool

    }
    interface GraphR2  {
        + LayoutNodeR2(id int64) NodeR2

    }
    class IsomapR2 << (S,Aquamarine) >> {
        + Update(g graph.Graph, layout LayoutR2) bool

    }
    interface LayoutR2  {
        + IsInitialized() bool
        + SetCoord2(id int64, coords r2.Vec) 
        + Coord2(id int64) r2.Vec

    }
    class NodeR2 << (S,Aquamarine) >> {
        + Coord2 r2.Vec

    }
    class OptimizerR2 << (S,Aquamarine) >> {
        - g graph.Graph
        - layout LayoutR2

        + Updater <font color=blue>func</font>(graph.Graph, LayoutR2) bool

        + Coord2(id int64) r2.Vec
        + Update() bool
        + LayoutNodeR2(id int64) NodeR2
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Edge(uid int64, vid int64) graph.Edge

    }
    class coordinatesR2 << (S,Aquamarine) >> {
        + IsInitialized() bool
        + SetCoord2(id int64, pos r2.Vec) 
        + Coord2(id int64) r2.Vec

    }
    class eadesR2Node << (S,Aquamarine) >> {
        - id int64
        - pos r2.Vec

        + Coord2() r2.Vec
        + Mass() float64

    }
    class layout.coordinatesR2 << (T, #FF7700) >>  {
    }
    class "<font color=blue>map</font>[int64]r2.Vec" as fontcolorbluemapfontint64r2Vec {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"graph.Node" *-- "layout.NodeR2"

"gen.GraphBuilder" <|-- "layout.OptimizerR2"
"graph.Graph" <|-- "layout.OptimizerR2"
"layout.GraphR2" <|-- "layout.OptimizerR2"
"traverse.Graph" <|-- "layout.OptimizerR2"
"layout.LayoutR2" <|-- "layout.coordinatesR2"
"barneshut.Particle2" <|-- "layout.eadesR2Node"

namespace lexer {
    class ActionRow << (S,Aquamarine) >> {
        + Accept token.Type
        + Ignore string

        + String() string

    }
    class Lexer << (S,Aquamarine) >> {
        - src []byte
        - pos int
        - line int
        - column int

        + Scan() *token.Token
        + Reset() 

    }
    class lexer.ActionTable << (T, #FF7700) >>  {
    }
    class lexer.TransitionTable << (T, #FF7700) >>  {
    }
}

"mat.Reseter" <|-- "lexer.Lexer"
"parser.Scanner" <|-- "lexer.Lexer"

namespace linear {
    class NodeQueue << (S,Aquamarine) >> {
        - head int
        - data []graph.Node

        + Len() int
        + Enqueue(n graph.Node) 
        + Dequeue() graph.Node
        + Reset() 

    }
    class NodeStack << (S,Aquamarine) >> {
        + Len() int
        + Pop() graph.Node
        + Push(n graph.Node) 

    }
    class linear.NodeStack << (T, #FF7700) >>  {
    }
    class "[]graph.Node" as graphNode {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}

"mat.Reseter" <|-- "linear.NodeQueue"

namespace main {
    class Constant << (S,Aquamarine) >> {
        + Name string
        + Value string
        + Name string
        + Value float64
        + Dimensions []Dimension
        + Comment string
        + Uncertainty float64

        - dimensions() unit.Dimensions

        + IsDefined() bool
        + Type() string
        + Units() string

    }
    class Dimension << (S,Aquamarine) >> {
        + Name string
        + Power int
        + Name string
        + Power int

    }
    class Prefix << (S,Aquamarine) >> {
        + Name string
        + Power int

    }
    class Unit << (S,Aquamarine) >> {
        + DimensionName string
        + Receiver string
        + PowerOffset int
        + PrintString string
        + ExtraConstant []Constant
        + Name string
        + TypeComment string
        + Dimensions []Dimension
        + ErForm string

        + Units() string

    }
    class builtin << (S,Aquamarine) >> {
        - name <font color=blue>func</font>(float64) string
        - fn <font color=blue>func</font>(float64) <font color=blue>func</font>([]float64) []float64
        - ok <font color=blue>func</font>(float64) bool

    }
    class characteristics << (S,Aquamarine) >> {
        - deltaF0 float64
        - deltaFhalf float64
        - gammaMax float64
        - beta float64

        - k() float64

    }
    class errFile << (S,Aquamarine) >> {
        - file *os.File
        - err error

        + Write(b []byte) 
        + WriteString(s string) 

    }
    class level1functionStruct << (S,Aquamarine) >> {
        - camel string
        - sig string
        - call string
        - extraSetup string
        - oneInput bool
        - extraName string

    }
}


namespace mat {
    class BandCholesky << (S,Aquamarine) >> {
        - chol *TriBandDense
        - cond float64

        - valid() bool

        + Factorize(a SymBanded) bool
        + SolveTo(dst *Dense, b Matrix) error
        + SolveVecTo(dst *VecDense, b Vector) error
        + Cond() float64
        + Reset() 
        + Dims() (int, int)
        + At(i int, j int) float64
        + T() Matrix
        + TBand() Banded
        + SymmetricDim() int
        + Bandwidth() (int, int)
        + SymBand() (int, int)
        + IsEmpty() bool
        + Det() float64
        + LogDet() float64

    }
    class BandDense << (S,Aquamarine) >> {
        - mat blas64.Band

        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - at(i int, j int) float64
        - set(i int, j int, v float64) 

        + Dims() (int, int)
        + Bandwidth() (int, int)
        + T() Matrix
        + TBand() Banded
        + RawBand() blas64.Band
        + SetRawBand(mat blas64.Band) 
        + IsEmpty() bool
        + Reset() 
        + DiagView() Diagonal
        + DoNonZero(fn <font color=blue>func</font>(int, int, float64) ) 
        + DoRowNonZero(i int, fn <font color=blue>func</font>(int, int, float64) ) 
        + DoColNonZero(j int, fn <font color=blue>func</font>(int, int, float64) ) 
        + Zero() 
        + Norm(norm float64) float64
        + Trace() float64
        + MulVecTo(dst *VecDense, trans bool, x Vector) 
        + At(i int, j int) float64
        + SetBand(i int, j int, v float64) 
        + At(i int, j int) float64
        + SetBand(i int, j int, v float64) 

    }
    interface Banded  {
        + Bandwidth() (int, int)
        + TBand() Banded

    }
    class CDense << (S,Aquamarine) >> {
        - mat cblas128.General
        - capRows int

        - slice(i int, k int, j int, l int) *CDense
        - reuseAsNonZeroed(r int, c int) 
        - reuseAsZeroed(r int, c int) 
        - isolatedWorkspace(a CMatrix) (*CDense, <font color=blue>func</font>() )
        - at(i int, j int) complex128
        - set(i int, j int, v complex128) 
        - at(i int, j int) complex128
        - set(i int, j int, v complex128) 
        - checkOverlap(a cblas128.General) bool
        - checkOverlapMatrix(a CMatrix) bool

        + Dims() (int, int)
        + Caps() (int, int)
        + H() CMatrix
        + T() CMatrix
        + Conj(a CMatrix) 
        + Slice(i int, k int, j int, l int) CMatrix
        + ReuseAs(r int, c int) 
        + Reset() 
        + IsEmpty() bool
        + Zero() 
        + Copy(a CMatrix) (int, int)
        + SetRawCMatrix(b cblas128.General) 
        + RawCMatrix() cblas128.General
        + Grow(r int, c int) CMatrix
        + At(i int, j int) complex128
        + Set(i int, j int, v complex128) 
        + At(i int, j int) complex128
        + Set(i int, j int, v complex128) 

    }
    interface CMatrix  {
        + Dims() (int, int)
        + At(i int, j int) complex128
        + H() CMatrix
        + T() CMatrix

    }
    class CTranspose << (S,Aquamarine) >> {
        + CMatrix CMatrix

        + At(i int, j int) complex128
        + Dims() (int, int)
        + H() CMatrix
        + T() CMatrix
        + Untranspose() CMatrix

    }
    interface CUntransposer  {
        + Untranspose() CMatrix

    }
    class Cholesky << (S,Aquamarine) >> {
        - chol *TriDense
        - cond float64

        - updateCond(norm float64) 
        - valid() bool

        + Dims() (int, int)
        + At(i int, j int) float64
        + T() Matrix
        + SymmetricDim() int
        + Cond() float64
        + Factorize(a Symmetric) bool
        + Reset() 
        + IsEmpty() bool
        + SetFromU(t Triangular) 
        + Clone(chol *Cholesky) 
        + Det() float64
        + LogDet() float64
        + SolveTo(dst *Dense, b Matrix) error
        + SolveCholTo(dst *Dense, b *Cholesky) error
        + SolveVecTo(dst *VecDense, b Vector) error
        + RawU() Triangular
        + UTo(dst *TriDense) 
        + LTo(dst *TriDense) 
        + ToSym(dst *SymDense) 
        + InverseTo(dst *SymDense) error
        + Scale(f float64, orig *Cholesky) 
        + ExtendVecSym(a *Cholesky, v Vector) bool
        + SymRankOne(orig *Cholesky, alpha float64, x Vector) bool

    }
    interface ClonerFrom  {
        + CloneFrom(a Matrix) 

    }
    interface ColNonZeroDoer  {
        + DoColNonZero(j int, fn <font color=blue>func</font>(int, int, float64) ) 

    }
    interface ColViewer  {
        + ColView(j int) Vector

    }
    class Condition << (S,Aquamarine) >> {
        + Error() string

    }
    class ConjTranspose << (S,Aquamarine) >> {
        + CMatrix CMatrix

        + At(i int, j int) complex128
        + Dims() (int, int)
        + H() CMatrix
        + T() CMatrix
        + UnConjTranspose() CMatrix

    }
    interface Copier  {
        + Copy(a Matrix) (int, int)

    }
    class Dense << (S,Aquamarine) >> {
        - mat blas64.General
        - capRows int

        - reuseAsNonZeroed(r int, c int) 
        - reuseAsZeroed(r int, c int) 
        - isolatedWorkspace(a Matrix) (*Dense, <font color=blue>func</font>() )
        - asTriDense(n int, diag blas.Diag, uplo blas.Uplo) *TriDense
        - rawRowView(i int) []float64
        - slice(i int, k int, j int, l int) *Dense
        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - checkOverlap(a blas64.General) bool
        - checkOverlapMatrix(a Matrix) bool

        + ReuseAs(r int, c int) 
        + Zero() 
        + Reset() 
        + IsEmpty() bool
        + SetRawMatrix(b blas64.General) 
        + RawMatrix() blas64.General
        + Dims() (int, int)
        + Caps() (int, int)
        + T() Matrix
        + ColView(j int) Vector
        + SetCol(j int, src []float64) 
        + SetRow(i int, src []float64) 
        + RowView(i int) Vector
        + RawRowView(i int) []float64
        + DiagView() Diagonal
        + Slice(i int, k int, j int, l int) Matrix
        + Grow(r int, c int) Matrix
        + CloneFrom(a Matrix) 
        + Copy(a Matrix) (int, int)
        + Stack(a Matrix, b Matrix) 
        + Augment(a Matrix, b Matrix) 
        + Trace() float64
        + Norm(norm float64) float64
        + Add(a Matrix, b Matrix) 
        + Sub(a Matrix, b Matrix) 
        + MulElem(a Matrix, b Matrix) 
        + DivElem(a Matrix, b Matrix) 
        + Inverse(a Matrix) error
        + Mul(a Matrix, b Matrix) 
        + Exp(a Matrix) 
        + Pow(a Matrix, n int) 
        + Kronecker(a Matrix, b Matrix) 
        + Scale(f float64, a Matrix) 
        + Apply(fn <font color=blue>func</font>(int, int, float64) float64, a Matrix) 
        + RankOne(a Matrix, alpha float64, x Vector, y Vector) 
        + Outer(alpha float64, x Vector, y Vector) 
        + At(i int, j int) float64
        + Set(i int, j int, v float64) 
        + At(i int, j int) float64
        + Set(i int, j int, v float64) 
        + MarshalBinary() ([]byte, error)
        + MarshalBinaryTo(w io.Writer) (int, error)
        + UnmarshalBinary(data []byte) error
        + UnmarshalBinaryFrom(r io.Reader) (int, error)
        + Permutation(r int, swaps []int) 
        + Product(factors ...Matrix) 
        + Solve(a Matrix, b Matrix) error

    }
    class DiagDense << (S,Aquamarine) >> {
        - mat blas64.Vector

        - reuseAsNonZeroed(r int) 
        - at(i int, j int) float64
        - setDiag(i int, v float64) 
        - at(i int, j int) float64
        - setDiag(i int, v float64) 

        + Diag() int
        + Dims() (int, int)
        + T() Matrix
        + TTri() Triangular
        + TBand() Banded
        + TTriBand() TriBanded
        + Bandwidth() (int, int)
        + SymmetricDim() int
        + SymBand() (int, int)
        + Triangle() (int, TriKind)
        + TriBand() (int, int, TriKind)
        + Reset() 
        + Zero() 
        + DiagView() Diagonal
        + DiagFrom(m Matrix) 
        + RawBand() blas64.Band
        + RawSymBand() blas64.SymmetricBand
        + IsEmpty() bool
        + Trace() float64
        + Norm(norm float64) float64
        + At(i int, j int) float64
        + SetDiag(i int, v float64) 
        + At(i int, j int) float64
        + SetDiag(i int, v float64) 

    }
    interface Diagonal  {
        + Diag() int

    }
    class Eigen << (S,Aquamarine) >> {
        - n int
        - kind EigenKind
        - values []complex128
        - rVectors *CDense
        - lVectors *CDense

        - succFact() bool
        - complexEigenTo(dst *CDense, d *Dense) 

        + Factorize(a Matrix, kind EigenKind) bool
        + Kind() EigenKind
        + Values(dst []complex128) []complex128
        + VectorsTo(dst *CDense) 
        + LeftVectorsTo(dst *CDense) 

    }
    class EigenSym << (S,Aquamarine) >> {
        - vectorsComputed bool
        - values []float64
        - vectors *Dense

        - succFact() bool

        + Factorize(a Symmetric, vectors bool) bool
        + Values(dst []float64) []float64
        + VectorsTo(dst *Dense) 

    }
    class Error << (S,Aquamarine) >> {
        + Error() string

    }
    class ErrorStack << (S,Aquamarine) >> {
        + Err error
        + StackTrace string

        + Error() string

    }
    class GSVD << (S,Aquamarine) >> {
        - kind GSVDKind
        - r int
        - s1 []float64
        - a blas64.General
        - work []float64
        - iwork []int

        - succFact() bool

        + Factorize(a Matrix, b Matrix, kind GSVDKind) bool
        + Kind() GSVDKind
        + Rank() (int, int)
        + GeneralizedValues(v []float64) []float64
        + ValuesA(s []float64) []float64
        + ValuesB(s []float64) []float64
        + ZeroRTo(dst *Dense) 
        + SigmaATo(dst *Dense) 
        + SigmaBTo(dst *Dense) 
        + UTo(dst *Dense) 
        + VTo(dst *Dense) 
        + QTo(dst *Dense) 

    }
    interface Grower  {
        + Caps() (int, int)
        + Grow(r int, c int) Matrix

    }
    class HOGSVD << (S,Aquamarine) >> {
        - n int
        - v *Dense
        - b []Dense
        - err error

        - succFact() bool

        + Factorize(m ...Matrix) bool
        + Err() error
        + Len() int
        + UTo(dst *Dense, n int) 
        + Values(s []float64, n int) []float64
        + VTo(dst *Dense) 

    }
    class LQ << (S,Aquamarine) >> {
        - lq *Dense
        - tau []float64
        - cond float64

        - updateCond(norm lapack.MatrixNorm) 
        - factorize(a Matrix, norm lapack.MatrixNorm) 
        - isValid() bool

        + Factorize(a Matrix) 
        + Cond() float64
        + LTo(dst *Dense) 
        + QTo(dst *Dense) 
        + SolveTo(dst *Dense, trans bool, b Matrix) error
        + SolveVecTo(dst *VecDense, trans bool, b Vector) error

    }
    class LU << (S,Aquamarine) >> {
        - lu *Dense
        - pivot []int
        - cond float64

        - updateCond(anorm float64, norm lapack.MatrixNorm) 
        - factorize(a Matrix, norm lapack.MatrixNorm) 
        - isValid() bool
        - isZero() bool

        + Factorize(a Matrix) 
        + Cond() float64
        + Reset() 
        + Det() float64
        + LogDet() (float64, float64)
        + Pivot(swaps []int) []int
        + RankOne(orig *LU, alpha float64, x Vector, y Vector) 
        + LTo(dst *TriDense) *TriDense
        + UTo(dst *TriDense) 
        + SolveTo(dst *Dense, trans bool, b Matrix) error
        + SolveVecTo(dst *VecDense, trans bool, b Vector) error

    }
    interface Matrix  {
        + Dims() (int, int)
        + At(i int, j int) float64
        + T() Matrix

    }
    interface Mutable  {
        + Set(i int, j int, v float64) 

    }
    interface MutableBanded  {
        + SetBand(i int, j int, v float64) 

    }
    interface MutableDiagonal  {
        + SetDiag(i int, v float64) 

    }
    interface MutableSymBanded  {
        + SetSymBand(i int, j int, v float64) 

    }
    interface MutableSymmetric  {
        + SetSym(i int, j int, v float64) 

    }
    interface MutableTriBanded  {
        + SetTriBand(i int, j int, v float64) 

    }
    interface MutableTriangular  {
        + SetTri(i int, j int, v float64) 

    }
    interface MutableVector  {
        + SetVec(i int, v float64) 

    }
    interface NonZeroDoer  {
        + DoNonZero( <font color=blue>func</font>(int, int, float64) ) 

    }
    interface Normer  {
        + Norm(norm float64) float64

    }
    class QR << (S,Aquamarine) >> {
        - qr *Dense
        - tau []float64
        - cond float64

        - updateCond(norm lapack.MatrixNorm) 
        - factorize(a Matrix, norm lapack.MatrixNorm) 
        - isValid() bool

        + Factorize(a Matrix) 
        + Cond() float64
        + RTo(dst *Dense) 
        + QTo(dst *Dense) 
        + SolveTo(dst *Dense, trans bool, b Matrix) error
        + SolveVecTo(dst *VecDense, trans bool, b Vector) error

    }
    interface RawBander  {
        + RawBand() blas64.Band

    }
    interface RawCMatrixer  {
        + RawCMatrix() cblas128.General

    }
    interface RawColViewer  {
        + RawColView(j int) []float64

    }
    interface RawMatrixSetter  {
        + SetRawMatrix(a blas64.General) 

    }
    interface RawMatrixer  {
        + RawMatrix() blas64.General

    }
    interface RawRowViewer  {
        + RawRowView(i int) []float64

    }
    interface RawSymBander  {
        + RawSymBand() blas64.SymmetricBand

    }
    interface RawSymmetricer  {
        + RawSymmetric() blas64.Symmetric

    }
    interface RawTriBander  {
        + RawTriBand() blas64.TriangularBand

    }
    interface RawTriangular  {
        + RawTriangular() blas64.Triangular

    }
    interface RawTridiagonaler  {
        + RawTridiagonal() lapack64.Tridiagonal

    }
    interface RawVectorer  {
        + RawVector() blas64.Vector

    }
    interface Reseter  {
        + Reset() 

    }
    interface RowNonZeroDoer  {
        + DoRowNonZero(i int, fn <font color=blue>func</font>(int, int, float64) ) 

    }
    interface RowViewer  {
        + RowView(i int) Vector

    }
    class SVD << (S,Aquamarine) >> {
        - kind SVDKind
        - s []float64
        - u blas64.General
        - vt blas64.General

        - succFact() bool

        + Factorize(a Matrix, kind SVDKind) bool
        + Kind() SVDKind
        + Rank(rcond float64) int
        + Cond() float64
        + Values(s []float64) []float64
        + UTo(dst *Dense) 
        + VTo(dst *Dense) 
        + SolveTo(dst *Dense, b Matrix, rank int) []float64
        + SolveVecTo(dst *VecDense, b Vector, rank int) float64

    }
    class SymBandDense << (S,Aquamarine) >> {
        - mat blas64.SymmetricBand

        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - checkOverlap(a blas64.General) bool
        - checkOverlapMatrix(a Matrix) bool

        + At(i int, j int) float64
        + SetSymBand(i int, j int, v float64) 
        + At(i int, j int) float64
        + SetSymBand(i int, j int, v float64) 
        + Dims() (int, int)
        + SymmetricDim() int
        + Bandwidth() (int, int)
        + SymBand() (int, int)
        + T() Matrix
        + TBand() Banded
        + RawSymBand() blas64.SymmetricBand
        + SetRawSymBand(mat blas64.SymmetricBand) 
        + IsEmpty() bool
        + Reset() 
        + Zero() 
        + DiagView() Diagonal
        + DoNonZero(fn <font color=blue>func</font>(int, int, float64) ) 
        + DoRowNonZero(i int, fn <font color=blue>func</font>(int, int, float64) ) 
        + DoColNonZero(j int, fn <font color=blue>func</font>(int, int, float64) ) 
        + Norm(norm float64) float64
        + Trace() float64
        + MulVecTo(dst *VecDense, _ bool, x Vector) 

    }
    interface SymBanded  {
        + SymmetricDim() int
        + SymBand() (int, int)

    }
    class SymDense << (S,Aquamarine) >> {
        - mat blas64.Symmetric
        - cap int

        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - checkOverlap(a blas64.General) bool
        - checkOverlapMatrix(a Matrix) bool
        - reuseAsNonZeroed(n int) 
        - reuseAsZeroed(n int) 
        - isolatedWorkspace(a Symmetric) (*SymDense, <font color=blue>func</font>() )
        - sliceSym(i int, k int) *SymDense

        + At(i int, j int) float64
        + SetSym(i int, j int, v float64) 
        + At(i int, j int) float64
        + SetSym(i int, j int, v float64) 
        + Dims() (int, int)
        + Caps() (int, int)
        + T() Matrix
        + SymmetricDim() int
        + RawSymmetric() blas64.Symmetric
        + SetRawSymmetric(mat blas64.Symmetric) 
        + Reset() 
        + ReuseAsSym(n int) 
        + Zero() 
        + IsEmpty() bool
        + DiagView() Diagonal
        + AddSym(a Symmetric, b Symmetric) 
        + CopySym(a Symmetric) int
        + SymRankOne(a Symmetric, alpha float64, x Vector) 
        + SymRankK(a Symmetric, alpha float64, x Matrix) 
        + SymOuterK(alpha float64, x Matrix) 
        + RankTwo(a Symmetric, alpha float64, x Vector, y Vector) 
        + ScaleSym(f float64, a Symmetric) 
        + SubsetSym(a Symmetric, set []int) 
        + SliceSym(i int, k int) Symmetric
        + Norm(norm float64) float64
        + Trace() float64
        + GrowSym(n int) Symmetric
        + PowPSD(a Symmetric, pow float64) error

    }
    interface Symmetric  {
        + SymmetricDim() int

    }
    interface Tracer  {
        + Trace() float64

    }
    class Transpose << (S,Aquamarine) >> {
        + Matrix Matrix

        + At(i int, j int) float64
        + Dims() (int, int)
        + T() Matrix
        + Untranspose() Matrix

    }
    class TransposeBand << (S,Aquamarine) >> {
        + Banded Banded

        + At(i int, j int) float64
        + Dims() (int, int)
        + T() Matrix
        + Bandwidth() (int, int)
        + TBand() Banded
        + Untranspose() Matrix
        + UntransposeBand() Banded

    }
    class TransposeTri << (S,Aquamarine) >> {
        + Triangular Triangular

        + At(i int, j int) float64
        + Dims() (int, int)
        + T() Matrix
        + Triangle() (int, TriKind)
        + TTri() Triangular
        + Untranspose() Matrix
        + UntransposeTri() Triangular

    }
    class TransposeTriBand << (S,Aquamarine) >> {
        + TriBanded TriBanded

        + At(i int, j int) float64
        + Dims() (int, int)
        + T() Matrix
        + Triangle() (int, TriKind)
        + TTri() Triangular
        + Bandwidth() (int, int)
        + TBand() Banded
        + TriBand() (int, int, TriKind)
        + TTriBand() TriBanded
        + Untranspose() Matrix
        + UntransposeTri() Triangular
        + UntransposeBand() Banded
        + UntransposeTriBand() TriBanded

    }
    class TransposeVec << (S,Aquamarine) >> {
        + Vector Vector

        + At(i int, j int) float64
        + AtVec(i int) float64
        + Dims() (int, int)
        + T() Matrix
        + Len() int
        + TVec() Vector
        + Untranspose() Matrix
        + UntransposeVec() Vector

    }
    class TriBandDense << (S,Aquamarine) >> {
        - mat blas64.TriangularBand

        - at(i int, j int) float64
        - setTriBand(i int, j int, v float64) 
        - at(i int, j int) float64
        - reuseAsZeroed(n int, k int, kind TriKind) 
        - reuseAsNonZeroed(n int, k int, kind TriKind) 
        - isUpper() bool
        - triKind() TriKind

        + At(i int, j int) float64
        + SetTriBand(i int, j int, v float64) 
        + At(i int, j int) float64
        + SetTriBand(i int, j int, v float64) 
        + Dims() (int, int)
        + T() Matrix
        + IsEmpty() bool
        + Reset() 
        + ReuseAsTriBand(n int, k int, kind TriKind) 
        + DoNonZero(fn <font color=blue>func</font>(int, int, float64) ) 
        + DoRowNonZero(i int, fn <font color=blue>func</font>(int, int, float64) ) 
        + DoColNonZero(j int, fn <font color=blue>func</font>(int, int, float64) ) 
        + Zero() 
        + Triangle() (int, TriKind)
        + TTri() Triangular
        + Bandwidth() (int, int)
        + TBand() Banded
        + TriBand() (int, int, TriKind)
        + TTriBand() TriBanded
        + RawTriBand() blas64.TriangularBand
        + SetRawTriBand(mat blas64.TriangularBand) 
        + DiagView() Diagonal
        + Norm(norm float64) float64
        + Trace() float64
        + SolveTo(dst *Dense, trans bool, b Matrix) error
        + SolveVecTo(dst *VecDense, trans bool, b Vector) error

    }
    interface TriBanded  {
        + Triangle() (int, TriKind)
        + TTri() Triangular
        + TriBand() (int, int, TriKind)
        + TTriBand() TriBanded

    }
    class TriDense << (S,Aquamarine) >> {
        - mat blas64.Triangular
        - cap int

        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - checkOverlap(a blas64.General) bool
        - checkOverlapMatrix(a Matrix) bool
        - isUpper() bool
        - triKind() TriKind
        - asSymBlas() blas64.Symmetric
        - reuseAsNonZeroed(n int, kind TriKind) 
        - reuseAsZeroed(n int, kind TriKind) 
        - isolatedWorkspace(a Triangular) (*TriDense, <font color=blue>func</font>() )
        - sliceTri(i int, k int) *TriDense

        + At(i int, j int) float64
        + SetTri(i int, j int, v float64) 
        + At(i int, j int) float64
        + SetTri(i int, j int, v float64) 
        + Dims() (int, int)
        + Triangle() (int, TriKind)
        + T() Matrix
        + TTri() Triangular
        + RawTriangular() blas64.Triangular
        + SetRawTriangular(mat blas64.Triangular) 
        + Reset() 
        + Zero() 
        + IsEmpty() bool
        + ReuseAsTri(n int, kind TriKind) 
        + DiagView() Diagonal
        + Copy(a Matrix) (int, int)
        + InverseTri(a Triangular) error
        + MulTri(a Triangular, b Triangular) 
        + ScaleTri(f float64, a Triangular) 
        + SliceTri(i int, k int) Triangular
        + Norm(norm float64) float64
        + Trace() float64
        + DoNonZero(fn <font color=blue>func</font>(int, int, float64) ) 
        + DoRowNonZero(i int, fn <font color=blue>func</font>(int, int, float64) ) 
        + DoColNonZero(j int, fn <font color=blue>func</font>(int, int, float64) ) 

    }
    interface Triangular  {
        + Triangle() (int, TriKind)
        + TTri() Triangular

    }
    class Tridiag << (S,Aquamarine) >> {
        - mat lapack64.Tridiagonal

        - at(i int, j int) float64
        - set(i int, j int, v float64) 
        - at(i int, j int) float64
        - set(i int, j int, v float64) 

        + At(i int, j int) float64
        + SetBand(i int, j int, v float64) 
        + At(i int, j int) float64
        + SetBand(i int, j int, v float64) 
        + Dims() (int, int)
        + Bandwidth() (int, int)
        + T() Matrix
        + TBand() Banded
        + RawTridiagonal() lapack64.Tridiagonal
        + SetRawTridiagonal(mat lapack64.Tridiagonal) 
        + IsEmpty() bool
        + Reset() 
        + CloneFromTridiag(from *Tridiag) 
        + DiagView() Diagonal
        + Zero() 
        + Trace() float64
        + Norm(norm float64) float64
        + MulVecTo(dst *VecDense, trans bool, x Vector) 
        + SolveTo(dst *Dense, trans bool, b Matrix) error
        + SolveVecTo(dst *VecDense, trans bool, b Vector) error
        + DoNonZero(fn <font color=blue>func</font>(int, int, float64) ) 
        + DoRowNonZero(i int, fn <font color=blue>func</font>(int, int, float64) ) 
        + DoColNonZero(j int, fn <font color=blue>func</font>(int, int, float64) ) 

    }
    interface UnConjTransposer  {
        + UnConjTranspose() CMatrix

    }
    interface UntransposeBander  {
        + UntransposeBand() Banded

    }
    interface UntransposeTriBander  {
        + UntransposeTriBand() TriBanded

    }
    interface UntransposeTrier  {
        + UntransposeTri() Triangular

    }
    interface Untransposer  {
        + Untranspose() Matrix

    }
    class VecDense << (S,Aquamarine) >> {
        - mat blas64.Vector

        - at(i int) float64
        - setVec(i int, val float64) 
        - at(i int) float64
        - setVec(i int, val float64) 
        - checkOverlap(a blas64.Vector) bool
        - sliceVec(i int, k int) *VecDense
        - reuseAsNonZeroed(r int) 
        - reuseAsZeroed(r int) 
        - isolatedWorkspace(a Vector) (*VecDense, <font color=blue>func</font>() )
        - asDense() *Dense
        - asGeneral() blas64.General

        + At(i int, j int) float64
        + AtVec(i int) float64
        + SetVec(i int, val float64) 
        + At(i int, j int) float64
        + AtVec(i int) float64
        + SetVec(i int, val float64) 
        + MarshalBinary() ([]byte, error)
        + MarshalBinaryTo(w io.Writer) (int, error)
        + UnmarshalBinary(data []byte) error
        + UnmarshalBinaryFrom(r io.Reader) (int, error)
        + SolveVec(a Matrix, b Vector) error
        + SliceVec(i int, k int) Vector
        + Dims() (int, int)
        + Caps() (int, int)
        + Len() int
        + Cap() int
        + T() Matrix
        + TVec() Vector
        + Reset() 
        + Zero() 
        + CloneFromVec(a Vector) 
        + RawVector() blas64.Vector
        + SetRawVector(a blas64.Vector) 
        + CopyVec(a Vector) int
        + Norm(norm float64) float64
        + ScaleVec(alpha float64, a Vector) 
        + AddScaledVec(a Vector, alpha float64, b Vector) 
        + AddVec(a Vector, b Vector) 
        + SubVec(a Vector, b Vector) 
        + MulElemVec(a Vector, b Vector) 
        + DivElemVec(a Vector, b Vector) 
        + MulVec(a Matrix, b Vector) 
        + ReuseAsVec(n int) 
        + IsEmpty() bool
        + ColViewOf(m RawMatrixer, j int) 
        + RowViewOf(m RawMatrixer, i int) 

    }
    interface Vector  {
        + AtVec( int) float64
        + Len() int

    }
    interface allMatrix  {
        + IsEmpty() bool
        + Zero() 

    }
    class columnWidth << (S,Aquamarine) >> {
        - width(i int) int
        - setWidth(i int, w int) 

    }
    interface denseMatrix  {
        + DiagView() Diagonal

    }
    class entry << (S,Aquamarine) >> {
        - k int
        - cost int

    }
    class formatter << (S,Aquamarine) >> {
        - matrix Matrix
        - prefix string
        - margin int
        - dot byte
        - squeeze bool
        - format <font color=blue>func</font>(Matrix, string, int, byte, bool, fmt.State, rune) 

        + Format(fs fmt.State, c rune) 

    }
    class mat.Condition << (T, #FF7700) >>  {
    }
    class mat.EigenKind << (T, #FF7700) >>  {
    }
    class mat.FormatOption << (T, #FF7700) >>  {
    }
    class mat.GSVDKind << (T, #FF7700) >>  {
    }
    class mat.SVDKind << (T, #FF7700) >>  {
    }
    class mat.TriKind << (T, #FF7700) >>  {
    }
    class mat.columnWidth << (T, #FF7700) >>  {
    }
    class mat.result << (T, #FF7700) >>  {
    }
    class mat.uniformWidth << (T, #FF7700) >>  {
    }
    class multiplier << (S,Aquamarine) >> {
        - factors []Matrix
        - dims []int
        - table table

        - optimize() 
        - multiply() *Dense
        - multiplySubchain(i int, j int) (Matrix, bool)

    }
    class repVector << (S,Aquamarine) >> {
        - vec []float64
        - cols int

        + Dims() (int, int)
        + At(i int, j int) float64
        + T() Matrix

    }
    class result << (S,Aquamarine) >> {
        + String() string

    }
    class storage << (S,Aquamarine) >> {
        + Version uint32
        + Form byte
        + Packing byte
        + Uplo byte
        + Unit bool
        + Rows int64
        + Cols int64
        + KU int64
        + KL int64

        - marshalBinaryTo(w io.Writer) (int, error)
        - unmarshalBinary(buf []byte) error
        - unmarshalBinaryFrom(r io.Reader) (int, error)

    }
    class table << (S,Aquamarine) >> {
        - n int
        - entries []entry

        - at(i int, j int) entry
        - set(i int, j int, e entry) 

    }
    class uniformWidth << (S,Aquamarine) >> {
        - width(_ int) int
        - setWidth(_ int, w int) 

    }
    interface widther  {
        - width(i int) int
        - setWidth(i int, w int) 

    }
}
"mat.Matrix" *-- "mat.Banded"
"mat.Banded" *-- "mat.Diagonal"
"mat.Matrix" *-- "mat.Diagonal"
"mat.SymBanded" *-- "mat.Diagonal"
"mat.Symmetric" *-- "mat.Diagonal"
"mat.TriBanded" *-- "mat.Diagonal"
"mat.Triangular" *-- "mat.Diagonal"
"__builtin__.string" *-- "mat.Error"
"mat.Matrix" *-- "mat.Mutable"
"mat.Banded" *-- "mat.MutableBanded"
"mat.Diagonal" *-- "mat.MutableDiagonal"
"mat.SymBanded" *-- "mat.MutableSymBanded"
"mat.Symmetric" *-- "mat.MutableSymmetric"
"mat.TriBanded" *-- "mat.MutableTriBanded"
"mat.Triangular" *-- "mat.MutableTriangular"
"mat.Vector" *-- "mat.MutableVector"
"mat.Banded" *-- "mat.SymBanded"
"mat.Matrix" *-- "mat.Symmetric"
"mat.Banded" *-- "mat.TriBanded"
"mat.Matrix" *-- "mat.Triangular"
"mat.Matrix" *-- "mat.Vector"
"mat.Reseter" *-- "mat.allMatrix"
"mat.Normer" *-- "mat.denseMatrix"
"mat.Tracer" *-- "mat.denseMatrix"

"mat.Banded" <|-- "mat.BandCholesky"
"mat.Matrix" <|-- "mat.BandCholesky"
"mat.Reseter" <|-- "mat.BandCholesky"
"mat.SymBanded" <|-- "mat.BandCholesky"
"mat.Symmetric" <|-- "mat.BandCholesky"
"mat.Banded" <|-- "mat.BandDense"
"mat.ColNonZeroDoer" <|-- "mat.BandDense"
"mat.Matrix" <|-- "mat.BandDense"
"mat.MutableBanded" <|-- "mat.BandDense"
"mat.NonZeroDoer" <|-- "mat.BandDense"
"mat.Normer" <|-- "mat.BandDense"
"mat.RawBander" <|-- "mat.BandDense"
"mat.Reseter" <|-- "mat.BandDense"
"mat.RowNonZeroDoer" <|-- "mat.BandDense"
"mat.Tracer" <|-- "mat.BandDense"
"mat.allMatrix" <|-- "mat.BandDense"
"mat.denseMatrix" <|-- "mat.BandDense"
"mat.CMatrix" <|-- "mat.CDense"
"mat.RawCMatrixer" <|-- "mat.CDense"
"mat.Reseter" <|-- "mat.CDense"
"mat.allMatrix" <|-- "mat.CDense"
"mat.CMatrix" <|-- "mat.CTranspose"
"mat.CUntransposer" <|-- "mat.CTranspose"
"mat.Matrix" <|-- "mat.Cholesky"
"mat.Reseter" <|-- "mat.Cholesky"
"mat.Symmetric" <|-- "mat.Cholesky"
"mat.CMatrix" <|-- "mat.ConjTranspose"
"mat.UnConjTransposer" <|-- "mat.ConjTranspose"
"mat.ClonerFrom" <|-- "mat.Dense"
"mat.ColViewer" <|-- "mat.Dense"
"mat.Copier" <|-- "mat.Dense"
"mat.Grower" <|-- "mat.Dense"
"mat.Matrix" <|-- "mat.Dense"
"mat.Mutable" <|-- "mat.Dense"
"mat.Normer" <|-- "mat.Dense"
"mat.RawMatrixSetter" <|-- "mat.Dense"
"mat.RawMatrixer" <|-- "mat.Dense"
"mat.RawRowViewer" <|-- "mat.Dense"
"mat.Reseter" <|-- "mat.Dense"
"mat.RowViewer" <|-- "mat.Dense"
"mat.Tracer" <|-- "mat.Dense"
"mat.allMatrix" <|-- "mat.Dense"
"mat.denseMatrix" <|-- "mat.Dense"
"mat.Banded" <|-- "mat.DiagDense"
"mat.Diagonal" <|-- "mat.DiagDense"
"mat.Matrix" <|-- "mat.DiagDense"
"mat.MutableDiagonal" <|-- "mat.DiagDense"
"mat.Normer" <|-- "mat.DiagDense"
"mat.RawBander" <|-- "mat.DiagDense"
"mat.RawSymBander" <|-- "mat.DiagDense"
"mat.Reseter" <|-- "mat.DiagDense"
"mat.SymBanded" <|-- "mat.DiagDense"
"mat.Symmetric" <|-- "mat.DiagDense"
"mat.Tracer" <|-- "mat.DiagDense"
"mat.TriBanded" <|-- "mat.DiagDense"
"mat.Triangular" <|-- "mat.DiagDense"
"mat.allMatrix" <|-- "mat.DiagDense"
"mat.denseMatrix" <|-- "mat.DiagDense"
"mat.Reseter" <|-- "mat.LU"
"mat.Banded" <|-- "mat.SymBandDense"
"mat.ColNonZeroDoer" <|-- "mat.SymBandDense"
"mat.Matrix" <|-- "mat.SymBandDense"
"mat.MutableSymBanded" <|-- "mat.SymBandDense"
"mat.NonZeroDoer" <|-- "mat.SymBandDense"
"mat.Normer" <|-- "mat.SymBandDense"
"mat.RawSymBander" <|-- "mat.SymBandDense"
"mat.Reseter" <|-- "mat.SymBandDense"
"mat.RowNonZeroDoer" <|-- "mat.SymBandDense"
"mat.SymBanded" <|-- "mat.SymBandDense"
"mat.Symmetric" <|-- "mat.SymBandDense"
"mat.Tracer" <|-- "mat.SymBandDense"
"mat.allMatrix" <|-- "mat.SymBandDense"
"mat.denseMatrix" <|-- "mat.SymBandDense"
"mat.Matrix" <|-- "mat.SymDense"
"mat.MutableSymmetric" <|-- "mat.SymDense"
"mat.Normer" <|-- "mat.SymDense"
"mat.RawSymmetricer" <|-- "mat.SymDense"
"mat.Reseter" <|-- "mat.SymDense"
"mat.Symmetric" <|-- "mat.SymDense"
"mat.Tracer" <|-- "mat.SymDense"
"mat.allMatrix" <|-- "mat.SymDense"
"mat.denseMatrix" <|-- "mat.SymDense"
"mat.Matrix" <|-- "mat.Transpose"
"mat.Untransposer" <|-- "mat.Transpose"
"mat.Banded" <|-- "mat.TransposeBand"
"mat.Matrix" <|-- "mat.TransposeBand"
"mat.UntransposeBander" <|-- "mat.TransposeBand"
"mat.Untransposer" <|-- "mat.TransposeBand"
"mat.Matrix" <|-- "mat.TransposeTri"
"mat.Triangular" <|-- "mat.TransposeTri"
"mat.UntransposeTrier" <|-- "mat.TransposeTri"
"mat.Untransposer" <|-- "mat.TransposeTri"
"mat.Banded" <|-- "mat.TransposeTriBand"
"mat.Matrix" <|-- "mat.TransposeTriBand"
"mat.TriBanded" <|-- "mat.TransposeTriBand"
"mat.Triangular" <|-- "mat.TransposeTriBand"
"mat.UntransposeBander" <|-- "mat.TransposeTriBand"
"mat.UntransposeTriBander" <|-- "mat.TransposeTriBand"
"mat.UntransposeTrier" <|-- "mat.TransposeTriBand"
"mat.Untransposer" <|-- "mat.TransposeTriBand"
"mat.Matrix" <|-- "mat.TransposeVec"
"mat.Untransposer" <|-- "mat.TransposeVec"
"mat.Vector" <|-- "mat.TransposeVec"
"mat.Banded" <|-- "mat.TriBandDense"
"mat.ColNonZeroDoer" <|-- "mat.TriBandDense"
"mat.Matrix" <|-- "mat.TriBandDense"
"mat.MutableTriBanded" <|-- "mat.TriBandDense"
"mat.NonZeroDoer" <|-- "mat.TriBandDense"
"mat.Normer" <|-- "mat.TriBandDense"
"mat.RawTriBander" <|-- "mat.TriBandDense"
"mat.Reseter" <|-- "mat.TriBandDense"
"mat.RowNonZeroDoer" <|-- "mat.TriBandDense"
"mat.Tracer" <|-- "mat.TriBandDense"
"mat.TriBanded" <|-- "mat.TriBandDense"
"mat.Triangular" <|-- "mat.TriBandDense"
"mat.allMatrix" <|-- "mat.TriBandDense"
"mat.denseMatrix" <|-- "mat.TriBandDense"
"mat.ColNonZeroDoer" <|-- "mat.TriDense"
"mat.Copier" <|-- "mat.TriDense"
"mat.Matrix" <|-- "mat.TriDense"
"mat.MutableTriangular" <|-- "mat.TriDense"
"mat.NonZeroDoer" <|-- "mat.TriDense"
"mat.Normer" <|-- "mat.TriDense"
"mat.RawTriangular" <|-- "mat.TriDense"
"mat.Reseter" <|-- "mat.TriDense"
"mat.RowNonZeroDoer" <|-- "mat.TriDense"
"mat.Tracer" <|-- "mat.TriDense"
"mat.Triangular" <|-- "mat.TriDense"
"mat.allMatrix" <|-- "mat.TriDense"
"mat.denseMatrix" <|-- "mat.TriDense"
"mat.Banded" <|-- "mat.Tridiag"
"mat.ColNonZeroDoer" <|-- "mat.Tridiag"
"mat.Matrix" <|-- "mat.Tridiag"
"mat.MutableBanded" <|-- "mat.Tridiag"
"mat.NonZeroDoer" <|-- "mat.Tridiag"
"mat.Normer" <|-- "mat.Tridiag"
"mat.RawTridiagonaler" <|-- "mat.Tridiag"
"mat.Reseter" <|-- "mat.Tridiag"
"mat.RowNonZeroDoer" <|-- "mat.Tridiag"
"mat.Tracer" <|-- "mat.Tridiag"
"mat.allMatrix" <|-- "mat.Tridiag"
"mat.denseMatrix" <|-- "mat.Tridiag"
"mat.Matrix" <|-- "mat.VecDense"
"mat.MutableVector" <|-- "mat.VecDense"
"mat.Normer" <|-- "mat.VecDense"
"mat.RawVectorer" <|-- "mat.VecDense"
"mat.Reseter" <|-- "mat.VecDense"
"mat.Vector" <|-- "mat.VecDense"
"mat.allMatrix" <|-- "mat.VecDense"
"mat.widther" <|-- "mat.columnWidth"
"mat.Matrix" <|-- "mat.repVector"
"mat.widther" <|-- "mat.uniformWidth"

namespace mathext {
    class mathext.fSolveResult << (T, #FF7700) >>  {
    }
    class mathext.objectiveFunc << (T, #FF7700) >>  {
    }
}


namespace multi {
    class DirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - from <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Line
        - to <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Line
        - nodeIDs *uid.Set
        - lineIDs <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]*uid.Set

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + Lines(uid int64, vid int64) graph.Lines
        + NewLine(from graph.Node, to graph.Node) graph.Line
        + NewNode() graph.Node
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveLine(fid int64, tid int64, id int64) 
        + RemoveNode(id int64) 
        + SetLine(l graph.Line) 
        + To(id int64) graph.Nodes

    }
    class Edge << (S,Aquamarine) >> {
        + F graph.Node

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge

    }
    class Line << (S,Aquamarine) >> {
        + F graph.Node
        + UID int64

        + From() graph.Node
        + To() graph.Node
        + ReversedLine() graph.Line
        + ID() int64

    }
    class Node << (S,Aquamarine) >> {
        + ID() int64

    }
    class UndirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - lines <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Line
        - nodeIDs *uid.Set
        - lineIDs <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]*uid.Set

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + EdgeBetween(xid int64, yid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Lines(uid int64, vid int64) graph.Lines
        + LinesBetween(xid int64, yid int64) graph.Lines
        + NewLine(from graph.Node, to graph.Node) graph.Line
        + NewNode() graph.Node
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveLine(fid int64, tid int64, id int64) 
        + RemoveNode(id int64) 
        + SetLine(l graph.Line) 

    }
    class WeightedDirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - from <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.WeightedLine
        - to <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.WeightedLine
        - nodeIDs *uid.Set
        - lineIDs <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]*uid.Set

        + EdgeWeightFunc <font color=blue>func</font>(graph.WeightedLines) float64

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + Lines(uid int64, vid int64) graph.Lines
        + NewNode() graph.Node
        + NewWeightedLine(from graph.Node, to graph.Node, weight float64) graph.WeightedLine
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveLine(fid int64, tid int64, id int64) 
        + RemoveNode(id int64) 
        + SetWeightedLine(l graph.WeightedLine) 
        + To(id int64) graph.Nodes
        + Weight(uid int64, vid int64) (float64, bool)
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + WeightedEdges() graph.WeightedEdges
        + WeightedLines(uid int64, vid int64) graph.WeightedLines

    }
    class WeightedEdge << (S,Aquamarine) >> {
        + F graph.Node
        + WeightFunc <font color=blue>func</font>(graph.WeightedLines) float64

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge
        + Weight() float64

    }
    class WeightedLine << (S,Aquamarine) >> {
        + F graph.Node
        + W float64
        + UID int64

        + From() graph.Node
        + To() graph.Node
        + ReversedLine() graph.Line
        + ID() int64
        + Weight() float64

    }
    class WeightedUndirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - lines <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.WeightedLine
        - nodeIDs *uid.Set
        - lineIDs <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]*uid.Set

        + EdgeWeightFunc <font color=blue>func</font>(graph.WeightedLines) float64

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + EdgeBetween(xid int64, yid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + Lines(uid int64, vid int64) graph.Lines
        + LinesBetween(xid int64, yid int64) graph.Lines
        + NewNode() graph.Node
        + NewWeightedLine(from graph.Node, to graph.Node, weight float64) graph.WeightedLine
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveLine(fid int64, tid int64, id int64) 
        + RemoveNode(id int64) 
        + SetWeightedLine(l graph.WeightedLine) 
        + Weight(xid int64, yid int64) (float64, bool)
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + WeightedEdgeBetween(xid int64, yid int64) graph.WeightedEdge
        + WeightedEdges() graph.WeightedEdges
        + WeightedLines(uid int64, vid int64) graph.WeightedLines
        + WeightedLinesBetween(xid int64, yid int64) graph.WeightedLines

    }
    class multi.Node << (T, #FF7700) >>  {
    }
}
"graph.Lines" *-- "multi.Edge"
"graph.WeightedLines" *-- "multi.WeightedEdge"

"gen.GraphBuilder" <|-- "multi.DirectedGraph"
"graph.Directed" <|-- "multi.DirectedGraph"
"graph.DirectedMultigraph" <|-- "multi.DirectedGraph"
"graph.Graph" <|-- "multi.DirectedGraph"
"graph.LineAdder" <|-- "multi.DirectedGraph"
"graph.LineRemover" <|-- "multi.DirectedGraph"
"graph.Multigraph" <|-- "multi.DirectedGraph"
"graph.NodeAdder" <|-- "multi.DirectedGraph"
"graph.NodeRemover" <|-- "multi.DirectedGraph"
"graph.NodeWithIDer" <|-- "multi.DirectedGraph"
"graph.WeightedDirected" <|-- "multi.DirectedGraph"
"graph.WeightedDirectedMultigraph" <|-- "multi.DirectedGraph"
"testgraph.edgeLister" <|-- "multi.DirectedGraph"
"traverse.Graph" <|-- "multi.DirectedGraph"
"dot.basicEdge" <|-- "multi.Edge"
"graph.Edge" <|-- "multi.Edge"
"testgraph.Edge" <|-- "multi.Edge"
"dot.basicEdge" <|-- "multi.Line"
"graph.Line" <|-- "multi.Line"
"graph.Node" <|-- "multi.Line"
"testgraph.Edge" <|-- "multi.Line"
"graph.Node" <|-- "multi.Node"
"gen.GraphBuilder" <|-- "multi.UndirectedGraph"
"graph.Graph" <|-- "multi.UndirectedGraph"
"graph.LineAdder" <|-- "multi.UndirectedGraph"
"graph.LineRemover" <|-- "multi.UndirectedGraph"
"graph.Multigraph" <|-- "multi.UndirectedGraph"
"graph.NodeAdder" <|-- "multi.UndirectedGraph"
"graph.NodeRemover" <|-- "multi.UndirectedGraph"
"graph.NodeWithIDer" <|-- "multi.UndirectedGraph"
"graph.Undirected" <|-- "multi.UndirectedGraph"
"graph.UndirectedMultigraph" <|-- "multi.UndirectedGraph"
"testgraph.edgeLister" <|-- "multi.UndirectedGraph"
"traverse.Graph" <|-- "multi.UndirectedGraph"
"gen.GraphBuilder" <|-- "multi.WeightedDirectedGraph"
"graph.Directed" <|-- "multi.WeightedDirectedGraph"
"graph.DirectedMultigraph" <|-- "multi.WeightedDirectedGraph"
"graph.Graph" <|-- "multi.WeightedDirectedGraph"
"graph.LineRemover" <|-- "multi.WeightedDirectedGraph"
"graph.Multigraph" <|-- "multi.WeightedDirectedGraph"
"graph.NodeAdder" <|-- "multi.WeightedDirectedGraph"
"graph.NodeRemover" <|-- "multi.WeightedDirectedGraph"
"graph.NodeWithIDer" <|-- "multi.WeightedDirectedGraph"
"graph.Weighted" <|-- "multi.WeightedDirectedGraph"
"graph.WeightedDirected" <|-- "multi.WeightedDirectedGraph"
"graph.WeightedDirectedMultigraph" <|-- "multi.WeightedDirectedGraph"
"graph.WeightedLineAdder" <|-- "multi.WeightedDirectedGraph"
"graph.WeightedMultigraph" <|-- "multi.WeightedDirectedGraph"
"path.UndirectedWeightLister" <|-- "multi.WeightedDirectedGraph"
"path.Weighted" <|-- "multi.WeightedDirectedGraph"
"testgraph.edgeLister" <|-- "multi.WeightedDirectedGraph"
"testgraph.weightedEdgeLister" <|-- "multi.WeightedDirectedGraph"
"traverse.Graph" <|-- "multi.WeightedDirectedGraph"
"dot.basicEdge" <|-- "multi.WeightedEdge"
"graph.Edge" <|-- "multi.WeightedEdge"
"graph.WeightedEdge" <|-- "multi.WeightedEdge"
"graph.WeightedLine" <|-- "multi.WeightedEdge"
"testgraph.Edge" <|-- "multi.WeightedEdge"
"dot.basicEdge" <|-- "multi.WeightedLine"
"graph.Line" <|-- "multi.WeightedLine"
"graph.Node" <|-- "multi.WeightedLine"
"graph.WeightedEdge" <|-- "multi.WeightedLine"
"graph.WeightedLine" <|-- "multi.WeightedLine"
"testgraph.Edge" <|-- "multi.WeightedLine"
"testgraph.WeightedLine" <|-- "multi.WeightedLine"
"gen.GraphBuilder" <|-- "multi.WeightedUndirectedGraph"
"graph.Graph" <|-- "multi.WeightedUndirectedGraph"
"graph.LineRemover" <|-- "multi.WeightedUndirectedGraph"
"graph.Multigraph" <|-- "multi.WeightedUndirectedGraph"
"graph.NodeAdder" <|-- "multi.WeightedUndirectedGraph"
"graph.NodeRemover" <|-- "multi.WeightedUndirectedGraph"
"graph.NodeWithIDer" <|-- "multi.WeightedUndirectedGraph"
"graph.Undirected" <|-- "multi.WeightedUndirectedGraph"
"graph.UndirectedMultigraph" <|-- "multi.WeightedUndirectedGraph"
"graph.Weighted" <|-- "multi.WeightedUndirectedGraph"
"graph.WeightedLineAdder" <|-- "multi.WeightedUndirectedGraph"
"graph.WeightedMultigraph" <|-- "multi.WeightedUndirectedGraph"
"graph.WeightedUndirected" <|-- "multi.WeightedUndirectedGraph"
"graph.WeightedUndirectedMultigraph" <|-- "multi.WeightedUndirectedGraph"
"path.UndirectedWeightLister" <|-- "multi.WeightedUndirectedGraph"
"path.Weighted" <|-- "multi.WeightedUndirectedGraph"
"testgraph.edgeLister" <|-- "multi.WeightedUndirectedGraph"
"testgraph.weightedEdgeLister" <|-- "multi.WeightedUndirectedGraph"
"traverse.Graph" <|-- "multi.WeightedUndirectedGraph"

namespace network {
    class HubAuthority << (S,Aquamarine) >> {
        + Hub float64
        + Authority float64

    }
    class compressedRow << (S,Aquamarine) >> {
        - addTo(j int, v float64) 
        - dotUnitary(v *mat.VecDense) float64

    }
    class network.compressedRow << (T, #FF7700) >>  {
    }
    class network.rowCompressedMatrix << (T, #FF7700) >>  {
    }
    class rowCompressedMatrix << (S,Aquamarine) >> {
        - addTo(i int, j int, v float64) 
        - mulVecUnitary(dst *mat.VecDense, src *mat.VecDense) 

    }
    class sparseElement << (S,Aquamarine) >> {
        - index int
        - value float64

    }
}


namespace optimize {
    class Available << (S,Aquamarine) >> {
        + Grad bool
        + Hess bool

        - function() (Available, error)
        - gradient() (Available, error)
        - hessian() (Available, error)

    }
    class BFGS << (S,Aquamarine) >> {
        - ls *LinesearchMethod
        - status Status
        - err error
        - dim int
        - x mat.VecDense
        - grad mat.VecDense
        - s mat.VecDense
        - y mat.VecDense
        - tmp mat.VecDense
        - invHess *mat.SymDense
        - first bool

        + Linesearcher Linesearcher
        + GradStopThreshold float64

        - initLocal(loc *Location) (Operation, error)
        - iterateLocal(loc *Location) (Operation, error)
        - needs() <font color=blue>struct</font>{bool, bool}

        + Status() (Status, error)
        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 
        + InitDirection(loc *Location, dir []float64) float64
        + NextDirection(loc *Location, dir []float64) float64

    }
    class Backtracking << (S,Aquamarine) >> {
        - stepSize float64
        - initF float64
        - initG float64
        - lastOp Operation

        + DecreaseFactor float64
        + ContractionFactor float64

        + Init(f float64, g float64, step float64) Operation
        + Iterate(f float64, _ float64) (Operation, float64, error)

    }
    class Bisection << (S,Aquamarine) >> {
        - minStep float64
        - maxStep float64
        - currStep float64
        - initF float64
        - minF float64
        - maxF float64
        - lastF float64
        - initGrad float64
        - lastOp Operation

        + CurvatureFactor float64

        - nextStep(step float64) (Operation, float64, error)

        + Init(f float64, g float64, step float64) Operation
        + Iterate(f float64, g float64) (Operation, float64, error)

    }
    class CG << (S,Aquamarine) >> {
        - ls *LinesearchMethod
        - status Status
        - err error
        - restartAfter int
        - iterFromRestart int
        - dirPrev []float64
        - gradPrev []float64
        - gradPrevNorm float64

        + Linesearcher Linesearcher
        + Variant CGVariant
        + InitialStep StepSizer
        + IterationRestartFactor float64
        + AngleRestartThreshold float64
        + GradStopThreshold float64

        - initLocal(loc *Location) (Operation, error)
        - iterateLocal(loc *Location) (Operation, error)
        - needs() <font color=blue>struct</font>{bool, bool}

        + Status() (Status, error)
        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 
        + InitDirection(loc *Location, dir []float64) float64
        + NextDirection(loc *Location, dir []float64) float64

    }
    interface CGVariant  {
        + Init(loc *Location) 
        + Beta(grad []float64, gradPrev []float64, dirPrev []float64) float64

    }
    class CmaEsChol << (S,Aquamarine) >> {
        - dim int
        - pop int
        - weights []float64
        - muEff float64
        - cc float64
        - eChi float64
        - xs *mat.Dense
        - fs []float64
        - invSigma float64
        - pc []float64
        - mean []float64
        - chol mat.Cholesky
        - bestX []float64
        - bestF float64
        - sentIdx int
        - receivedIdx int
        - operation <font color=blue>chan</font> Task
        - updateErr error

        + InitStepSize float64
        + Population int
        + InitCholesky *mat.Cholesky
        + StopLogDet float64
        + ForgetBest bool
        + Src rand.Source

        - methodConverged() Status
        - sendInitTasks(tasks []Task) 
        - sendTask(idx int, task Task) 
        - bestIdx() int
        - findBestAndUpdateTask(task Task) Task
        - update() error

        + Status() (Status, error)
        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operations <font color=blue>chan</font> Task, results <font color=blue>chan</font> Task, tasks []Task) 

    }
    class ConstantStepSize << (S,Aquamarine) >> {
        + Size float64

        + Init(_ *Location, _ []float64) float64
        + StepSize(_ *Location, _ []float64) float64

    }
    interface Converger  {
        + Init(dim int) 
        + Converged(loc *Location) Status

    }
    class DaiYuan << (S,Aquamarine) >> {
        - y []float64

        + Init(loc *Location) 
        + Beta(grad []float64, gradPrev []float64, dirPrev []float64) float64

    }
    class ErrFunc << (S,Aquamarine) >> {
        + Error() string

    }
    class ErrGrad << (S,Aquamarine) >> {
        + Grad float64
        + Index int

        + Error() string

    }
    class FirstOrderStepSize << (S,Aquamarine) >> {
        - dirPrevNorm float64
        - projGradPrev float64
        - xPrev []float64

        + InitialStepFactor float64
        + MinStepSize float64
        + MaxStepSize float64

        + Init(loc *Location, dir []float64) float64
        + StepSize(loc *Location, dir []float64) float64

    }
    class FletcherReeves << (S,Aquamarine) >> {
        - prevNorm float64

        + Init(loc *Location) 
        + Beta(grad []float64, _ []float64, _ []float64) float64

    }
    class FunctionConverge << (S,Aquamarine) >> {
        - first bool
        - best float64
        - iter int

        + Absolute float64
        + Relative float64
        + Iterations int

        + Init(dim int) 
        + Converged(l *Location) Status

    }
    class GradientDescent << (S,Aquamarine) >> {
        - ls *LinesearchMethod
        - status Status
        - err error

        + Linesearcher Linesearcher
        + StepSizer StepSizer
        + GradStopThreshold float64

        - initLocal(loc *Location) (Operation, error)
        - iterateLocal(loc *Location) (Operation, error)
        - needs() <font color=blue>struct</font>{bool, bool}

        + Status() (Status, error)
        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 
        + InitDirection(loc *Location, dir []float64) float64
        + NextDirection(loc *Location, dir []float64) float64

    }
    class GuessAndCheck << (S,Aquamarine) >> {
        - bestF float64
        - bestX []float64

        + Rander distmv.Rander

        - sendNewLoc(operation <font color=blue>chan</font> Task, task Task) 
        - updateMajor(operation <font color=blue>chan</font> Task, task Task) 

        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 

    }
    class HagerZhang << (S,Aquamarine) >> {
        - y []float64

        + Init(loc *Location) 
        + Beta(grad []float64, gradPrev []float64, dirPrev []float64) float64

    }
    class HestenesStiefel << (S,Aquamarine) >> {
        - y []float64

        + Init(loc *Location) 
        + Beta(grad []float64, gradPrev []float64, dirPrev []float64) float64

    }
    class LBFGS << (S,Aquamarine) >> {
        - status Status
        - err error
        - ls *LinesearchMethod
        - dim int
        - x []float64
        - grad []float64
        - oldest int
        - y [][]float64
        - s [][]float64
        - rho []float64
        - a []float64

        + Linesearcher Linesearcher
        + Store int
        + GradStopThreshold float64

        - initLocal(loc *Location) (Operation, error)
        - iterateLocal(loc *Location) (Operation, error)
        - initHistory(hist [][]float64) [][]float64
        - needs() <font color=blue>struct</font>{bool, bool}

        + Status() (Status, error)
        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 
        + InitDirection(loc *Location, dir []float64) float64
        + NextDirection(loc *Location, dir []float64) float64

    }
    class LinesearchMethod << (S,Aquamarine) >> {
        - x []float64
        - dir []float64
        - first bool
        - nextMajor bool
        - eval Operation
        - lastStep float64
        - lastOp Operation

        + NextDirectioner NextDirectioner
        + Linesearcher Linesearcher

        - error(err error) (Operation, error)
        - initNextLinesearch(loc *Location) (Operation, error)

        + Init(loc *Location) (Operation, error)
        + Iterate(loc *Location) (Operation, error)

    }
    interface Linesearcher  {
        + Init(value float64, derivative float64, step float64) Operation
        + Iterate(value float64, derivative float64) (Operation, float64, error)

    }
    class ListSearch << (S,Aquamarine) >> {
        - eval int
        - rows int
        - bestF float64
        - bestIdx int

        + Locs mat.Matrix

        - sendNewLoc(operation <font color=blue>chan</font> Task, task Task) 
        - updateMajor(operation <font color=blue>chan</font> Task, task Task) 

        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Status() (Status, error)
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 

    }
    class Location << (S,Aquamarine) >> {
        + X []float64
        + F float64
        + Gradient []float64
        + Hessian *mat.SymDense

    }
    interface Method  {
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 
        + Uses(has Available) (Available, error)

    }
    class MoreThuente << (S,Aquamarine) >> {
        - bracketed bool
        - fInit float64
        - gInit float64
        - stage int
        - step float64
        - lower float64
        - x float64
        - fx float64
        - y float64
        - fy float64
        - width []float64

        + DecreaseFactor float64
        + CurvatureFactor float64
        + StepTolerance float64
        + MinimumStep float64
        + MaximumStep float64

        - nextStep(fx float64, gx float64, fy float64, gy float64, f float64, g float64) 

        + Init(f float64, g float64, step float64) Operation
        + Iterate(f float64, g float64) (Operation, float64, error)

    }
    class NelderMead << (S,Aquamarine) >> {
        - status Status
        - err error
        - reflection float64
        - expansion float64
        - contraction float64
        - shrink float64
        - vertices [][]float64
        - values []float64
        - centroid []float64
        - fillIdx int
        - lastIter nmIterType
        - reflectedPoint []float64
        - reflectedValue float64

        + InitialVertices [][]float64
        + InitialValues []float64
        + Reflection float64
        + Expansion float64
        + Contraction float64
        + Shrink float64
        + SimplexSize float64

        - initLocal(loc *Location) (Operation, error)
        - iterateLocal(loc *Location) (Operation, error)
        - returnNext(iter nmIterType, loc *Location) (Operation, error)
        - replaceWorst(x []float64, f float64) 
        - needs() <font color=blue>struct</font>{bool, bool}

        + Status() (Status, error)
        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 

    }
    class NeverTerminate << (S,Aquamarine) >> {
        + Init(dim int) 
        + Converged(loc *Location) Status

    }
    class Newton << (S,Aquamarine) >> {
        - status Status
        - err error
        - ls *LinesearchMethod
        - hess *mat.SymDense
        - chol mat.Cholesky
        - tau float64

        + Linesearcher Linesearcher
        + Increase float64
        + GradStopThreshold float64

        - initLocal(loc *Location) (Operation, error)
        - iterateLocal(loc *Location) (Operation, error)
        - needs() <font color=blue>struct</font>{bool, bool}

        + Status() (Status, error)
        + Uses(has Available) (Available, error)
        + Init(dim int, tasks int) int
        + Run(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) 
        + InitDirection(loc *Location, dir []float64) float64
        + NextDirection(loc *Location, dir []float64) float64

    }
    interface NextDirectioner  {
        + InitDirection(loc *Location, dir []float64) float64
        + NextDirection(loc *Location, dir []float64) float64

    }
    class Operation << (S,Aquamarine) >> {
        - isEvaluation() bool

        + String() string

    }
    class PolakRibierePolyak << (S,Aquamarine) >> {
        - prevNorm float64

        + Init(loc *Location) 
        + Beta(grad []float64, gradPrev []float64, _ []float64) float64

    }
    class Printer << (S,Aquamarine) >> {
        - lastHeading int
        - lastValue time.Time

        + Writer io.Writer
        + HeadingInterval int
        + ValueInterval time.Duration

        + Init() error
        + Record(loc *Location, op Operation, stats *Stats) error

    }
    class Problem << (S,Aquamarine) >> {
        + Func <font color=blue>func</font>([]float64) float64
        + Grad <font color=blue>func</font>([]float64, []float64) 
        + Hess <font color=blue>func</font>(*mat.SymDense, []float64) 
        + Status <font color=blue>func</font>() (Status, error)

    }
    class QuadraticStepSize << (S,Aquamarine) >> {
        - fPrev float64
        - dirPrevNorm float64
        - projGradPrev float64
        - xPrev []float64

        + Threshold float64
        + InitialStepFactor float64
        + MinStepSize float64
        + MaxStepSize float64

        + Init(loc *Location, dir []float64) float64
        + StepSize(loc *Location, dir []float64) float64

    }
    interface Recorder  {
        + Init() error
        + Record( *Location,  Operation,  *Stats) error

    }
    class Result << (S,Aquamarine) >> {
        + Status Status

    }
    class Settings << (S,Aquamarine) >> {
        + InitValues *Location
        + GradientThreshold float64
        + Converger Converger
        + MajorIterations int
        + Runtime time.Duration
        + FuncEvaluations int
        + GradEvaluations int
        + HessEvaluations int
        + Recorder Recorder
        + Concurrent int

    }
    class Stats << (S,Aquamarine) >> {
        + MajorIterations int
        + FuncEvaluations int
        + GradEvaluations int
        + HessEvaluations int
        + Runtime time.Duration

    }
    class Status << (S,Aquamarine) >> {
        + String() string
        + Early() bool
        + Err() error

    }
    interface Statuser  {
        + Status() (Status, error)

    }
    interface StepSizer  {
        + Init(loc *Location, dir []float64) float64
        + StepSize(loc *Location, dir []float64) float64

    }
    class Task << (S,Aquamarine) >> {
        + ID int
        + Op Operation

    }
    class bestSorter << (S,Aquamarine) >> {
        + F []float64
        + Idx []int

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    interface localMethod  {
        - initLocal(loc *Location) (Operation, error)
        - iterateLocal(loc *Location) (Operation, error)

    }
    class localOptimizer << (S,Aquamarine) >> {
        - run(method localMethod, gradThresh float64, operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, tasks []Task) (Status, error)
        - initialOperation(task Task, n needser) Operation
        - initialLocation(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, task Task, needs needser) Task
        - checkStartingLocation(task Task, gradThresh float64) (Status, error)
        - checkGradientConvergence(gradient []float64, gradThresh float64) Status
        - finish(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task) 
        - finishMethodDone(operation <font color=blue>chan</font> Task, result <font color=blue>chan</font> Task, task Task) 

    }
    interface needser  {
        - needs() <font color=blue>struct</font>{bool, bool}

    }
    class nmVertexSorter << (S,Aquamarine) >> {
        - vertices [][]float64
        - values []float64

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class optimize.ErrFunc << (T, #FF7700) >>  {
    }
    class optimize.Operation << (T, #FF7700) >>  {
    }
    class optimize.Status << (T, #FF7700) >>  {
    }
    class optimize.nmIterType << (T, #FF7700) >>  {
    }
}
"optimize.Location" *-- "optimize.Result"
"optimize.Stats" *-- "optimize.Result"
"optimize.Location" *-- "optimize.Task"
"optimize.needser" *-- "optimize.localMethod"

"optimize.Method" <|-- "optimize.BFGS"
"optimize.NextDirectioner" <|-- "optimize.BFGS"
"optimize.Statuser" <|-- "optimize.BFGS"
"optimize.localMethod" <|-- "optimize.BFGS"
"optimize.needser" <|-- "optimize.BFGS"
"optimize.Linesearcher" <|-- "optimize.Backtracking"
"optimize.Linesearcher" <|-- "optimize.Bisection"
"optimize.Method" <|-- "optimize.CG"
"optimize.NextDirectioner" <|-- "optimize.CG"
"optimize.Statuser" <|-- "optimize.CG"
"optimize.localMethod" <|-- "optimize.CG"
"optimize.needser" <|-- "optimize.CG"
"optimize.Method" <|-- "optimize.CmaEsChol"
"optimize.Statuser" <|-- "optimize.CmaEsChol"
"optimize.StepSizer" <|-- "optimize.ConstantStepSize"
"optimize.CGVariant" <|-- "optimize.DaiYuan"
"optimize.StepSizer" <|-- "optimize.FirstOrderStepSize"
"optimize.CGVariant" <|-- "optimize.FletcherReeves"
"optimize.Converger" <|-- "optimize.FunctionConverge"
"optimize.Method" <|-- "optimize.GradientDescent"
"optimize.NextDirectioner" <|-- "optimize.GradientDescent"
"optimize.Statuser" <|-- "optimize.GradientDescent"
"optimize.localMethod" <|-- "optimize.GradientDescent"
"optimize.needser" <|-- "optimize.GradientDescent"
"optimize.Method" <|-- "optimize.GuessAndCheck"
"optimize.CGVariant" <|-- "optimize.HagerZhang"
"optimize.CGVariant" <|-- "optimize.HestenesStiefel"
"optimize.Method" <|-- "optimize.LBFGS"
"optimize.NextDirectioner" <|-- "optimize.LBFGS"
"optimize.Statuser" <|-- "optimize.LBFGS"
"optimize.localMethod" <|-- "optimize.LBFGS"
"optimize.needser" <|-- "optimize.LBFGS"
"optimize.Method" <|-- "optimize.ListSearch"
"optimize.Statuser" <|-- "optimize.ListSearch"
"optimize.Linesearcher" <|-- "optimize.MoreThuente"
"optimize.Method" <|-- "optimize.NelderMead"
"optimize.Statuser" <|-- "optimize.NelderMead"
"optimize.localMethod" <|-- "optimize.NelderMead"
"optimize.needser" <|-- "optimize.NelderMead"
"optimize.Converger" <|-- "optimize.NeverTerminate"
"optimize.Method" <|-- "optimize.Newton"
"optimize.NextDirectioner" <|-- "optimize.Newton"
"optimize.Statuser" <|-- "optimize.Newton"
"optimize.localMethod" <|-- "optimize.Newton"
"optimize.needser" <|-- "optimize.Newton"
"optimize.CGVariant" <|-- "optimize.PolakRibierePolyak"
"optimize.Recorder" <|-- "optimize.Printer"
"optimize.StepSizer" <|-- "optimize.QuadraticStepSize"

namespace parser {
    interface Attrib  {
    }
    class Parser << (S,Aquamarine) >> {
        - stack *stack
        - nextToken *token.Token
        - pos int

        - popNonRecoveryStates() []errors.ErrorSymbol
        - firstRecoveryState() (int, bool)
        - newError(err error) error

        + Reset() 
        + Error(err error, scanner Scanner) (bool, *errors.Error)
        + Parse(scanner Scanner) (<font color=blue>interface</font>{}, error)

    }
    class ProdTabEntry << (S,Aquamarine) >> {
        + String string
        + Id string
        + NTType int
        + Index int
        + NumSymbols int
        + ReduceFunc <font color=blue>func</font>([]Attrib) (Attrib, error)

    }
    interface Scanner  {
        + Scan() *token.Token

    }
    class accept << (S,Aquamarine) >> {
        - act() 

        + Equal(that action) bool
        + String() string

    }
    interface action  {
        - act() 

        + String() string

    }
    class actionRow << (S,Aquamarine) >> {
        - canRecover bool
        - actions []action

    }
    class parser.ProdTab << (T, #FF7700) >>  {
    }
    class parser.accept << (T, #FF7700) >>  {
    }
    class parser.actionTable << (T, #FF7700) >>  {
    }
    class parser.gotoRow << (T, #FF7700) >>  {
    }
    class parser.gotoTable << (T, #FF7700) >>  {
    }
    class parser.reduce << (T, #FF7700) >>  {
    }
    class parser.shift << (T, #FF7700) >>  {
    }
    class reduce << (S,Aquamarine) >> {
        - act() 

        + Equal(that action) bool
        + String() string

    }
    class shift << (S,Aquamarine) >> {
        - act() 

        + Equal(that action) bool
        + String() string

    }
    class stack << (S,Aquamarine) >> {
        - state []int
        - attrib []Attrib

        - reset() 
        - push(state int, a Attrib) 
        - top() int
        - peek(pos int) int
        - topIndex() int
        - popN(items int) []Attrib

        + String() string

    }
}

"mat.Reseter" <|-- "parser.Parser"
"parser.action" <|-- "parser.accept"
"parser.action" <|-- "parser.reduce"
"parser.action" <|-- "parser.shift"

namespace path {
    class AllShortest << (S,Aquamarine) >> {
        - nodes []graph.Node
        - indexOf <font color=blue>map</font>[int64]int
        - dist *mat.Dense
        - next [][]int
        - forward bool

        - at(from int, to int) []int
        - set(from int, to int, weight float64, mid ...int) 
        - add(from int, to int, mid ...int) 
        - allBetween(from int, to int, seen []bool, path []graph.Node, paths [][]graph.Node) [][]graph.Node

        + Weight(uid int64, vid int64) float64
        + Between(uid int64, vid int64) ([]graph.Node, float64, bool)
        + AllBetween(uid int64, vid int64) ([][]graph.Node, float64)

    }
    interface HeuristicCoster  {
        + HeuristicCost(x graph.Node, y graph.Node) float64

    }
    class Shortest << (S,Aquamarine) >> {
        - from graph.Node
        - nodes []graph.Node
        - indexOf <font color=blue>map</font>[int64]int
        - dist []float64
        - next []int
        - hasNegativeCycle bool
        - negCosts <font color=blue>map</font>[negEdge]float64

        - add(u graph.Node) int
        - set(to int, weight float64, mid int) 

        + From() graph.Node
        + WeightTo(vid int64) float64
        + To(vid int64) ([]graph.Node, float64)

    }
    class ShortestAlts << (S,Aquamarine) >> {
        - from graph.Node
        - nodes []graph.Node
        - indexOf <font color=blue>map</font>[int64]int
        - dist []float64
        - next [][]int
        - hasNegativeCycle bool
        - negCosts <font color=blue>map</font>[negEdge]float64

        - add(u graph.Node) int
        - set(to int, weight float64, mid int) 
        - addPath(to int, mid int) 
        - allTo(from int, to int, seen []bool, path []graph.Node, paths [][]graph.Node) [][]graph.Node

        + From() graph.Node
        + WeightTo(vid int64) float64
        + To(vid int64) ([]graph.Node, float64, bool)
        + AllTo(vid int64) ([][]graph.Node, float64)

    }
    interface UndirectedWeightLister  {
        + WeightedEdges() graph.WeightedEdges

    }
    interface Weighted  {
        + Weight(xid int64, yid int64) (float64, bool)

    }
    interface WeightedBuilder  {
        + AddNode( graph.Node) 
        + SetWeightedEdge( graph.WeightedEdge) 

    }
    class aStarNode << (S,Aquamarine) >> {
        - node graph.Node
        - gscore float64
        - fscore float64

    }
    class aStarQueue << (S,Aquamarine) >> {
        - indexOf <font color=blue>map</font>[int64]int
        - nodes []aStarNode

        - update(id int64, g float64, f float64) 
        - node(id int64) (aStarNode, bool)

        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Len() int
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class bellmanFordQueue << (S,Aquamarine) >> {
        - queue linear.NodeQueue
        - onQueue []bool
        - indexOf <font color=blue>map</font>[int64]int

        - enqueue(n graph.Node) 
        - dequeue() graph.Node
        - len() int
        - has(id int64) bool

    }
    class byPathWeight << (S,Aquamarine) >> {
        + Len() int
        + Swap(i int, j int) 
        + Less(i int, j int) bool

    }
    class byWeight << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class distanceNode << (S,Aquamarine) >> {
        - node graph.Node
        - dist float64

    }
    class djSet << (S,Aquamarine) >> {
        - add(e int64) 
        - union(a *dsNode, b *dsNode) 
        - find(e int64) *dsNode

    }
    class dsNode << (S,Aquamarine) >> {
        - parent *dsNode
        - rank int

    }
    class johnsonGraphNode << (S,Aquamarine) >> {
        + ID() int64

    }
    class johnsonNodeIterator << (S,Aquamarine) >> {
        - q int64
        - nodes graph.Nodes
        - qUsed bool

        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 

    }
    class johnsonReWeight << (S,Aquamarine) >> {
        - q int64

        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + From(id int64) graph.Nodes
        + Edge(uid int64, vid int64) graph.Edge
        + Weight(xid int64, yid int64) (float64, bool)

    }
    class johnsonWeightAdjuster << (S,Aquamarine) >> {
        - weight Weighting
        - adjustBy Shortest

        + Node(id int64) graph.Node
        + WeightedEdge(_ int64, _ int64) graph.WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)
        + HasEdgeBetween(_ int64, _ int64) bool

    }
    class negEdge << (S,Aquamarine) >> {
        - from int

    }
    class node << (S,Aquamarine) >> {
        + ID() int64

    }
    class path.Heuristic << (T, #FF7700) >>  {
    }
    class path.Weighting << (T, #FF7700) >>  {
    }
    class path.byPathWeight << (T, #FF7700) >>  {
    }
    class path.byWeight << (T, #FF7700) >>  {
    }
    class path.djSet << (T, #FF7700) >>  {
    }
    class path.johnsonGraphNode << (T, #FF7700) >>  {
    }
    class path.node << (T, #FF7700) >>  {
    }
    class path.priorityQueue << (T, #FF7700) >>  {
    }
    class primQueue << (S,Aquamarine) >> {
        - indexOf <font color=blue>map</font>[int64]int
        - nodes []simple.WeightedEdge

        - key(u graph.Node) (float64, bool)
        - update(u graph.Node, v graph.Node, key float64) 

        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Len() int
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class priorityQueue << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(n <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    class yenKSPAdjuster << (S,Aquamarine) >> {
        - isDirected bool
        - weight Weighting
        - visitedEdges <font color=blue>map</font>[[]int64]<font color=blue>struct</font>{}

        - canWalk(u int64, v int64) bool
        - removeEdge(u int64, v int64) 
        - reset() 

        + From(id int64) graph.Nodes
        + Weight(xid int64, yid int64) (float64, bool)

    }
    class yenShortest << (S,Aquamarine) >> {
        - path []graph.Node
        - weight float64

    }
    class "<font color=blue>func</font>(graph.Node, graph.Node) float64" as fontcolorbluefuncfontgraphNodegraphNodefloat64 {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[]graph.WeightedEdge" as graphWeightedEdge {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"path.johnsonWeightAdjuster" *-- "path.johnsonReWeight"
"graph.Graph" *-- "path.johnsonWeightAdjuster"
"graph.Graph" *-- "path.yenKSPAdjuster"

"graph.Node" <|-- "path.johnsonGraphNode"
"graph.Iterator" <|-- "path.johnsonNodeIterator"
"graph.Nodes" <|-- "path.johnsonNodeIterator"
"mat.Reseter" <|-- "path.johnsonNodeIterator"
"path.Weighted" <|-- "path.johnsonReWeight"
"traverse.Graph" <|-- "path.johnsonReWeight"
"gen.GraphBuilder" <|-- "path.johnsonWeightAdjuster"
"graph.Weighted" <|-- "path.johnsonWeightAdjuster"
"path.Weighted" <|-- "path.johnsonWeightAdjuster"
"graph.Node" <|-- "path.node"
"path.Weighted" <|-- "path.yenKSPAdjuster"

namespace prng {
    class MT19937 << (S,Aquamarine) >> {
        - mt []uint32
        - mti uint32

        + Seed(seed uint64) 
        + SeedFromKeys(keys []uint32) 
        + Uint32() uint32
        + Uint64() uint64
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
    class MT19937_64 << (S,Aquamarine) >> {
        - mt []uint64
        - mti uint64

        + Seed(seed uint64) 
        + SeedFromKeys(keys []uint64) 
        + Uint64() uint64
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
    class SplitMix64 << (S,Aquamarine) >> {
        - state uint64

        + Seed(seed uint64) 
        + Uint64() uint64
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
    class Xoshiro256plus << (S,Aquamarine) >> {
        - state []uint64

        + Seed(seed uint64) 
        + Uint64() uint64
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
    class Xoshiro256plusplus << (S,Aquamarine) >> {
        - state []uint64

        + Seed(seed uint64) 
        + Uint64() uint64
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
    class Xoshiro256starstar << (S,Aquamarine) >> {
        - state []uint64

        + Seed(seed uint64) 
        + Uint64() uint64
        + MarshalBinary() ([]byte, error)
        + UnmarshalBinary(data []byte) error

    }
}


namespace product {
    class Node << (S,Aquamarine) >> {
        + UID int64
        + A graph.Node

        + ID() int64

    }
}

"graph.Node" <|-- "product.Node"

namespace quad {
    interface FixedLocationSingler  {
        + FixedLocationSingle(n int, k int, min float64, max float64) (float64, float64)

    }
    interface FixedLocationer  {
        + FixedLocations(x []float64, weight []float64, min float64, max float64) 

    }
    class Hermite << (S,Aquamarine) >> {
        - locations(x []float64, weights []float64) 
        - locationsAsy(x []float64, w []float64) 
        - locationsAsy0(i int, n int) (float64, float64)
        - hermpolyAsyAiry(i int, n int, t float64) (float64, float64)
        - hermiteInitialGuess(i int, n int) float64

        + FixedLocations(x []float64, weight []float64, min float64, max float64) 

    }
    class Legendre << (S,Aquamarine) >> {
        - boundedLocation(n int, k int, min float64, max float64) (float64, float64)
        - location(n int, k int) (float64, float64)
        - tabulated(n int, k int) (float64, float64)
        - computed(n int, k int) (float64, float64)

        + FixedLocations(x []float64, weight []float64, min float64, max float64) 
        + FixedLocationSingle(n int, k int, min float64, max float64) (float64, float64)

    }
}

"quad.FixedLocationer" <|-- "quad.Hermite"
"quad.FixedLocationSingler" <|-- "quad.Legendre"
"quad.FixedLocationer" <|-- "quad.Legendre"

namespace quat {
    class Number << (S,Aquamarine) >> {
        + Real float64

        + Format(fs fmt.State, c rune) 

    }
    class parseError << (S,Aquamarine) >> {
        - string string
        - state int
        - rune rune

        + Error() string

    }
}


namespace r1 {
    class Interval << (S,Aquamarine) >> {
        + Min float64

    }
}


namespace r2 {
    class Box << (S,Aquamarine) >> {
        + Min Vec

        + Size() Vec
        + Center() Vec
        + Empty() bool
        + Vertices() []Vec
        + Union(b Box) Box
        + Add(v Vec) Box
        + Scale(v Vec) Box
        + Contains(v Vec) bool
        + Canon() Box

    }
    class Rotation << (S,Aquamarine) >> {
        - sin float64
        - p Vec

        - isIdentity() bool

        + Rotate(p Vec) Vec

    }
    class Triangle << (S,Aquamarine) >> {
        - orderedLengths() (float64, float64, float64)
        - sides() (Vec, Vec, Vec)

        + Centroid() Vec
        + Area() float64
        + IsDegenerate(tol float64) bool

    }
    class Vec << (S,Aquamarine) >> {
        + X float64

    }
    class line << (S,Aquamarine) >> {
        - vecOnLine(t float64) Vec
        - distance(p Vec) float64

    }
    class r2.Triangle << (T, #FF7700) >>  {
    }
    class r2.line << (T, #FF7700) >>  {
    }
}


namespace r3 {
    class Box << (S,Aquamarine) >> {
        + Min Vec

        + Empty() bool
        + Size() Vec
        + Center() Vec
        + Vertices() []Vec
        + Union(b Box) Box
        + Add(v Vec) Box
        + Scale(scale Vec) Box
        + Contains(v Vec) bool
        + Canon() Box

    }
    class Mat << (S,Aquamarine) >> {
        - data *array

        - slice() []float64

        + Dims() (int, int)
        + T() mat.Matrix
        + Scale(f float64, a mat.Matrix) 
        + MulVec(v Vec) Vec
        + MulVecTrans(v Vec) Vec
        + CloneFrom(a mat.Matrix) 
        + Sub(a mat.Matrix, b mat.Matrix) 
        + Add(a mat.Matrix, b mat.Matrix) 
        + VecRow(i int) Vec
        + VecCol(j int) Vec
        + Outer(alpha float64, x Vec, y Vec) 
        + Det() float64
        + Skew(v Vec) 
        + Hessian(p Vec, step Vec, field <font color=blue>func</font>(Vec) float64) 
        + At(i int, j int) float64
        + Set(i int, j int, v float64) 
        + Mul(a mat.Matrix, b mat.Matrix) 
        + RawMatrix() blas64.General
        + At(i int, j int) float64
        + Set(i int, j int, v float64) 
        + Mul(a mat.Matrix, b mat.Matrix) 
        + RawMatrix() blas64.General

    }
    class Rotation << (S,Aquamarine) >> {
        - isIdentity() bool

        + Mat() *Mat
        + Mat() *Mat
        + Rotate(p Vec) Vec

    }
    class Triangle << (S,Aquamarine) >> {
        - longIdx() int
        - orderedLengths() (float64, float64, float64)
        - sides() (Vec, Vec, Vec)

        + Centroid() Vec
        + Normal() Vec
        + IsDegenerate(tol float64) bool
        + Area() float64

    }
    class Vec << (S,Aquamarine) >> {
        + X float64

    }
    class line << (S,Aquamarine) >> {
        - vecOnLine(t float64) Vec
        - distance(p Vec) float64

    }
    class r3.Rotation << (T, #FF7700) >>  {
    }
    class r3.Triangle << (T, #FF7700) >>  {
    }
    class r3.array << (T, #FF7700) >>  {
    }
    class r3.line << (T, #FF7700) >>  {
    }
    class "quat.Number" as quatNumber {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}

"mat.ClonerFrom" <|-- "r3.Mat"
"mat.Matrix" <|-- "r3.Mat"
"mat.Mutable" <|-- "r3.Mat"
"mat.RawMatrixer" <|-- "r3.Mat"

namespace rdf {
    class Decoder << (S,Aquamarine) >> {
        - scanner *bufio.Scanner
        - strings store
        - ids <font color=blue>map</font>[string]int64

        - idFor(s string) int64

        + Reset(r io.Reader) 
        + Unmarshal() (*Statement, error)
        + Terms() <font color=blue>map</font>[string]int64

    }
    class Graph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - from <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Line
        - to <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Line
        - pred <font color=blue>map</font>[int64]<font color=blue>map</font>[*Statement]bool
        - termIDs <font color=blue>map</font>[string]int64
        - ids *uid.Set

        - addNode(n graph.Node) 
        - addTerm(t *Term) 
        - newLine(from graph.Node, to graph.Node) graph.Line
        - newNode() graph.Node
        - removeLine(fid int64, tid int64, id int64) 
        - removeNode(id int64) 
        - setLine(l graph.Line) 

        + AddStatement(s *Statement) 
        + AllStatements() *Statements
        + Edge(uid int64, vid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + FromSubject(t Term) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + Lines(uid int64, vid int64) graph.Lines
        + Node(id int64) graph.Node
        + TermFor(text string) (Term, bool)
        + Nodes() graph.Nodes
        + Predicates() []Term
        + RemoveStatement(s *Statement) 
        + RemoveTerm(t Term) 
        + Statements(uid int64, vid int64) *Statements
        + To(id int64) graph.Nodes
        + ToObject(t Term) graph.Nodes
        + Query(from ...Term) Query

    }
    class Kind << (S,Aquamarine) >> {
        + String() string

    }
    class Query << (S,Aquamarine) >> {
        - g graph.Directed
        - terms []Term

        + Out(fn <font color=blue>func</font>(*Statement) bool) Query
        + In(fn <font color=blue>func</font>(*Statement) bool) Query
        + HasAllOut(fn <font color=blue>func</font>(*Statement) bool) Query
        + HasAllIn(fn <font color=blue>func</font>(*Statement) bool) Query
        + HasAnyOut(fn <font color=blue>func</font>(*Statement) bool) Query
        + HasAnyIn(fn <font color=blue>func</font>(*Statement) bool) Query
        + And(p Query) Query
        + Or(p Query) Query
        + Not(p Query) Query
        + Repeat(fn <font color=blue>func</font>(Query) (Query, bool)) Query
        + Unique() Query
        + Len() int
        + Result() []Term

    }
    class Statement << (S,Aquamarine) >> {
        + Subject Term
        + Predicate Term
        + Object Term
        + Label Term

        + String() string
        + From() graph.Node
        + To() graph.Node
        + ID() int64
        + ReversedEdge() graph.Edge
        + ReversedLine() graph.Line

    }
    class Statements << (S,Aquamarine) >> {
        - eit graph.Edges
        - lit graph.Lines

        + Next() bool
        + Statement() *Statement

    }
    class Term << (S,Aquamarine) >> {
        + Value string
        + UID int64

        + Parts() (string, string, Kind, error)
        + ID() int64

    }
    class attrs << (S,Aquamarine) >> {
        - blanks <font color=blue>map</font>[string]bool
        - selfs int

    }
    class byLengthHash << (S,Aquamarine) >> {
        - nodes [][]string
        - hashes []string

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class c14nStatements << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class debugger << (S,Aquamarine) >> {
        - log(depth int, args ...<font color=blue>interface</font>{}) 
        - logf(depth int, format string, args ...<font color=blue>interface</font>{}) 
        - logHashes(depth int, hashes <font color=blue>map</font>[string][]byte, size int) 
        - logParts(depth int, parts byLengthHash) 
        - log(depth int, args ...<font color=blue>interface</font>{}) 
        - logf(depth int, format string, args ...<font color=blue>interface</font>{}) 
        - logHashes(depth int, hashes <font color=blue>map</font>[string][]byte, size int) 
        - logParts(depth int, parts byLengthHash) 

    }
    class dfs << (S,Aquamarine) >> {
        - evaluate(g []*Statement, q []*Statement, cands <font color=blue>map</font>[string]<font color=blue>map</font>[string]bool, mu <font color=blue>map</font>[string]string) <font color=blue>map</font>[string]string
        - search(g []*Statement, q []*Statement, cands <font color=blue>map</font>[string]<font color=blue>map</font>[string]bool, mu <font color=blue>map</font>[string]string) <font color=blue>map</font>[string]string
        - join(q *Statement, g []*Statement, cands <font color=blue>map</font>[string]<font color=blue>map</font>[string]bool, m <font color=blue>map</font>[string]string) []<font color=blue>map</font>[string]string

    }
    class djSet << (S,Aquamarine) >> {
        - add(e string) 
        - union(a *dsNode, b *dsNode) 
        - find(e string) *dsNode

    }
    class dsNode << (S,Aquamarine) >> {
        - parent *dsNode
        - rank int

    }
    class hashBag << (S,Aquamarine) >> {
        - hash hash.Hash
        - hashesFor <font color=blue>map</font>[string][][]byte

        - add(term string, hash []byte) 
        - sum(term string) []byte

    }
    class issuer << (S,Aquamarine) >> {
        - prefix string
        - issued <font color=blue>map</font>[string]string
        - ordered []string

        - issueFor(b string) string
        - has(id string) bool
        - clone() *issuer

    }
    class lexical << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class lexicalStatements << (S,Aquamarine) >> {
        - statements []*Statement
        - hashes <font color=blue>map</font>[string][]byte

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class orderedByCodom << (S,Aquamarine) >> {
        - maps []<font color=blue>map</font>[string]string
        - attrs []attrs

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class permutations << (S,Aquamarine) >> {
        - src []string
        - dst []string
        - idx []int
        - perm *combin.PermutationGenerator

        - next() bool
        - permutation() []string

    }
    class rdf.Kind << (T, #FF7700) >>  {
    }
    class rdf.c14nStatements << (T, #FF7700) >>  {
    }
    class rdf.debugger << (T, #FF7700) >>  {
    }
    class rdf.djSet << (T, #FF7700) >>  {
    }
    class rdf.lexical << (T, #FF7700) >>  {
    }
    class rdf.relatedHashCreator << (T, #FF7700) >>  {
    }
    class rdf.store << (T, #FF7700) >>  {
    }
    class rdf.triple << (T, #FF7700) >>  {
    }
    class relabeledStatement << (S,Aquamarine) >> {
        - statement *Statement
        - labels <font color=blue>map</font>[string][]byte

        - less(b relabeledStatement) bool

        + String() string

    }
    class relabeledTerm << (S,Aquamarine) >> {
        - term Term
        - labels <font color=blue>map</font>[string][]byte

        - less(b relabeledTerm) bool

        + String() string

    }
    class store << (S,Aquamarine) >> {
        - intern(s string) string

    }
    class table << (S,Aquamarine) >> {
        - hashOf <font color=blue>map</font>[string][]byte
        - termsFor <font color=blue>map</font>[string]<font color=blue>map</font>[string]bool
        - isBlank <font color=blue>map</font>[string]bool
        - blanks []string

        - wasCloned() bool
        - isNew() bool
        - clone() *table
        - set(term string, hash []byte) 
        - allUnique() bool
        - changedFrom(last *table) bool

    }
    class urna << (S,Aquamarine) >> {
        - canon *issuer
        - hashes <font color=blue>map</font>[string]string
        - statementsFor <font color=blue>map</font>[string][]*Statement
        - hash hash.Hash
        - hashToRelated relatedHashCreator
        - label string

        - relabel(dst []*Statement, src []*Statement) ([]*Statement, error)
        - hashFirstDegreeQuads(b string) string
        - hashNDegreeQuads(b string, names *issuer) ([]byte, *issuer)
        - hashToRelatedURDNA2015(b string, names *issuer) <font color=blue>map</font>[string][]string
        - hashToRelatedURGNA2012(b string, names *issuer) <font color=blue>map</font>[string][]string
        - hashRelatedBlank(term string, s *Statement, names *issuer, pos byte) []byte

    }
}

"gen.GraphBuilder" <|-- "rdf.Graph"
"graph.Directed" <|-- "rdf.Graph"
"graph.DirectedMultigraph" <|-- "rdf.Graph"
"graph.Graph" <|-- "rdf.Graph"
"graph.Multigraph" <|-- "rdf.Graph"
"graph.WeightedDirected" <|-- "rdf.Graph"
"graph.WeightedDirectedMultigraph" <|-- "rdf.Graph"
"testgraph.edgeLister" <|-- "rdf.Graph"
"traverse.Graph" <|-- "rdf.Graph"
"dot.basicEdge" <|-- "rdf.Statement"
"graph.Edge" <|-- "rdf.Statement"
"graph.Line" <|-- "rdf.Statement"
"graph.Node" <|-- "rdf.Statement"
"testgraph.Edge" <|-- "rdf.Statement"
"graph.Node" <|-- "rdf.Term"

namespace samplemv {
    class Halton << (S,Aquamarine) >> {
        + Kind HaltonKind
        + Q distmv.Quantiler
        + Src rand.Source

        + Sample(batch *mat.Dense) 

    }
    class IID << (S,Aquamarine) >> {
        + Dist distmv.Rander

        + Sample(batch *mat.Dense) 

    }
    class Importance << (S,Aquamarine) >> {
        + Target distmv.LogProber
        + Proposal distmv.RandLogProber

        + SampleWeighted(batch *mat.Dense, weights []float64) 

    }
    class LatinHypercube << (S,Aquamarine) >> {
        + Q distmv.Quantiler
        + Src rand.Source

        + Sample(batch *mat.Dense) 

    }
    interface MHProposal  {
        + ConditionalLogProb(x []float64, y []float64) float64
        + ConditionalRand(x []float64, y []float64) []float64

    }
    class MetropolisHastingser << (S,Aquamarine) >> {
        + Initial []float64
        + Target distmv.LogProber
        + Proposal MHProposal
        + Src rand.Source
        + BurnIn int
        + Rate int

        + Sample(batch *mat.Dense) 

    }
    class ProposalNormal << (S,Aquamarine) >> {
        - normal *distmv.Normal

        + ConditionalLogProb(x []float64, y []float64) float64
        + ConditionalRand(x []float64, y []float64) []float64

    }
    class Rejection << (S,Aquamarine) >> {
        - err error
        - proposed int

        + C float64
        + Target distmv.LogProber
        + Proposal distmv.RandLogProber
        + Src rand.Source

        + Err() error
        + Proposed() int
        + Sample(batch *mat.Dense) 

    }
    class SampleUniformWeighted << (S,Aquamarine) >> {
        + SampleWeighted(batch *mat.Dense, weights []float64) 

    }
    interface Sampler  {
        + Sample(batch *mat.Dense) 

    }
    interface WeightedSampler  {
        + SampleWeighted(batch *mat.Dense, weights []float64) 

    }
    class samplemv.HaltonKind << (T, #FF7700) >>  {
    }
}
"samplemv.Sampler" *-- "samplemv.SampleUniformWeighted"

"samplemv.Sampler" <|-- "samplemv.Halton"
"samplemv.Sampler" <|-- "samplemv.IID"
"samplemv.WeightedSampler" <|-- "samplemv.Importance"
"samplemv.Sampler" <|-- "samplemv.LatinHypercube"
"samplemv.Sampler" <|-- "samplemv.MetropolisHastingser"
"samplemv.MHProposal" <|-- "samplemv.ProposalNormal"
"samplemv.Sampler" <|-- "samplemv.Rejection"
"samplemv.WeightedSampler" <|-- "samplemv.SampleUniformWeighted"

namespace sampleuv {
    class IIDer << (S,Aquamarine) >> {
        + Dist distuv.Rander

        + Sample(batch []float64) 

    }
    class Importance << (S,Aquamarine) >> {
        + Target distuv.LogProber
        + Proposal distuv.RandLogProber

        + SampleWeighted(batch []float64, weights []float64) 

    }
    class LatinHypercube << (S,Aquamarine) >> {
        + Q distuv.Quantiler
        + Src rand.Source

        + Sample(batch []float64) 

    }
    interface MHProposal  {
        + ConditionalLogProb(x float64, y float64) float64
        + ConditionalRand(y float64) float64

    }
    class MetropolisHastings << (S,Aquamarine) >> {
        + Initial float64
        + Target distuv.LogProber
        + Proposal MHProposal
        + Src rand.Source
        + BurnIn int
        + Rate int

        + Sample(batch []float64) 

    }
    class Rejection << (S,Aquamarine) >> {
        - err error
        - proposed int

        + C float64
        + Target distuv.LogProber
        + Proposal distuv.RandLogProber
        + Src rand.Source

        + Err() error
        + Proposed() int
        + Sample(batch []float64) 

    }
    class SampleUniformWeighted << (S,Aquamarine) >> {
        + SampleWeighted(batch []float64, weights []float64) 

    }
    interface Sampler  {
        + Sample(batch []float64) 

    }
    class Weighted << (S,Aquamarine) >> {
        - weights []float64
        - heap []float64
        - rnd *rand.Rand

        - reset() 

        + Len() int
        + Take() (int, bool)
        + Reweight(idx int, w float64) 
        + ReweightAll(w []float64) 

    }
    interface WeightedSampler  {
        + SampleWeighted(batch []float64, weights []float64) 

    }
}
"sampleuv.Sampler" *-- "sampleuv.SampleUniformWeighted"

"sampleuv.Sampler" <|-- "sampleuv.IIDer"
"sampleuv.WeightedSampler" <|-- "sampleuv.Importance"
"sampleuv.Sampler" <|-- "sampleuv.LatinHypercube"
"sampleuv.Sampler" <|-- "sampleuv.MetropolisHastings"
"sampleuv.Sampler" <|-- "sampleuv.Rejection"
"sampleuv.WeightedSampler" <|-- "sampleuv.SampleUniformWeighted"

namespace set {
    class Int64s << (S,Aquamarine) >> {
        + Add(e int64) 
        + Has(e int64) bool
        + Remove(e int64) 
        + Count() int

    }
    class Ints << (S,Aquamarine) >> {
        + Add(e int) 
        + Has(e int) bool
        + Remove(e int) 
        + Count() int

    }
    class Nodes << (S,Aquamarine) >> {
        + Add(n graph.Node) 
        + Remove(e graph.Node) 
        + Count() int
        + Has(n graph.Node) bool

    }
    class set.Int64s << (T, #FF7700) >>  {
    }
    class set.Ints << (T, #FF7700) >>  {
    }
    class set.Nodes << (T, #FF7700) >>  {
    }
    class "<font color=blue>map</font>[int64]graph.Node" as fontcolorbluemapfontint64graphNode {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}


namespace sigmajs {
    class Edge << (S,Aquamarine) >> {
        + ID string
        + Source string
        + Target string
        + Attributes <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(data []byte) error

    }
    class Graph << (S,Aquamarine) >> {
        + Nodes []Node
        + Edges []Edge

    }
    class Node << (S,Aquamarine) >> {
        + ID string
        + Attributes <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        + MarshalJSON() ([]byte, error)
        + UnmarshalJSON(data []byte) error

    }
}


namespace simple {
    class DirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - from <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Edge
        - to <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Edge
        - nodeIDs *uid.Set

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + NewEdge(from graph.Node, to graph.Node) graph.Edge
        + NewNode() graph.Node
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveEdge(fid int64, tid int64) 
        + RemoveNode(id int64) 
        + SetEdge(e graph.Edge) 
        + To(id int64) graph.Nodes

    }
    class DirectedMatrix << (S,Aquamarine) >> {
        - mat *mat.Dense
        - nodes []graph.Node
        - self float64
        - absent float64

        - setWeightedEdge(e graph.Edge, weight float64) 
        - has(id int64) bool

        + Edge(uid int64, vid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + Matrix() mat.Matrix
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + RemoveEdge(fid int64, tid int64) 
        + SetEdge(e graph.Edge) 
        + SetWeightedEdge(e graph.WeightedEdge) 
        + To(id int64) graph.Nodes
        + Weight(xid int64, yid int64) (float64, bool)
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + WeightedEdges() graph.WeightedEdges

    }
    class Edge << (S,Aquamarine) >> {
        + F graph.Node

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge

    }
    class Node << (S,Aquamarine) >> {
        + ID() int64

    }
    class UndirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.Edge
        - nodeIDs *uid.Set

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + EdgeBetween(xid int64, yid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + NewEdge(from graph.Node, to graph.Node) graph.Edge
        + NewNode() graph.Node
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveEdge(fid int64, tid int64) 
        + RemoveNode(id int64) 
        + SetEdge(e graph.Edge) 

    }
    class UndirectedMatrix << (S,Aquamarine) >> {
        - mat *mat.SymDense
        - nodes []graph.Node
        - self float64
        - absent float64

        - setWeightedEdge(e graph.Edge, weight float64) 
        - has(id int64) bool

        + Edge(uid int64, vid int64) graph.Edge
        + EdgeBetween(uid int64, vid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(uid int64, vid int64) bool
        + Matrix() mat.Matrix
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + RemoveEdge(fid int64, tid int64) 
        + SetEdge(e graph.Edge) 
        + SetWeightedEdge(e graph.WeightedEdge) 
        + Weight(xid int64, yid int64) (float64, bool)
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + WeightedEdgeBetween(uid int64, vid int64) graph.WeightedEdge
        + WeightedEdges() graph.WeightedEdges

    }
    class WeightedDirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - from <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.WeightedEdge
        - to <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.WeightedEdge
        - self float64
        - nodeIDs *uid.Set

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + HasEdgeFromTo(uid int64, vid int64) bool
        + NewNode() graph.Node
        + NewWeightedEdge(from graph.Node, to graph.Node, weight float64) graph.WeightedEdge
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveEdge(fid int64, tid int64) 
        + RemoveNode(id int64) 
        + SetWeightedEdge(e graph.WeightedEdge) 
        + To(id int64) graph.Nodes
        + Weight(xid int64, yid int64) (float64, bool)
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + WeightedEdges() graph.WeightedEdges

    }
    class WeightedEdge << (S,Aquamarine) >> {
        + F graph.Node
        + W float64

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge
        + Weight() float64

    }
    class WeightedUndirectedGraph << (S,Aquamarine) >> {
        - nodes <font color=blue>map</font>[int64]graph.Node
        - edges <font color=blue>map</font>[int64]<font color=blue>map</font>[int64]graph.WeightedEdge
        - self float64
        - nodeIDs *uid.Set

        + AddNode(n graph.Node) 
        + Edge(uid int64, vid int64) graph.Edge
        + EdgeBetween(xid int64, yid int64) graph.Edge
        + Edges() graph.Edges
        + From(id int64) graph.Nodes
        + HasEdgeBetween(xid int64, yid int64) bool
        + NewNode() graph.Node
        + NewWeightedEdge(from graph.Node, to graph.Node, weight float64) graph.WeightedEdge
        + Node(id int64) graph.Node
        + Nodes() graph.Nodes
        + NodeWithID(id int64) (graph.Node, bool)
        + RemoveEdge(fid int64, tid int64) 
        + RemoveNode(id int64) 
        + SetWeightedEdge(e graph.WeightedEdge) 
        + Weight(xid int64, yid int64) (float64, bool)
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + WeightedEdgeBetween(xid int64, yid int64) graph.WeightedEdge
        + WeightedEdges() graph.WeightedEdges

    }
    interface edgeSetter  {
        + SetEdge(e graph.Edge) 

    }
    class simple.Node << (T, #FF7700) >>  {
    }
    interface weightedEdgeSetter  {
        + SetWeightedEdge(e graph.WeightedEdge) 

    }
}

"gen.GraphBuilder" <|-- "simple.DirectedGraph"
"graph.Directed" <|-- "simple.DirectedGraph"
"graph.DirectedMultigraph" <|-- "simple.DirectedGraph"
"graph.EdgeAdder" <|-- "simple.DirectedGraph"
"graph.EdgeRemover" <|-- "simple.DirectedGraph"
"graph.Graph" <|-- "simple.DirectedGraph"
"graph.NodeAdder" <|-- "simple.DirectedGraph"
"graph.NodeRemover" <|-- "simple.DirectedGraph"
"graph.NodeWithIDer" <|-- "simple.DirectedGraph"
"graph.WeightedDirected" <|-- "simple.DirectedGraph"
"graph.WeightedDirectedMultigraph" <|-- "simple.DirectedGraph"
"simple.edgeSetter" <|-- "simple.DirectedGraph"
"testgraph.edgeLister" <|-- "simple.DirectedGraph"
"topo.Builder" <|-- "simple.DirectedGraph"
"traverse.Graph" <|-- "simple.DirectedGraph"
"gen.GraphBuilder" <|-- "simple.DirectedMatrix"
"graph.Directed" <|-- "simple.DirectedMatrix"
"graph.DirectedMultigraph" <|-- "simple.DirectedMatrix"
"graph.EdgeRemover" <|-- "simple.DirectedMatrix"
"graph.Graph" <|-- "simple.DirectedMatrix"
"graph.Weighted" <|-- "simple.DirectedMatrix"
"graph.WeightedDirected" <|-- "simple.DirectedMatrix"
"graph.WeightedDirectedMultigraph" <|-- "simple.DirectedMatrix"
"path.UndirectedWeightLister" <|-- "simple.DirectedMatrix"
"path.Weighted" <|-- "simple.DirectedMatrix"
"simple.edgeSetter" <|-- "simple.DirectedMatrix"
"simple.weightedEdgeSetter" <|-- "simple.DirectedMatrix"
"testgraph.edgeLister" <|-- "simple.DirectedMatrix"
"testgraph.matrixer" <|-- "simple.DirectedMatrix"
"testgraph.weightedEdgeLister" <|-- "simple.DirectedMatrix"
"traverse.Graph" <|-- "simple.DirectedMatrix"
"dot.basicEdge" <|-- "simple.Edge"
"graph.Edge" <|-- "simple.Edge"
"testgraph.Edge" <|-- "simple.Edge"
"graph.Node" <|-- "simple.Node"
"gen.GraphBuilder" <|-- "simple.UndirectedGraph"
"graph.EdgeAdder" <|-- "simple.UndirectedGraph"
"graph.EdgeRemover" <|-- "simple.UndirectedGraph"
"graph.Graph" <|-- "simple.UndirectedGraph"
"graph.NodeAdder" <|-- "simple.UndirectedGraph"
"graph.NodeRemover" <|-- "simple.UndirectedGraph"
"graph.NodeWithIDer" <|-- "simple.UndirectedGraph"
"graph.Undirected" <|-- "simple.UndirectedGraph"
"simple.edgeSetter" <|-- "simple.UndirectedGraph"
"testgraph.edgeLister" <|-- "simple.UndirectedGraph"
"topo.Builder" <|-- "simple.UndirectedGraph"
"traverse.Graph" <|-- "simple.UndirectedGraph"
"gen.GraphBuilder" <|-- "simple.UndirectedMatrix"
"graph.EdgeRemover" <|-- "simple.UndirectedMatrix"
"graph.Graph" <|-- "simple.UndirectedMatrix"
"graph.Undirected" <|-- "simple.UndirectedMatrix"
"graph.Weighted" <|-- "simple.UndirectedMatrix"
"graph.WeightedUndirected" <|-- "simple.UndirectedMatrix"
"path.UndirectedWeightLister" <|-- "simple.UndirectedMatrix"
"path.Weighted" <|-- "simple.UndirectedMatrix"
"simple.edgeSetter" <|-- "simple.UndirectedMatrix"
"simple.weightedEdgeSetter" <|-- "simple.UndirectedMatrix"
"testgraph.edgeLister" <|-- "simple.UndirectedMatrix"
"testgraph.matrixer" <|-- "simple.UndirectedMatrix"
"testgraph.weightedEdgeLister" <|-- "simple.UndirectedMatrix"
"traverse.Graph" <|-- "simple.UndirectedMatrix"
"gen.GraphBuilder" <|-- "simple.WeightedDirectedGraph"
"graph.Directed" <|-- "simple.WeightedDirectedGraph"
"graph.DirectedMultigraph" <|-- "simple.WeightedDirectedGraph"
"graph.EdgeRemover" <|-- "simple.WeightedDirectedGraph"
"graph.Graph" <|-- "simple.WeightedDirectedGraph"
"graph.NodeAdder" <|-- "simple.WeightedDirectedGraph"
"graph.NodeRemover" <|-- "simple.WeightedDirectedGraph"
"graph.NodeWithIDer" <|-- "simple.WeightedDirectedGraph"
"graph.Weighted" <|-- "simple.WeightedDirectedGraph"
"graph.WeightedDirected" <|-- "simple.WeightedDirectedGraph"
"graph.WeightedDirectedMultigraph" <|-- "simple.WeightedDirectedGraph"
"graph.WeightedEdgeAdder" <|-- "simple.WeightedDirectedGraph"
"path.UndirectedWeightLister" <|-- "simple.WeightedDirectedGraph"
"path.Weighted" <|-- "simple.WeightedDirectedGraph"
"path.WeightedBuilder" <|-- "simple.WeightedDirectedGraph"
"simple.weightedEdgeSetter" <|-- "simple.WeightedDirectedGraph"
"testgraph.edgeLister" <|-- "simple.WeightedDirectedGraph"
"testgraph.weightedEdgeLister" <|-- "simple.WeightedDirectedGraph"
"traverse.Graph" <|-- "simple.WeightedDirectedGraph"
"dot.basicEdge" <|-- "simple.WeightedEdge"
"graph.Edge" <|-- "simple.WeightedEdge"
"graph.WeightedEdge" <|-- "simple.WeightedEdge"
"graph.WeightedLine" <|-- "simple.WeightedEdge"
"testgraph.Edge" <|-- "simple.WeightedEdge"
"gen.GraphBuilder" <|-- "simple.WeightedUndirectedGraph"
"graph.EdgeRemover" <|-- "simple.WeightedUndirectedGraph"
"graph.Graph" <|-- "simple.WeightedUndirectedGraph"
"graph.NodeAdder" <|-- "simple.WeightedUndirectedGraph"
"graph.NodeRemover" <|-- "simple.WeightedUndirectedGraph"
"graph.NodeWithIDer" <|-- "simple.WeightedUndirectedGraph"
"graph.Undirected" <|-- "simple.WeightedUndirectedGraph"
"graph.Weighted" <|-- "simple.WeightedUndirectedGraph"
"graph.WeightedEdgeAdder" <|-- "simple.WeightedUndirectedGraph"
"graph.WeightedUndirected" <|-- "simple.WeightedUndirectedGraph"
"path.UndirectedWeightLister" <|-- "simple.WeightedUndirectedGraph"
"path.Weighted" <|-- "simple.WeightedUndirectedGraph"
"path.WeightedBuilder" <|-- "simple.WeightedUndirectedGraph"
"simple.weightedEdgeSetter" <|-- "simple.WeightedUndirectedGraph"
"testgraph.edgeLister" <|-- "simple.WeightedUndirectedGraph"
"testgraph.weightedEdgeLister" <|-- "simple.WeightedUndirectedGraph"
"traverse.Graph" <|-- "simple.WeightedUndirectedGraph"

namespace spectral {
    class Laplacian << (S,Aquamarine) >> {
        + Nodes []graph.Node
        + Index <font color=blue>map</font>[int64]int

    }
}
"mat.Matrix" *-- "spectral.Laplacian"


namespace stat {
    class CC << (S,Aquamarine) >> {
        - n int
        - xd int
        - x *mat.SVD
        - ok bool

        + CanonicalCorrelations(x mat.Matrix, y mat.Matrix, weights []float64) error
        + CorrsTo(dst []float64) []float64
        + LeftTo(dst *mat.Dense, spheredSpace bool) 
        + RightTo(dst *mat.Dense, spheredSpace bool) 

    }
    class PC << (S,Aquamarine) >> {
        - n int
        - weights []float64
        - svd *mat.SVD
        - ok bool

        + PrincipalComponents(a mat.Matrix, weights []float64) bool
        + VectorsTo(dst *mat.Dense) 
        + VarsTo(dst []float64) []float64

    }
    class labelSorter << (S,Aquamarine) >> {
        - x []float64
        - l []bool

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class stat.CumulantKind << (T, #FF7700) >>  {
    }
    class weightLabelSorter << (S,Aquamarine) >> {
        - x []float64
        - l []bool
        - w []float64

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class weightSorter << (S,Aquamarine) >> {
        - x []float64
        - w []float64

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
}


namespace testblas {
    class DScalCase << (S,Aquamarine) >> {
        + Alpha float64
        + Ans []float64
        + Name string

    }
    class DTwoVecAnswer << (S,Aquamarine) >> {
        + X []float64
        + Y []float64

    }
    interface Dasumer  {
        + Dasum(n int, x []float64, incX int) float64

    }
    class DaxpyCase << (S,Aquamarine) >> {
        + Alpha float64
        + Ans []float64

    }
    interface Daxpyer  {
        + Daxpy(n int, alpha float64, x []float64, incX int, y []float64, incY int) 

    }
    interface Dcopier  {
        + Dcopy(n int, x []float64, incX int, y []float64, incY int) 

    }
    interface Ddotter  {
        + Ddot(n int, x []float64, incX int, y []float64, incY int) float64

    }
    interface Dgbmver  {
        + Dgbmv(tA blas.Transpose, m int, n int, kL int, kU int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 

    }
    class DgemmCase << (S,Aquamarine) >> {
        - m int
        - alpha float64
        - a [][]float64
        - b [][]float64
        - c [][]float64
        - ans [][]float64

    }
    interface Dgemmer  {
        + Dgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 

    }
    class DgemvCase << (S,Aquamarine) >> {
        - m int
        - n int
        - tA blas.Transpose
        - x []float64
        - incX int
        - y []float64
        - incY int

        + Name string
        + A [][]float64
        + Subcases []DgemvSubcase

    }
    class DgemvSubcase << (S,Aquamarine) >> {
        - mulXNeg1 bool
        - mulYNeg1 bool
        - alpha float64
        - beta float64
        - ans []float64

    }
    interface Dgemver  {
        + Dgemv(tA blas.Transpose, m int, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 

    }
    interface Dgerer  {
        + Dger(m int, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) 

    }
    interface Dnrm2er  {
        + Dnrm2(n int, x []float64, incX int) float64

    }
    class DoubleOneVectorCase << (S,Aquamarine) >> {
        + Name string
        + X []float64
        + Incx int
        + N int
        + Panic bool
        + Dasum float64
        + Dnrm2 float64
        + Idamax int
        + DscalCases []DScalCase

    }
    class DoubleTwoVectorCase << (S,Aquamarine) >> {
        + Name string
        + X []float64
        + Y []float64
        + XTmp []float64
        + YTmp []float64
        + Incx int
        + Incy int
        + N int
        + Panic bool
        + DaxpyCases []DaxpyCase
        + DdotAns float64
        + DswapAns DTwoVecAnswer
        + DcopyAns DTwoVecAnswer
        + DrotCases []DrotCase
        + DrotmCases []DrotmCase

    }
    class DrotCase << (S,Aquamarine) >> {
        + C float64
        + S float64
        + XAns []float64
        + YAns []float64

    }
    interface Droter  {
        + Drot(n int, x []float64, incX int, y []float64, incY int, c float64, s float64) 

    }
    class DrotgTestStruct << (S,Aquamarine) >> {
        + Name string
        + A float64
        + C float64

    }
    interface Drotger  {
        + Drotg(a float64, b float64) (float64, float64, float64, float64)

    }
    class DrotmCase << (S,Aquamarine) >> {
        + P blas.DrotmParams
        + XAns []float64
        + YAns []float64
        + Name string

    }
    interface Drotmer  {
        + Drotm(n int, x []float64, incX int, y []float64, incY int, p blas.DrotmParams) 

    }
    class DrotmgTestStruct << (S,Aquamarine) >> {
        + Name string
        + D1 float64
        + P *blas.DrotmParams
        + Rd1 float64

    }
    interface Drotmger  {
        + Drotmg(d1 float64, d2 float64, x1 float64, y1 float64) (blas.DrotmParams, float64, float64, float64)

    }
    interface Dsbmver  {
        + Dsbmv(ul blas.Uplo, n int, k int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 

    }
    interface Dscaler  {
        + Dscal(n int, alpha float64, x []float64, incX int) 

    }
    interface Dspmver  {
        + Dspmv(ul blas.Uplo, n int, alpha float64, ap []float64, x []float64, incX int, beta float64, y []float64, incY int) 

    }
    interface Dspr2er  {
        + Dspr2(ul blas.Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64) 

    }
    interface Dsprer  {
        + Dspr(ul blas.Uplo, n int, alpha float64, x []float64, incX int, a []float64) 

    }
    interface Dswapper  {
        + Dswap(n int, x []float64, incX int, y []float64, incY int) 

    }
    interface Dsyker  {
        + Dsyrk(ul blas.Uplo, tA blas.Transpose, n int, k int, alpha float64, a []float64, lda int, beta float64, c []float64, ldc int) 

    }
    interface Dsymmer  {
        + Dsymm(s blas.Side, ul blas.Uplo, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 

    }
    interface Dsymver  {
        + Dsymv(ul blas.Uplo, n int, alpha float64, a []float64, lda int, x []float64, incX int, beta float64, y []float64, incY int) 

    }
    interface Dsyr2er  {
        + Dsyr2(ul blas.Uplo, n int, alpha float64, x []float64, incX int, y []float64, incY int, a []float64, lda int) 

    }
    interface Dsyr2ker  {
        + Dsyr2k(ul blas.Uplo, tA blas.Transpose, n int, k int, alpha float64, a []float64, lda int, b []float64, ldb int, beta float64, c []float64, ldc int) 

    }
    interface Dsyrer  {
        + Dsyr(ul blas.Uplo, n int, alpha float64, x []float64, incX int, a []float64, lda int) 

    }
    interface Dtbmver  {
        + Dtbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float64, lda int, x []float64, incX int) 

    }
    interface Dtbsver  {
        + Dtbsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float64, lda int, x []float64, incX int) 
        + Dtrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) 

    }
    interface Dtpmver  {
        + Dtpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float64, x []float64, incX int) 

    }
    interface Dtpsver  {
        + Dtpsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, ap []float64, x []float64, incX int) 

    }
    interface Dtrmmer  {
        + Dtrmm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) 

    }
    interface Dtrmver  {
        + Dtrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) 

    }
    interface Dtrsmer  {
        + Dtrsm(s blas.Side, ul blas.Uplo, tA blas.Transpose, d blas.Diag, m int, n int, alpha float64, a []float64, lda int, b []float64, ldb int) 

    }
    interface Dtrsver  {
        + Dtrsv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) 

    }
    interface Dtxmver  {
        + Dtrmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, lda int, x []float64, incX int) 
        + Dtbmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, k int, a []float64, lda int, x []float64, incX int) 
        + Dtpmv(ul blas.Uplo, tA blas.Transpose, d blas.Diag, n int, a []float64, x []float64, incX int) 

    }
    interface Dzasumer  {
        + Dzasum(n int, x []complex128, incX int) float64

    }
    interface Dznrm2er  {
        + Dznrm2(n int, x []complex128, incX int) float64

    }
    interface Idamaxer  {
        + Idamax(n int, x []float64, incX int) int

    }
    interface Izamaxer  {
        + Izamax(n int, x []complex128, incX int) int

    }
    interface Sgerer  {
        + Sger(m int, n int, alpha float32, x []float32, incX int, y []float32, incY int, a []float32, lda int) 

    }
    interface Zaxpyer  {
        + Zaxpy(n int, alpha complex128, x []complex128, incX int, y []complex128, incY int) 

    }
    interface Zcopyer  {
        + Zcopy(n int, x []complex128, incX int, y []complex128, incY int) 

    }
    interface Zdotcer  {
        + Zdotc(n int, x []complex128, incX int, y []complex128, incY int) complex128

    }
    interface Zdotuer  {
        + Zdotu(n int, x []complex128, incX int, y []complex128, incY int) complex128

    }
    interface Zdscaler  {
        + Zdscal(n int, alpha float64, x []complex128, incX int) 

    }
    interface Zgbmver  {
        + Zgbmv(trans blas.Transpose, m int, n int, kL int, kU int, alpha complex128, ab []complex128, ldab int, x []complex128, incX int, beta complex128, y []complex128, incY int) 

    }
    interface Zgemmer  {
        + Zgemm(tA blas.Transpose, tB blas.Transpose, m int, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 

    }
    interface Zgemver  {
        + Zgemv(trans blas.Transpose, m int, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 

    }
    interface Zgercer  {
        + Zgerc(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 

    }
    interface Zgeruer  {
        + Zgeru(m int, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 

    }
    interface Zhbmver  {
        + Zhbmv(uplo blas.Uplo, n int, k int, alpha complex128, ab []complex128, ldab int, x []complex128, incX int, beta complex128, y []complex128, incY int) 

    }
    interface Zhemmer  {
        + Zhemm(side blas.Side, uplo blas.Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 

    }
    interface Zhemver  {
        + Zhemv(uplo blas.Uplo, n int, alpha complex128, a []complex128, lda int, x []complex128, incX int, beta complex128, y []complex128, incY int) 

    }
    interface Zher2er  {
        + Zher2(uplo blas.Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, a []complex128, lda int) 

    }
    interface Zher2ker  {
        + Zher2k(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta float64, c []complex128, ldc int) 

    }
    interface Zherer  {
        + Zher(uplo blas.Uplo, n int, alpha float64, x []complex128, incX int, a []complex128, lda int) 

    }
    interface Zherker  {
        + Zherk(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha float64, a []complex128, lda int, beta float64, c []complex128, ldc int) 

    }
    interface Zhpmver  {
        + Zhpmv(uplo blas.Uplo, n int, alpha complex128, ap []complex128, x []complex128, incX int, beta complex128, y []complex128, incY int) 

    }
    interface Zhpr2er  {
        + Zhpr2(uplo blas.Uplo, n int, alpha complex128, x []complex128, incX int, y []complex128, incY int, ap []complex128) 

    }
    interface Zhprer  {
        + Zhpr(uplo blas.Uplo, n int, alpha float64, x []complex128, incX int, ap []complex128) 

    }
    interface Zscaler  {
        + Zscal(n int, alpha complex128, x []complex128, incX int) 

    }
    interface Zswaper  {
        + Zswap(n int, x []complex128, incX int, y []complex128, incY int) 

    }
    interface Zsymmer  {
        + Zsymm(side blas.Side, uplo blas.Uplo, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 

    }
    interface Zsyr2ker  {
        + Zsyr2k(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, b []complex128, ldb int, beta complex128, c []complex128, ldc int) 

    }
    interface Zsyrker  {
        + Zsyrk(uplo blas.Uplo, trans blas.Transpose, n int, k int, alpha complex128, a []complex128, lda int, beta complex128, c []complex128, ldc int) 

    }
    interface Ztbmver  {
        + Ztbmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, k int, ab []complex128, ldab int, x []complex128, incX int) 

    }
    interface Ztbsver  {
        + Ztbsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, k int, ab []complex128, ldab int, x []complex128, incX int) 

    }
    interface Ztpmver  {
        + Ztpmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, ap []complex128, x []complex128, incX int) 

    }
    interface Ztpsver  {
        + Ztpsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, ap []complex128, x []complex128, incX int) 

    }
    interface Ztrmmer  {
        + Ztrmm(side blas.Side, uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) 

    }
    interface Ztrmver  {
        + Ztrmv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, a []complex128, lda int, x []complex128, incX int) 

    }
    interface Ztrsmer  {
        + Ztrsm(side blas.Side, uplo blas.Uplo, transA blas.Transpose, diag blas.Diag, m int, n int, alpha complex128, a []complex128, lda int, b []complex128, ldb int) 

    }
    interface Ztrsver  {
        + Ztrsv(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, a []complex128, lda int, x []complex128, incX int) 

    }
    class vec << (S,Aquamarine) >> {
        - data []float64
        - inc int

    }
}
"testblas.Drotmer" *-- "testblas.Drotmger"
"testblas.Dnrm2er" *-- "testblas.Dznrm2er"
"testblas.Zgemver" *-- "testblas.Zgbmver"
"testblas.Zhemver" *-- "testblas.Zhbmver"
"testblas.Ztrmver" *-- "testblas.Ztbmver"
"testblas.Ztbmver" *-- "testblas.Ztbsver"
"testblas.Ztpmver" *-- "testblas.Ztpsver"
"testblas.Ztrmver" *-- "testblas.Ztrsver"


namespace testgraph {
    interface Edge  {
        + From() graph.Node
        + To() graph.Node

    }
    interface EdgeAdder  {
    }
    interface EdgeRemover  {
    }
    interface LineAdder  {
    }
    interface LineRemover  {
    }
    interface NodeAdder  {
    }
    interface NodeRemover  {
    }
    class RandomNodes << (S,Aquamarine) >> {
        - n int
        - seed uint64
        - newNode <font color=blue>func</font>(int64) graph.Node
        - curr int64
        - state *rand.Rand
        - seen set.Int64s
        - count int

        + Len() int
        + Next() bool
        + Node() graph.Node
        + Reset() 

    }
    interface WeightedEdgeAdder  {
    }
    interface WeightedLine  {
        + ID() int64
        + Weight() float64

    }
    interface WeightedLineAdder  {
    }
    class edge << (S,Aquamarine) >> {
        - f int64

    }
    interface edgeLister  {
        + Edges() graph.Edges

    }
    class lexicalEdges << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class lexicalUndirectedEdges << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class line << (S,Aquamarine) >> {
        + F graph.Node
        + UID int64
        + W float64

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge
        + ID() int64
        + Weight() float64

    }
    interface matrixer  {
        + Matrix() mat.Matrix

    }
    class node << (S,Aquamarine) >> {
        + ID() int64

    }
    class testgraph.Builder << (T, #FF7700) >>  {
    }
    class testgraph.lexicalEdges << (T, #FF7700) >>  {
    }
    class testgraph.lexicalUndirectedEdges << (T, #FF7700) >>  {
    }
    class testgraph.node << (T, #FF7700) >>  {
    }
    class testgraph.tripleInt64s << (T, #FF7700) >>  {
    }
    class tripleInt64s << (S,Aquamarine) >> {
        - add(x int64, y int64, z int64) 
        - has(x int64, y int64, z int64) bool

    }
    interface weightedEdgeLister  {
        + WeightedEdges() graph.WeightedEdges

    }
    class "<font color=blue>func</font>([]graph.Node, []WeightedLine, float64, float64) (graph.Graph, []graph.Node, []Edge, float64, float64, bool)" as fontcolorbluefuncfontgraphNodeWeightedLinefloat64float64graphGraphgraphNodeEdgefloat64float64bool {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"testgraph.Edge" *-- "testgraph.WeightedLine"

"graph.Iterator" <|-- "testgraph.RandomNodes"
"graph.Nodes" <|-- "testgraph.RandomNodes"
"mat.Reseter" <|-- "testgraph.RandomNodes"
"dot.basicEdge" <|-- "testgraph.line"
"graph.Edge" <|-- "testgraph.line"
"graph.Node" <|-- "testgraph.line"
"graph.WeightedEdge" <|-- "testgraph.line"
"graph.WeightedLine" <|-- "testgraph.line"
"testgraph.Edge" <|-- "testgraph.line"
"testgraph.WeightedLine" <|-- "testgraph.line"
"graph.Node" <|-- "testgraph.node"

namespace testgraphs {
    class Grid << (S,Aquamarine) >> {
        - open []bool
        - r int

        + AllowDiagonal bool
        + UnitEdgeWeight bool
        + AllVisible bool

        - has(id int64) bool

        + Nodes() graph.Nodes
        + Node(id int64) graph.Node
        + HasOpen(id int64) bool
        + Set(r int, c int, open bool) 
        + Dims() (int, int)
        + RowCol(id int64) (int, int)
        + XY(id int64) (float64, float64)
        + NodeAt(r int, c int) graph.Node
        + From(uid int64) graph.Nodes
        + HasEdgeBetween(uid int64, vid int64) bool
        + Edge(uid int64, vid int64) graph.Edge
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + EdgeBetween(uid int64, vid int64) graph.Edge
        + WeightedEdgeBetween(uid int64, vid int64) graph.WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)
        + String() string
        + Render(path []graph.Node) ([]byte, error)

    }
    class LimitedVisionGrid << (S,Aquamarine) >> {
        + Grid *Grid
        + Location graph.Node
        + VisionRadius float64
        + Known <font color=blue>map</font>[int64]bool

        - allPossibleFrom(uid int64) []graph.Node
        - has(id int64) bool

        + MoveTo(n graph.Node) ([]graph.Edge, []graph.Edge)
        + RowCol(id int64) (int, int)
        + XY(id int64) (float64, float64)
        + Nodes() graph.Nodes
        + NodeAt(r int, c int) graph.Node
        + Node(id int64) graph.Node
        + From(uid int64) graph.Nodes
        + HasEdgeBetween(uid int64, vid int64) bool
        + Edge(uid int64, vid int64) graph.Edge
        + WeightedEdge(uid int64, vid int64) graph.WeightedEdge
        + EdgeBetween(uid int64, vid int64) graph.Edge
        + WeightedEdgeBetween(uid int64, vid int64) graph.WeightedEdge
        + Weight(xid int64, yid int64) (float64, bool)
        + String() string
        + Render(path []graph.Node) ([]byte, error)

    }
}

"gen.GraphBuilder" <|-- "testgraphs.Grid"
"graph.Graph" <|-- "testgraphs.Grid"
"graph.Undirected" <|-- "testgraphs.Grid"
"graph.Weighted" <|-- "testgraphs.Grid"
"graph.WeightedUndirected" <|-- "testgraphs.Grid"
"path.Weighted" <|-- "testgraphs.Grid"
"traverse.Graph" <|-- "testgraphs.Grid"
"gen.GraphBuilder" <|-- "testgraphs.LimitedVisionGrid"
"graph.Graph" <|-- "testgraphs.LimitedVisionGrid"
"graph.Undirected" <|-- "testgraphs.LimitedVisionGrid"
"graph.Weighted" <|-- "testgraphs.LimitedVisionGrid"
"graph.WeightedUndirected" <|-- "testgraphs.LimitedVisionGrid"
"path.Weighted" <|-- "testgraphs.LimitedVisionGrid"
"traverse.Graph" <|-- "testgraphs.LimitedVisionGrid"

namespace testlapack {
    class A123 << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128
        + LeftEV() blas64.General
        + RightEV() blas64.General

    }
    class AntisymRandom << (S,Aquamarine) >> {
        - mat blas64.General

        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Circulant << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Clement << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Creation << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    interface Dbdsqrer  {
        + Dbdsqr(uplo blas.Uplo, n int, ncvt int, nru int, ncc int, d []float64, e []float64, vt []float64, ldvt int, u []float64, ldu int, c []float64, ldc int, work []float64) bool

    }
    interface Dgebaker  {
        + Dgebak(job lapack.BalanceJob, side lapack.EVSide, n int, ilo int, ihi int, scale []float64, m int, v []float64, ldv int) 

    }
    interface Dgebaler  {
        + Dgebal(job lapack.BalanceJob, n int, a []float64, lda int, scale []float64) (int, int)

    }
    interface Dgebd2er  {
        + Dgebd2(m int, n int, a []float64, lda int, d []float64, e []float64, tauq []float64, taup []float64, work []float64) 

    }
    interface Dgebrder  {
        + Dgebrd(m int, n int, a []float64, lda int, d []float64, e []float64, tauQ []float64, tauP []float64, work []float64, lwork int) 

    }
    interface Dgeconer  {
        + Dgecon(norm lapack.MatrixNorm, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64

    }
    interface Dgeever  {
        + Dgeev(jobvl lapack.LeftEVJob, jobvr lapack.RightEVJob, n int, a []float64, lda int, wr []float64, wi []float64, vl []float64, ldvl int, vr []float64, ldvr int, work []float64, lwork int) int

    }
    interface Dgehd2er  {
        + Dgehd2(n int, ilo int, ihi int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dgehrder  {
        + Dgehrd(n int, ilo int, ihi int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorgqr(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dgelq2er  {
        + Dgelq2(m int, n int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dgelqfer  {
        + Dgelqf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dgelser  {
        + Dgels(trans blas.Transpose, m int, n int, nrhs int, a []float64, lda int, b []float64, ldb int, work []float64, lwork int) bool

    }
    interface Dgeql2er  {
        + Dgeql2(m int, n int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dgeqp3er  {
        + Dgeqp3(m int, n int, a []float64, lda int, jpvt []int, tau []float64, work []float64, lwork int) 

    }
    interface Dgeqr2er  {
        + Dgeqr2(m int, n int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dgeqrfer  {
        + Dgeqrf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dgerq2er  {
        + Dgerq2(m int, n int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dgerqfer  {
        + Dgerqf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dgesc2er  {
        + Dgesc2(n int, a []float64, lda int, rhs []float64, ipiv []int, jpiv []int) float64

    }
    interface Dgesvder  {
        + Dgesvd(jobU lapack.SVDJob, jobVT lapack.SVDJob, m int, n int, a []float64, lda int, s []float64, u []float64, ldu int, vt []float64, ldvt int, work []float64, lwork int) bool

    }
    interface Dgesver  {
        + Dgesv(n int, nrhs int, a []float64, lda int, ipiv []int, b []float64, ldb int) bool
        + Dgetri(n int, a []float64, lda int, ipiv []int, work []float64, lwork int) bool

    }
    interface Dgetc2er  {
        + Dgetc2(n int, a []float64, lda int, ipiv []int, jpiv []int) int

    }
    interface Dgetf2er  {
        + Dgetf2(m int, n int, a []float64, lda int, ipiv []int) bool

    }
    interface Dgetrfer  {
        + Dgetrf(m int, n int, a []float64, lda int, ipiv []int) bool

    }
    interface Dgetrier  {
        + Dgetri(n int, a []float64, lda int, ipiv []int, work []float64, lwork int) bool

    }
    interface Dgetrser  {
        + Dgetrs(trans blas.Transpose, n int, nrhs int, a []float64, lda int, ipiv []int, b []float64, ldb int) 

    }
    interface Dggsvd3er  {
        + Dggsvd3(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, n int, p int, a []float64, lda int, b []float64, ldb int, alpha []float64, beta []float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, work []float64, lwork int, iwork []int) (int, int, bool)

    }
    interface Dggsvp3er  {
        + Dggsvp3(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, p int, n int, a []float64, lda int, b []float64, ldb int, tola float64, tolb float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, iwork []int, tau []float64, work []float64, lwork int) (int, int)

    }
    interface Dgtsver  {
        + Dgtsv(n int, nrhs int, dl []float64, d []float64, du []float64, b []float64, ldb int) bool

    }
    interface Dhseqrer  {
        + Dhseqr(job lapack.SchurJob, compz lapack.SchurComp, n int, ilo int, ihi int, h []float64, ldh int, wr []float64, wi []float64, z []float64, ldz int, work []float64, lwork int) int

    }
    class Diagonal << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    interface Dlabrder  {
        + Dlabrd(m int, n int, nb int, a []float64, lda int, d []float64, e []float64, tauq []float64, taup []float64, x []float64, ldx int, y []float64, ldy int) 

    }
    interface Dlacn2er  {
        + Dlacn2(n int, v []float64, x []float64, isgn []int, est float64, kase int, isave *[]int) (float64, int)

    }
    interface Dlacpyer  {
        + Dlacpy(uplo blas.Uplo, m int, n int, a []float64, lda int, b []float64, ldb int) 

    }
    interface Dlae2er  {
        + Dlae2(a float64, b float64, c float64) (float64, float64)

    }
    interface Dlaev2er  {
        + Dlaev2(a float64, b float64, c float64) (float64, float64, float64, float64)

    }
    interface Dlaexcer  {
        + Dlaexc(wantq bool, n int, t []float64, ldt int, q []float64, ldq int, j1 int, n1 int, n2 int, work []float64) bool

    }
    interface Dlag2er  {
        + Dlag2(a []float64, lda int, b []float64, ldb int) (float64, float64, float64, float64, float64)

    }
    interface Dlags2er  {
        + Dlags2(upper bool, a1 float64, a2 float64, a3 float64, b1 float64, b2 float64, b3 float64) (float64, float64, float64, float64, float64, float64)

    }
    interface Dlagtmer  {
        + Dlagtm(trans blas.Transpose, m int, n int, alpha float64, dl []float64, d []float64, du []float64, b []float64, ldb int, beta float64, c []float64, ldc int) 

    }
    interface Dlahqrer  {
        + Dlahqr(wantt bool, wantz bool, n int, ilo int, ihi int, h []float64, ldh int, wr []float64, wi []float64, iloz int, ihiz int, z []float64, ldz int) int

    }
    interface Dlahr2er  {
        + Dlahr2(n int, k int, nb int, a []float64, lda int, tau []float64, t []float64, ldt int, y []float64, ldy int) 

    }
    interface Dlaln2er  {
        + Dlaln2(trans bool, na int, nw int, smin float64, ca float64, a []float64, lda int, d1 float64, d2 float64, b []float64, ldb int, wr float64, wi float64, x []float64, ldx int) (float64, float64, bool)

    }
    interface Dlangber  {
        + Dlangb(norm lapack.MatrixNorm, m int, n int, kl int, ku int, ab []float64, ldab int) float64

    }
    interface Dlanger  {
        + Dlange(norm lapack.MatrixNorm, m int, n int, a []float64, lda int, work []float64) float64

    }
    interface Dlangter  {
        + Dlangt(norm lapack.MatrixNorm, n int, dl []float64, d []float64, du []float64) float64

    }
    interface Dlansber  {
        + Dlansb(norm lapack.MatrixNorm, uplo blas.Uplo, n int, kd int, ab []float64, ldab int, work []float64) float64

    }
    interface Dlanster  {
        + Dlanst(norm lapack.MatrixNorm, n int, d []float64, e []float64) float64

    }
    interface Dlansyer  {
        + Dlansy(norm lapack.MatrixNorm, uplo blas.Uplo, n int, a []float64, lda int, work []float64) float64

    }
    interface Dlantber  {
        + Dlantb(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, n int, k int, a []float64, lda int, work []float64) float64

    }
    interface Dlantrer  {
        + Dlantr(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, m int, n int, a []float64, lda int, work []float64) float64

    }
    interface Dlanv2er  {
        + Dlanv2(a float64, b float64, c float64, d float64) (float64, float64, float64, float64, float64, float64, float64, float64, float64, float64)

    }
    interface Dlapller  {
        + Dlapll(n int, x []float64, incX int, y []float64, incY int) float64

    }
    interface Dlapmrer  {
        + Dlapmr(forwrd bool, m int, n int, x []float64, ldx int, k []int) 

    }
    interface Dlapmter  {
        + Dlapmt(forward bool, m int, n int, x []float64, ldx int, k []int) 

    }
    interface Dlapy2er  {
        + Dlapy2( float64,  float64) float64

    }
    interface Dlaqp2er  {
        + Dlaqp2(m int, n int, offset int, a []float64, lda int, jpvt []int, tau []float64, vn1 []float64, vn2 []float64, work []float64) 

    }
    interface Dlaqpser  {
        + Dlaqps(m int, n int, offset int, nb int, a []float64, lda int, jpvt []int, tau []float64, vn1 []float64, vn2 []float64, auxv []float64, f []float64, ldf int) int

    }
    interface Dlaqr04er  {
        + Dlaqr04(wantt bool, wantz bool, n int, ilo int, ihi int, h []float64, ldh int, wr []float64, wi []float64, iloz int, ihiz int, z []float64, ldz int, work []float64, lwork int, recur int) int

    }
    interface Dlaqr1er  {
        + Dlaqr1(n int, h []float64, ldh int, sr1 float64, si1 float64, sr2 float64, si2 float64, v []float64) 

    }
    interface Dlaqr23er  {
        + Dlaqr23(wantt bool, wantz bool, n int, ktop int, kbot int, nw int, h []float64, ldh int, iloz int, ihiz int, z []float64, ldz int, sr []float64, si []float64, v []float64, ldv int, nh int, t []float64, ldt int, nv int, wv []float64, ldwv int, work []float64, lwork int, recur int) (int, int)

    }
    interface Dlaqr5er  {
        + Dlaqr5(wantt bool, wantz bool, kacc22 int, n int, ktop int, kbot int, nshfts int, sr []float64, si []float64, h []float64, ldh int, iloz int, ihiz int, z []float64, ldz int, v []float64, ldv int, u []float64, ldu int, nh int, wh []float64, ldwh int, nv int, wv []float64, ldwv int) 

    }
    interface Dlarfber  {
        + Dlarfb(side blas.Side, trans blas.Transpose, direct lapack.Direct, store lapack.StoreV, m int, n int, k int, v []float64, ldv int, t []float64, ldt int, c []float64, ldc int, work []float64, ldwork int) 

    }
    interface Dlarfer  {
        + Dlarf(side blas.Side, m int, n int, v []float64, incv int, tau float64, c []float64, ldc int, work []float64) 

    }
    interface Dlarfger  {
        + Dlarfg(n int, alpha float64, x []float64, incX int) (float64, float64)

    }
    interface Dlarfter  {
        + Dlarft(direct lapack.Direct, store lapack.StoreV, n int, k int, v []float64, ldv int, tau []float64, t []float64, ldt int) 

    }
    interface Dlarfxer  {
        + Dlarfx(side blas.Side, m int, n int, v []float64, tau float64, c []float64, ldc int, work []float64) 

    }
    interface Dlartger  {
        + Dlartg(f float64, g float64) (float64, float64, float64)

    }
    interface Dlas2er  {
        + Dlas2(f float64, g float64, h float64) (float64, float64)

    }
    interface Dlascler  {
        + Dlascl(kind lapack.MatrixType, kl int, ku int, cfrom float64, cto float64, m int, n int, a []float64, lda int) 

    }
    interface Dlaseter  {
        + Dlaset(uplo blas.Uplo, m int, n int, alpha float64, beta float64, a []float64, lda int) 

    }
    interface Dlasq1er  {
        + Dlasq1(n int, d []float64, e []float64, work []float64) int
        + Dgebrd(m int, n int, a []float64, lda int, d []float64, e []float64, tauQ []float64, tauP []float64, work []float64, lwork int) 

    }
    interface Dlasq2er  {
        + Dlasq2(n int, z []float64) int
        + Dsyev(jobz lapack.EVJob, uplo blas.Uplo, n int, a []float64, lda int, w []float64, work []float64, lwork int) bool

    }
    interface Dlasrer  {
        + Dlasr(side blas.Side, pivot lapack.Pivot, direct lapack.Direct, m int, n int, c []float64, s []float64, a []float64, lda int) 

    }
    interface Dlasrter  {
        + Dlasrt(s lapack.Sort, n int, d []float64) 

    }
    interface Dlassqer  {
        + Dlassq(n int, x []float64, incx int, scale float64, ssq float64) (float64, float64)

    }
    interface Dlasv2er  {
        + Dlasv2(f float64, g float64, h float64) (float64, float64, float64, float64, float64, float64)

    }
    interface Dlaswper  {
        + Dlaswp(n int, a []float64, lda int, k1 int, k2 int, ipiv []int, incX int) 

    }
    interface Dlasy2er  {
        + Dlasy2(tranl bool, tranr bool, isgn int, n1 int, n2 int, tl []float64, ldtl int, tr []float64, ldtr int, b []float64, ldb int, x []float64, ldx int) (float64, float64, bool)

    }
    interface Dlatbser  {
        + Dlatbs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, normin bool, n int, kd int, ab []float64, ldab int, x []float64, cnorm []float64) float64

    }
    interface Dlatrder  {
        + Dlatrd(uplo blas.Uplo, n int, nb int, a []float64, lda int, e []float64, tau []float64, w []float64, ldw int) 

    }
    interface Dlatrser  {
        + Dlatrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, normin bool, n int, a []float64, lda int, x []float64, cnorm []float64) float64

    }
    interface Dlauu2er  {
        + Dlauu2(uplo blas.Uplo, n int, a []float64, lda int) 

    }
    interface Dlauumer  {
        + Dlauum(uplo blas.Uplo, n int, a []float64, lda int) 

    }
    interface Dorg2ler  {
        + Dorg2l(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dorg2rer  {
        + Dorg2r(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dorgbrer  {
        + Dorgbr(vect lapack.GenOrtho, m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dorghrer  {
        + Dorghr(n int, ilo int, ihi int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dorgl2er  {
        + Dorgl2(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dorglqer  {
        + Dorglq(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dorgqler  {
        + Dorgql(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dorgqrer  {
        + Dorgqr(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dorgr2er  {
        + Dorgr2(m int, n int, k int, a []float64, lda int, tau []float64, work []float64) 

    }
    interface Dorgtrer  {
        + Dorgtr(uplo blas.Uplo, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dorm2rer  {
        + Dorm2r(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64) 

    }
    interface Dormbrer  {
        + Dormbr(vect lapack.ApplyOrtho, side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 

    }
    interface Dormhrer  {
        + Dormhr(side blas.Side, trans blas.Transpose, m int, n int, ilo int, ihi int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 

    }
    interface Dorml2er  {
        + Dorml2(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64) 

    }
    interface Dormlqer  {
        + Dormlq(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 

    }
    interface Dormqrer  {
        + Dormqr(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64, lwork int) 

    }
    interface Dormr2er  {
        + Dgerqf(m int, n int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dormr2(side blas.Side, trans blas.Transpose, m int, n int, k int, a []float64, lda int, tau []float64, c []float64, ldc int, work []float64) 

    }
    class Downshift << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    interface Dpbconer  {
        + Dpbcon(uplo blas.Uplo, n int, kd int, ab []float64, ldab int, anorm float64, work []float64, iwork []int) float64

    }
    interface Dpbtf2er  {
        + Dpbtf2(uplo blas.Uplo, n int, kd int, ab []float64, ldab int) bool

    }
    interface Dpbtrfer  {
        + Dpbtrf(uplo blas.Uplo, n int, kd int, ab []float64, ldab int) bool

    }
    interface Dpbtrser  {
        + Dpbtrs(uplo blas.Uplo, n int, kd int, nrhs int, ab []float64, ldab int, b []float64, ldb int) 

    }
    interface Dpoconer  {
        + Dlansy(norm lapack.MatrixNorm, uplo blas.Uplo, n int, a []float64, lda int, work []float64) float64
        + Dpocon(uplo blas.Uplo, n int, a []float64, lda int, anorm float64, work []float64, iwork []int) float64

    }
    interface Dpotf2er  {
        + Dpotf2(ul blas.Uplo, n int, a []float64, lda int) bool

    }
    interface Dpotrfer  {
        + Dpotrf(ul blas.Uplo, n int, a []float64, lda int) bool

    }
    interface Dpotrier  {
        + Dpotri(uplo blas.Uplo, n int, a []float64, lda int) bool
        + Dpotrf(uplo blas.Uplo, n int, a []float64, lda int) bool

    }
    interface Dpotrser  {
        + Dpotrs(uplo blas.Uplo, n int, nrhs int, a []float64, lda int, b []float64, ldb int) 
        + Dpotrf(uplo blas.Uplo, n int, a []float64, lda int) bool

    }
    interface Dpstf2er  {
        + Dpstf2(uplo blas.Uplo, n int, a []float64, lda int, piv []int, tol float64, work []float64) (int, bool)

    }
    interface Dpstrfer  {
        + Dpstrf(uplo blas.Uplo, n int, a []float64, lda int, piv []int, tol float64, work []float64) (int, bool)

    }
    interface Drscler  {
        + Drscl(n int, a float64, x []float64, incX int) 

    }
    interface Dsteqrer  {
        + Dsteqr(compz lapack.EVComp, n int, d []float64, e []float64, z []float64, ldz int, work []float64) bool

    }
    interface Dsterfer  {
        + Dsterf(n int, d []float64, e []float64) bool

    }
    interface Dsyever  {
        + Dsyev(jobz lapack.EVJob, uplo blas.Uplo, n int, a []float64, lda int, w []float64, work []float64, lwork int) bool

    }
    interface Dsytd2er  {
        + Dsytd2(uplo blas.Uplo, n int, a []float64, lda int, d []float64, e []float64, tau []float64) 

    }
    interface Dsytrder  {
        + Dsytrd(uplo blas.Uplo, n int, a []float64, lda int, d []float64, e []float64, tau []float64, work []float64, lwork int) 
        + Dorgqr(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 
        + Dorgql(m int, n int, k int, a []float64, lda int, tau []float64, work []float64, lwork int) 

    }
    interface Dtbtrser  {
        + Dtbtrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, kd int, nrhs int, a []float64, lda int, b []float64, ldb int) bool

    }
    interface Dtgsjaer  {
        + Dtgsja(jobU lapack.GSVDJob, jobV lapack.GSVDJob, jobQ lapack.GSVDJob, m int, p int, n int, k int, l int, a []float64, lda int, b []float64, ldb int, tola float64, tolb float64, alpha []float64, beta []float64, u []float64, ldu int, v []float64, ldv int, q []float64, ldq int, work []float64) (int, bool)

    }
    interface Dtrconer  {
        + Dtrcon(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int, work []float64, iwork []int) float64
        + Dtrtri(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) bool
        + Dlantr(norm lapack.MatrixNorm, uplo blas.Uplo, diag blas.Diag, m int, n int, a []float64, lda int, work []float64) float64

    }
    interface Dtrevc3er  {
        + Dtrevc3(side lapack.EVSide, howmny lapack.EVHowMany, selected []bool, n int, t []float64, ldt int, vl []float64, ldvl int, vr []float64, ldvr int, mm int, work []float64, lwork int) int

    }
    interface Dtrexcer  {
        + Dtrexc(compq lapack.UpdateSchurComp, n int, t []float64, ldt int, q []float64, ldq int, ifst int, ilst int, work []float64) (int, int, bool)

    }
    interface Dtrti2er  {
        + Dtrti2(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) 

    }
    interface Dtrtrier  {
        + Dtrtri(uplo blas.Uplo, diag blas.Diag, n int, a []float64, lda int) bool

    }
    interface Dtrtrser  {
        + Dtrtrs(uplo blas.Uplo, trans blas.Transpose, diag blas.Diag, n int, nrhs int, a []float64, lda int, b []float64, ldb int) bool

    }
    class Fibonacci << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Gear << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Grcar << (S,Aquamarine) >> {
        + N int
        + K int

        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Hanowa << (S,Aquamarine) >> {
        + N int
        + Alpha float64

        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    interface Iladlcer  {
        + Iladlc(m int, n int, a []float64, lda int) int

    }
    interface Iladlrer  {
        + Iladlr(m int, n int, a []float64, lda int) int

    }
    class Lesp << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Rutis << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Tris << (S,Aquamarine) >> {
        + N int
        + X float64

        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Wilk12 << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Wilk20 << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Wilk4 << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class Zero << (S,Aquamarine) >> {
        + Matrix() blas64.General
        + Eigenvalues() []complex128

    }
    class dgeevTest << (S,Aquamarine) >> {
        - a blas64.General
        - evWant []complex128
        - valTol float64
        - vecTol float64

    }
    class dhseqrTest << (S,Aquamarine) >> {
        - n int
        - ilo int
        - ihi int
        - h []float64
        - tol float64
        - evWant []complex128

    }
    class dlahqrTest << (S,Aquamarine) >> {
        - h blas64.General
        - ilo int
        - iloz int
        - wantt bool
        - evWant []complex128

    }
    class dlaqr04Test << (S,Aquamarine) >> {
        - h blas64.General
        - ilo int
        - iloz int
        - wantt bool
        - evWant []complex128

    }
    class dlaqr23Test << (S,Aquamarine) >> {
        - wantt bool
        - ktop int
        - nw int
        - h blas64.General
        - iloz int
        - evWant []complex128

    }
    class fortran64 << (S,Aquamarine) >> {
        + String() string

    }
    class testlapack.Circulant << (T, #FF7700) >>  {
    }
    class testlapack.Clement << (T, #FF7700) >>  {
    }
    class testlapack.Creation << (T, #FF7700) >>  {
    }
    class testlapack.Diagonal << (T, #FF7700) >>  {
    }
    class testlapack.Downshift << (T, #FF7700) >>  {
    }
    class testlapack.Fibonacci << (T, #FF7700) >>  {
    }
    class testlapack.Gear << (T, #FF7700) >>  {
    }
    class testlapack.Lesp << (T, #FF7700) >>  {
    }
    class testlapack.Wilk20 << (T, #FF7700) >>  {
    }
    class testlapack.Zero << (T, #FF7700) >>  {
    }
    class testlapack.fortran64 << (T, #FF7700) >>  {
    }
    class testlapack.worklen << (T, #FF7700) >>  {
    }
    class worklen << (S,Aquamarine) >> {
        + String() string

    }
}
"testlapack.Dgebd2er" *-- "testlapack.Dgebrder"
"testlapack.Dgetrier" *-- "testlapack.Dgeconer"
"testlapack.Dlanger" *-- "testlapack.Dgeconer"
"testlapack.Dgelq2er" *-- "testlapack.Dgelqfer"
"testlapack.Dlapmter" *-- "testlapack.Dgeqp3er"
"testlapack.Dgeqr2er" *-- "testlapack.Dgeqrfer"
"testlapack.Dgetc2er" *-- "testlapack.Dgesc2er"
"testlapack.Dgetrfer" *-- "testlapack.Dgetrier"
"testlapack.Dgetrfer" *-- "testlapack.Dgetrser"
"testlapack.Dlanger" *-- "testlapack.Dggsvp3er"
"testlapack.Dlanger" *-- "testlapack.Dlanster"
"testlapack.Dlanger" *-- "testlapack.Dlansyer"
"testlapack.Dlanger" *-- "testlapack.Dlantrer"
"testlapack.Dgesvder" *-- "testlapack.Dlapller"
"testlapack.Dlapmter" *-- "testlapack.Dlaqp2er"
"testlapack.Dlapmter" *-- "testlapack.Dlaqpser"
"testlapack.Dlahqrer" *-- "testlapack.Dlaqr04er"
"testlapack.Dlarfter" *-- "testlapack.Dlarfber"
"testlapack.Dgeqr2er" *-- "testlapack.Dlarfter"
"testlapack.Dgeql2er" *-- "testlapack.Dorg2ler"
"testlapack.Dgeqrfer" *-- "testlapack.Dorg2rer"
"testlapack.Dgebrder" *-- "testlapack.Dorgbrer"
"testlapack.Dgehrder" *-- "testlapack.Dorghrer"
"testlapack.Dgelqfer" *-- "testlapack.Dorgl2er"
"testlapack.Dorgl2er" *-- "testlapack.Dorglqer"
"testlapack.Dlarfger" *-- "testlapack.Dorgqler"
"testlapack.Dorg2rer" *-- "testlapack.Dorgqrer"
"testlapack.Dgerqfer" *-- "testlapack.Dorgr2er"
"testlapack.Dsytrder" *-- "testlapack.Dorgtrer"
"testlapack.Dgeqrfer" *-- "testlapack.Dorm2rer"
"testlapack.Dgebrder" *-- "testlapack.Dormbrer"
"testlapack.Dgehrder" *-- "testlapack.Dormhrer"
"testlapack.Dgelqfer" *-- "testlapack.Dorml2er"
"testlapack.Dorml2er" *-- "testlapack.Dormlqer"
"testlapack.Dorm2rer" *-- "testlapack.Dormqrer"
"testlapack.Dpbtrser" *-- "testlapack.Dpbconer"
"testlapack.Dpbtrfer" *-- "testlapack.Dpbtrser"
"testlapack.Dgeconer" *-- "testlapack.Dpoconer"
"testlapack.Dpotrfer" *-- "testlapack.Dpoconer"
"testlapack.Dorgtrer" *-- "testlapack.Dsteqrer"
"testlapack.Dlansyer" *-- "testlapack.Dsterfer"
"testlapack.Dsteqrer" *-- "testlapack.Dsterfer"
"testlapack.Dlanger" *-- "testlapack.Dtgsjaer"


namespace testquad {
    class Integral << (S,Aquamarine) >> {
        + Name string
        + A float64
        + F <font color=blue>func</font>(float64) float64
        + Value float64

    }
}


namespace testrand {
    interface Rand  {
        + ExpFloat64() float64
        + Float32() float32
        + Float64() float64
        + Int() int
        + Int31() int32
        + Int31n(n int32) int32
        + Int63() int64
        + Int63n(n int64) int64
        + Intn(n int) int
        + NormFloat64() float64
        + Perm(n int) []int
        + Read(p []byte) (int, error)
        + Seed(seed uint64) 
        + Shuffle(n int, swap <font color=blue>func</font>(int, int) ) 
        + Uint32() uint32
        + Uint64() uint64
        + Uint64n(n uint64) uint64

    }
    interface TB  {
        + Logf(format string, args ...<font color=blue>interface</font>{}) 

    }
    class extreme << (S,Aquamarine) >> {
        - probability float64
        - nanProbability float64
        - rnd Rand

        - p() bool
        - nan() bool

        + Perm(n int) []int
        + Read(p []byte) (int, error)
        + Seed(seed uint64) 
        + Shuffle(n int, swap <font color=blue>func</font>(int, int) ) 
        + ExpFloat64() float64
        + Float32() float32
        + Float64() float64
        + Int() int
        + Int31() int32
        + Int31n(n int32) int32
        + Int63() int64
        + Int63n(n int64) int64
        + Intn(n int) int
        + NormFloat64() float64
        + Uint32() uint32
        + Uint64() uint64
        + Uint64n(n uint64) uint64

    }
    class testrand.Source << (T, #FF7700) >>  {
    }
    class "rand.Source" as randSource {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}

"testrand.Rand" <|-- "testrand.extreme"

namespace token {
    class Pos << (S,Aquamarine) >> {
        + Offset int
        + Line int
        + Column int

        + String() string

    }
    class Token << (S,Aquamarine) >> {
        + Lit []byte

    }
    class TokenMap << (S,Aquamarine) >> {
        - typeMap []string
        - idMap <font color=blue>map</font>[string]Type

        + Id(tok Type) string
        + Type(tok string) Type
        + TokenString(tok *Token) string
        + StringType(typ Type) string

    }
    class token.Type << (T, #FF7700) >>  {
    }
}
"token.Pos" *-- "token.Token"
"token.Type" *-- "token.Token"


namespace topo {
    interface Builder  {
        + AddNode( graph.Node) 
        + SetEdge( graph.Edge) 

    }
    class Clique << (S,Aquamarine) >> {
        - id int64
        - nodes []graph.Node

        + ID() int64
        + Nodes() []graph.Node

    }
    class CliqueGraphEdge << (S,Aquamarine) >> {
        - from Clique
        - nodes []graph.Node

        + From() graph.Node
        + To() graph.Node
        + ReversedEdge() graph.Edge
        + Nodes() []graph.Node

    }
    class Unorderable << (S,Aquamarine) >> {
        + Error() string

    }
    class bronKerbosch << (S,Aquamarine) >> {
        - maximalCliquePivot(g graph.Undirected, r []graph.Node, p set.Nodes, x set.Nodes) 
        - choosePivotFrom(g graph.Undirected, p set.Nodes, x set.Nodes) []graph.Node

    }
    class johnson << (S,Aquamarine) >> {
        - adjacent johnsonGraph
        - b []set.Ints
        - blocked []bool
        - s int
        - stack []graph.Node
        - result [][]graph.Node

        - circuit(v int) bool
        - unblock(u int) 

    }
    class johnsonGraph << (S,Aquamarine) >> {
        - orig []graph.Node
        - index <font color=blue>map</font>[int64]int
        - nodes set.Int64s
        - succ <font color=blue>map</font>[int64]set.Int64s

        - order() int
        - indexOf(id int64) int
        - leastVertexIndex() int
        - subgraph(s int) johnsonGraph
        - sccSubGraph(sccs [][]graph.Node, min int) johnsonGraph

        + Nodes() graph.Nodes
        + From(id int64) graph.Nodes
        + Has( int64) bool
        + Node( int64) graph.Node
        + HasEdgeBetween(_ int64, _ int64) bool
        + Edge(_ int64, _ int64) graph.Edge
        + HasEdgeFromTo(_ int64, _ int64) bool
        + To( int64) graph.Nodes

    }
    class johnsonGraphNode << (S,Aquamarine) >> {
        + ID() int64

    }
    class nodeSet << (S,Aquamarine) >> {
        - nodes set.Nodes

    }
    class sets << (S,Aquamarine) >> {
        - add(uid int64, vid int64) 
        - has(uid int64) bool

    }
    class tarjan << (S,Aquamarine) >> {
        - succ <font color=blue>func</font>(int64) []graph.Node
        - index int
        - indexTable <font color=blue>map</font>[int64]int
        - lowLink <font color=blue>map</font>[int64]int
        - onStack set.Int64s
        - stack []graph.Node
        - sccs [][]graph.Node

        - strongconnect(v graph.Node) 

    }
    class topo.Unorderable << (T, #FF7700) >>  {
    }
    class topo.bronKerbosch << (T, #FF7700) >>  {
    }
    class topo.cliqueNodeSets << (T, #FF7700) >>  {
    }
    class topo.johnsonGraphNode << (T, #FF7700) >>  {
    }
    class topo.sets << (T, #FF7700) >>  {
    }
    class "<font color=blue>map</font>[int64]set.Int64s" as fontcolorbluemapfontint64setInt64s {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
    class "[][]graph.Node" as graphNode {
        'This class was created so that we can correctly have an alias pointing to this name. Since it contains dots that can break namespaces
    }
}
"topo.Clique" *-- "topo.nodeSet"

"graph.Node" <|-- "topo.Clique"
"dot.basicEdge" <|-- "topo.CliqueGraphEdge"
"graph.Edge" <|-- "topo.CliqueGraphEdge"
"testgraph.Edge" <|-- "topo.CliqueGraphEdge"
"gen.GraphBuilder" <|-- "topo.johnsonGraph"
"graph.Directed" <|-- "topo.johnsonGraph"
"graph.DirectedMultigraph" <|-- "topo.johnsonGraph"
"graph.Graph" <|-- "topo.johnsonGraph"
"graph.WeightedDirected" <|-- "topo.johnsonGraph"
"graph.WeightedDirectedMultigraph" <|-- "topo.johnsonGraph"
"traverse.Graph" <|-- "topo.johnsonGraph"
"graph.Node" <|-- "topo.johnsonGraphNode"

namespace traverse {
    class BreadthFirst << (S,Aquamarine) >> {
        - queue linear.NodeQueue
        - visited set.Int64s

        + Visit <font color=blue>func</font>(graph.Node) 
        + Traverse <font color=blue>func</font>(graph.Edge) bool

        + Walk(g Graph, from graph.Node, until <font color=blue>func</font>(graph.Node, int) bool) graph.Node
        + WalkAll(g graph.Undirected, before <font color=blue>func</font>() , after <font color=blue>func</font>() , during <font color=blue>func</font>(graph.Node) ) 
        + Visited(n graph.Node) bool
        + Reset() 

    }
    class DepthFirst << (S,Aquamarine) >> {
        - stack linear.NodeStack
        - visited set.Int64s

        + Visit <font color=blue>func</font>(graph.Node) 
        + Traverse <font color=blue>func</font>(graph.Edge) bool

        + Walk(g Graph, from graph.Node, until <font color=blue>func</font>(graph.Node) bool) graph.Node
        + WalkAll(g graph.Undirected, before <font color=blue>func</font>() , after <font color=blue>func</font>() , during <font color=blue>func</font>(graph.Node) ) 
        + Visited(n graph.Node) bool
        + Reset() 

    }
    interface Graph  {
        + From(id int64) graph.Nodes
        + Edge(uid int64, vid int64) graph.Edge

    }
}

"mat.Reseter" <|-- "traverse.BreadthFirst"
"mat.Reseter" <|-- "traverse.DepthFirst"

namespace uid {
    class Set << (S,Aquamarine) >> {
        - maxID int64
        - used set.Int64s

        + NewID() int64
        + Use(id int64) 
        + Release(id int64) 

    }
}


namespace unit {
    class AbsorbedRadioactiveDose << (S,Aquamarine) >> {
        + Unit() *Unit
        + AbsorbedRadioactiveDose() AbsorbedRadioactiveDose
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Acceleration << (S,Aquamarine) >> {
        + Unit() *Unit
        + Acceleration() Acceleration
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Angle << (S,Aquamarine) >> {
        + Unit() *Unit
        + Angle() Angle
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Area << (S,Aquamarine) >> {
        + Unit() *Unit
        + Area() Area
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Capacitance << (S,Aquamarine) >> {
        + Unit() *Unit
        + Capacitance() Capacitance
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Charge << (S,Aquamarine) >> {
        + Unit() *Unit
        + Charge() Charge
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Conductance << (S,Aquamarine) >> {
        + Unit() *Unit
        + Conductance() Conductance
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Current << (S,Aquamarine) >> {
        + Unit() *Unit
        + Current() Current
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Dimension << (S,Aquamarine) >> {
        + String() string

    }
    class Dimensions << (S,Aquamarine) >> {
        - clone() Dimensions
        - matches(o Dimensions) bool

        + String() string

    }
    class Dimless << (S,Aquamarine) >> {
        + Unit() *Unit
        + Dimless() Dimless
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Energy << (S,Aquamarine) >> {
        + Unit() *Unit
        + Energy() Energy
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class EquivalentRadioactiveDose << (S,Aquamarine) >> {
        + Unit() *Unit
        + EquivalentRadioactiveDose() EquivalentRadioactiveDose
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Force << (S,Aquamarine) >> {
        + Unit() *Unit
        + Force() Force
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Frequency << (S,Aquamarine) >> {
        + Unit() *Unit
        + Frequency() Frequency
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Inductance << (S,Aquamarine) >> {
        + Unit() *Unit
        + Inductance() Inductance
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Length << (S,Aquamarine) >> {
        + Unit() *Unit
        + Length() Length
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class LuminousIntensity << (S,Aquamarine) >> {
        + Unit() *Unit
        + LuminousIntensity() LuminousIntensity
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class MagneticFlux << (S,Aquamarine) >> {
        + Unit() *Unit
        + MagneticFlux() MagneticFlux
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class MagneticFluxDensity << (S,Aquamarine) >> {
        + Unit() *Unit
        + MagneticFluxDensity() MagneticFluxDensity
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Mass << (S,Aquamarine) >> {
        + Unit() *Unit
        + Mass() Mass
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Mole << (S,Aquamarine) >> {
        + Unit() *Unit
        + Mole() Mole
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Power << (S,Aquamarine) >> {
        + Unit() *Unit
        + Power() Power
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Pressure << (S,Aquamarine) >> {
        + Unit() *Unit
        + Pressure() Pressure
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Radioactivity << (S,Aquamarine) >> {
        + Unit() *Unit
        + Radioactivity() Radioactivity
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Resistance << (S,Aquamarine) >> {
        + Unit() *Unit
        + Resistance() Resistance
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Temperature << (S,Aquamarine) >> {
        + Unit() *Unit
        + Temperature() Temperature
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Time << (S,Aquamarine) >> {
        + Unit() *Unit
        + Time() Time
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Torque << (S,Aquamarine) >> {
        + Unit() *Unit
        + Torque() Torque
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Unit << (S,Aquamarine) >> {
        - dimensions Dimensions
        - value float64

        + Dimensions() Dimensions
        + Add(uniter Uniter) *Unit
        + Unit() *Unit
        + Copy() *Unit
        + Mul(uniter Uniter) *Unit
        + Div(uniter Uniter) *Unit
        + Value() float64
        + SetValue(v float64) 
        + Format(fs fmt.State, c rune) 

    }
    interface Uniter  {
        + Unit() *Unit

    }
    class Velocity << (S,Aquamarine) >> {
        + Unit() *Unit
        + Velocity() Velocity
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Voltage << (S,Aquamarine) >> {
        + Unit() *Unit
        + Voltage() Voltage
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class Volume << (S,Aquamarine) >> {
        + Unit() *Unit
        + Volume() Volume
        + From(u Uniter) error
        + Format(fs fmt.State, c rune) 

    }
    class atom << (S,Aquamarine) >> {
        - pow int

    }
    class unit.AbsorbedRadioactiveDose << (T, #FF7700) >>  {
    }
    class unit.Acceleration << (T, #FF7700) >>  {
    }
    class unit.Angle << (T, #FF7700) >>  {
    }
    class unit.Area << (T, #FF7700) >>  {
    }
    class unit.Capacitance << (T, #FF7700) >>  {
    }
    class unit.Charge << (T, #FF7700) >>  {
    }
    class unit.Conductance << (T, #FF7700) >>  {
    }
    class unit.Current << (T, #FF7700) >>  {
    }
    class unit.Dimension << (T, #FF7700) >>  {
    }
    class unit.Dimensions << (T, #FF7700) >>  {
    }
    class unit.Dimless << (T, #FF7700) >>  {
    }
    class unit.Energy << (T, #FF7700) >>  {
    }
    class unit.EquivalentRadioactiveDose << (T, #FF7700) >>  {
    }
    class unit.Force << (T, #FF7700) >>  {
    }
    class unit.Frequency << (T, #FF7700) >>  {
    }
    class unit.Inductance << (T, #FF7700) >>  {
    }
    class unit.Length << (T, #FF7700) >>  {
    }
    class unit.LuminousIntensity << (T, #FF7700) >>  {
    }
    class unit.MagneticFlux << (T, #FF7700) >>  {
    }
    class unit.MagneticFluxDensity << (T, #FF7700) >>  {
    }
    class unit.Mass << (T, #FF7700) >>  {
    }
    class unit.Mole << (T, #FF7700) >>  {
    }
    class unit.Power << (T, #FF7700) >>  {
    }
    class unit.Pressure << (T, #FF7700) >>  {
    }
    class unit.Radioactivity << (T, #FF7700) >>  {
    }
    class unit.Resistance << (T, #FF7700) >>  {
    }
    class unit.Temperature << (T, #FF7700) >>  {
    }
    class unit.Time << (T, #FF7700) >>  {
    }
    class unit.Torque << (T, #FF7700) >>  {
    }
    class unit.Velocity << (T, #FF7700) >>  {
    }
    class unit.Voltage << (T, #FF7700) >>  {
    }
    class unit.Volume << (T, #FF7700) >>  {
    }
    class unit.unitPrinters << (T, #FF7700) >>  {
    }
    class unitPrinters << (S,Aquamarine) >> {
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
}
"unit.Dimension" *-- "unit.atom"

"unit.Uniter" <|-- "unit.AbsorbedRadioactiveDose"
"unit.Uniter" <|-- "unit.Acceleration"
"unit.Uniter" <|-- "unit.Angle"
"unit.Uniter" <|-- "unit.Area"
"unit.Uniter" <|-- "unit.Capacitance"
"unit.Uniter" <|-- "unit.Charge"
"unit.Uniter" <|-- "unit.Conductance"
"unit.Uniter" <|-- "unit.Current"
"unit.Uniter" <|-- "unit.Dimless"
"unit.Uniter" <|-- "unit.Energy"
"unit.Uniter" <|-- "unit.EquivalentRadioactiveDose"
"unit.Uniter" <|-- "unit.Force"
"unit.Uniter" <|-- "unit.Frequency"
"unit.Uniter" <|-- "unit.Inductance"
"unit.Uniter" <|-- "unit.Length"
"unit.Uniter" <|-- "unit.LuminousIntensity"
"unit.Uniter" <|-- "unit.MagneticFlux"
"unit.Uniter" <|-- "unit.MagneticFluxDensity"
"unit.Uniter" <|-- "unit.Mass"
"unit.Uniter" <|-- "unit.Mole"
"unit.Uniter" <|-- "unit.Power"
"unit.Uniter" <|-- "unit.Pressure"
"unit.Uniter" <|-- "unit.Radioactivity"
"unit.Uniter" <|-- "unit.Resistance"
"unit.Uniter" <|-- "unit.Temperature"
"unit.Uniter" <|-- "unit.Time"
"unit.Uniter" <|-- "unit.Torque"
"unit.Uniter" <|-- "unit.Unit"
"unit.Uniter" <|-- "unit.Velocity"
"unit.Uniter" <|-- "unit.Voltage"
"unit.Uniter" <|-- "unit.Volume"

namespace vptree {
    interface Comparable  {
        + Distance( Comparable) float64

    }
    class ComparableDist << (S,Aquamarine) >> {
        + Comparable Comparable
        + Dist float64

    }
    class DistKeeper << (S,Aquamarine) >> {
        + Keep(c ComparableDist) 

    }
    class Heap << (S,Aquamarine) >> {
        + Max() ComparableDist
        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 
        + Push(x <font color=blue>interface</font>{}) 
        + Pop() <font color=blue>interface</font>{}

    }
    interface Keeper  {
        + Keep( ComparableDist) 
        + Max() ComparableDist

    }
    class NKeeper << (S,Aquamarine) >> {
        + Keep(c ComparableDist) 

    }
    class Node << (S,Aquamarine) >> {
        + Point Comparable
        + Radius float64
        + Closer *Node
        + Further *Node

        - search(q Comparable, dist float64) (*Node, float64)
        - searchSet(q Comparable, k Keeper) 
        - do(fn Operation, depth int) bool

    }
    class Point << (S,Aquamarine) >> {
        + Distance(c Comparable) float64

    }
    class Tree << (S,Aquamarine) >> {
        + Root *Node
        + Count int

        + Len() int
        + Nearest(q Comparable) (Comparable, float64)
        + NearestSet(k Keeper, q Comparable) 
        + Do(fn Operation) bool

    }
    class builder << (S,Aquamarine) >> {
        - work []float64
        - intn <font color=blue>func</font>(int) int
        - shuf <font color=blue>func</font>(int, <font color=blue>func</font>(int, int) ) 

        - build(s []Comparable, effort int) *Node
        - selectVantage(s []Comparable, effort int) Comparable
        - random(n int, s []Comparable) []Comparable
        - partition(v Comparable, s []Comparable) (float64, []Comparable, []Comparable)

    }
    class byDist << (S,Aquamarine) >> {
        - dists []float64
        - points []Comparable

        + Len() int
        + Less(i int, j int) bool
        + Swap(i int, j int) 

    }
    class vptree.Heap << (T, #FF7700) >>  {
    }
    class vptree.Operation << (T, #FF7700) >>  {
    }
    class vptree.Point << (T, #FF7700) >>  {
    }
}
"vptree.Heap" *-- "vptree.DistKeeper"
"vptree.Heap" *-- "vptree.NKeeper"

"vptree.Comparable" <|-- "vptree.Point"

namespace window {
    class Gaussian << (S,Aquamarine) >> {
        + Sigma float64

        + Transform(seq []float64) []float64
        + TransformComplex(seq []complex128) []complex128

    }
    class Tukey << (S,Aquamarine) >> {
        + Alpha float64

        + Transform(seq []float64) []float64
        + TransformComplex(seq []complex128) []complex128

    }
    class Values << (S,Aquamarine) >> {
        + Transform(seq []float64) []float64
        + TransformTo(dst []float64, src []float64) 
        + TransformComplex(seq []complex128) []complex128
        + TransformComplexTo(dst []complex128, src []complex128) 

    }
    class window.Values << (T, #FF7700) >>  {
    }
}


"__builtin__.<font color=blue>map</font>[Dimension]int" #.. "unit.Dimensions"
"__builtin__.<font color=blue>map</font>[string]string" #.. "rdf.store"
"__builtin__.[][]byte" #.. "rdf.lexical"
"__builtin__.[][]float64" #.. "r3.array"
"__builtin__.[]float64" #.. "dynamic.key"
"__builtin__.[]float64" #.. "kdtree.Point"
"__builtin__.[]float64" #.. "vptree.Point"
"__builtin__.[]float64" #.. "window.Values"
"__builtin__.[]int" #.. "mat.columnWidth"
"__builtin__.[]int" #.. "parser.gotoRow"
"__builtin__.[]int64" #.. "gen.IDSet"
"__builtin__.[]string" #.. "rdf.triple"
"__builtin__.bool" #.. "mat.TriKind"
"__builtin__.bool" #.. "mat.result"
"__builtin__.bool" #.. "parser.accept"
"__builtin__.bool" #.. "rdf.debugger"
"__builtin__.byte" #.. "blas.Diag"
"__builtin__.byte" #.. "blas.Side"
"__builtin__.byte" #.. "blas.Transpose"
"__builtin__.byte" #.. "blas.Uplo"
"__builtin__.byte" #.. "lapack.ApplyOrtho"
"__builtin__.byte" #.. "lapack.BalanceJob"
"__builtin__.byte" #.. "lapack.Direct"
"__builtin__.byte" #.. "lapack.EVComp"
"__builtin__.byte" #.. "lapack.EVHowMany"
"__builtin__.byte" #.. "lapack.EVJob"
"__builtin__.byte" #.. "lapack.EVSide"
"__builtin__.byte" #.. "lapack.GSVDJob"
"__builtin__.byte" #.. "lapack.GenOrtho"
"__builtin__.byte" #.. "lapack.LeftEVJob"
"__builtin__.byte" #.. "lapack.MatrixNorm"
"__builtin__.byte" #.. "lapack.MatrixType"
"__builtin__.byte" #.. "lapack.MaximizeNormXJob"
"__builtin__.byte" #.. "lapack.Pivot"
"__builtin__.byte" #.. "lapack.RightEVJob"
"__builtin__.byte" #.. "lapack.SVDJob"
"__builtin__.byte" #.. "lapack.SchurComp"
"__builtin__.byte" #.. "lapack.SchurJob"
"__builtin__.byte" #.. "lapack.Sort"
"__builtin__.byte" #.. "lapack.StoreV"
"__builtin__.byte" #.. "lapack.UpdateSchurComp"
"__builtin__.float64" #.. "constant.avogadroUnits"
"__builtin__.float64" #.. "constant.boltzmannUnits"
"__builtin__.float64" #.. "constant.electricConstantUnits"
"__builtin__.float64" #.. "constant.faradayUnits"
"__builtin__.float64" #.. "constant.gravitationalUnits"
"__builtin__.float64" #.. "constant.magneticConstantUnits"
"__builtin__.float64" #.. "constant.planckUnits"
"__builtin__.float64" #.. "interp.Constant"
"__builtin__.float64" #.. "mat.Condition"
"__builtin__.float64" #.. "optimize.ErrFunc"
"__builtin__.float64" #.. "testlapack.Wilk20"
"__builtin__.float64" #.. "testlapack.fortran64"
"__builtin__.float64" #.. "unit.AbsorbedRadioactiveDose"
"__builtin__.float64" #.. "unit.Acceleration"
"__builtin__.float64" #.. "unit.Angle"
"__builtin__.float64" #.. "unit.Area"
"__builtin__.float64" #.. "unit.Capacitance"
"__builtin__.float64" #.. "unit.Charge"
"__builtin__.float64" #.. "unit.Conductance"
"__builtin__.float64" #.. "unit.Current"
"__builtin__.float64" #.. "unit.Dimless"
"__builtin__.float64" #.. "unit.Energy"
"__builtin__.float64" #.. "unit.EquivalentRadioactiveDose"
"__builtin__.float64" #.. "unit.Force"
"__builtin__.float64" #.. "unit.Frequency"
"__builtin__.float64" #.. "unit.Inductance"
"__builtin__.float64" #.. "unit.Length"
"__builtin__.float64" #.. "unit.LuminousIntensity"
"__builtin__.float64" #.. "unit.MagneticFlux"
"__builtin__.float64" #.. "unit.MagneticFluxDensity"
"__builtin__.float64" #.. "unit.Mass"
"__builtin__.float64" #.. "unit.Mole"
"__builtin__.float64" #.. "unit.Power"
"__builtin__.float64" #.. "unit.Pressure"
"__builtin__.float64" #.. "unit.Radioactivity"
"__builtin__.float64" #.. "unit.Resistance"
"__builtin__.float64" #.. "unit.Temperature"
"__builtin__.float64" #.. "unit.Time"
"__builtin__.float64" #.. "unit.Torque"
"__builtin__.float64" #.. "unit.Velocity"
"__builtin__.float64" #.. "unit.Voltage"
"__builtin__.float64" #.. "unit.Volume"
"__builtin__.int" #.. "blas.Flag"
"__builtin__.int" #.. "community.node"
"__builtin__.int" #.. "community.nonDecreasing"
"__builtin__.int" #.. "cytoscapejs.ElemType"
"__builtin__.int" #.. "graph.empty"
"__builtin__.int" #.. "kdtree.Dim"
"__builtin__.int" #.. "mat.EigenKind"
"__builtin__.int" #.. "mat.GSVDKind"
"__builtin__.int" #.. "mat.SVDKind"
"__builtin__.int" #.. "mat.uniformWidth"
"__builtin__.int" #.. "optimize.Status"
"__builtin__.int" #.. "optimize.nmIterType"
"__builtin__.int" #.. "parser.reduce"
"__builtin__.int" #.. "parser.shift"
"__builtin__.int" #.. "rdf.Kind"
"__builtin__.int" #.. "samplemv.HaltonKind"
"__builtin__.int" #.. "stat.CumulantKind"
"__builtin__.int" #.. "testlapack.Circulant"
"__builtin__.int" #.. "testlapack.Clement"
"__builtin__.int" #.. "testlapack.Creation"
"__builtin__.int" #.. "testlapack.Diagonal"
"__builtin__.int" #.. "testlapack.Downshift"
"__builtin__.int" #.. "testlapack.Fibonacci"
"__builtin__.int" #.. "testlapack.Gear"
"__builtin__.int" #.. "testlapack.Lesp"
"__builtin__.int" #.. "testlapack.Zero"
"__builtin__.int" #.. "testlapack.worklen"
"__builtin__.int" #.. "token.Type"
"__builtin__.int" #.. "unit.Dimension"
"__builtin__.int64" #.. "multi.Node"
"__builtin__.int64" #.. "path.johnsonGraphNode"
"__builtin__.int64" #.. "path.node"
"__builtin__.int64" #.. "simple.Node"
"__builtin__.int64" #.. "testgraph.node"
"__builtin__.int64" #.. "topo.johnsonGraphNode"
"__builtin__.string" #.. "digraph6.Graph"
"__builtin__.string" #.. "graph6.Graph"
"__builtin__.uint" #.. "ast.CompassPoint"
"__builtin__.uint" #.. "ast.Kind"
"__builtin__.uint64" #.. "optimize.Operation"
"__builtin__.uint8" #.. "mathext.fSolveResult"
"barneshut.fontcolorbluefuncfontParticle2Particle2float64float64r2Vecr2Vec" #.. "barneshut.Force2"
"barneshut.fontcolorbluefuncfontParticle3Particle3float64float64r3Vecr3Vec" #.. "barneshut.Force3"
"blas32.Band" #.. "blas32.BandCols"
"blas32.General" #.. "blas32.GeneralCols"
"blas32.Symmetric" #.. "blas32.SymmetricCols"
"blas32.SymmetricBand" #.. "blas32.SymmetricBandCols"
"blas32.Triangular" #.. "blas32.TriangularCols"
"blas32.TriangularBand" #.. "blas32.TriangularBandCols"
"blas64.Band" #.. "blas64.BandCols"
"blas64.General" #.. "blas64.GeneralCols"
"blas64.Symmetric" #.. "blas64.SymmetricCols"
"blas64.SymmetricBand" #.. "blas64.SymmetricBandCols"
"blas64.Triangular" #.. "blas64.TriangularCols"
"blas64.TriangularBand" #.. "blas64.TriangularBandCols"
"cblas128.Band" #.. "cblas128.BandCols"
"cblas128.General" #.. "cblas128.GeneralCols"
"cblas128.Hermitian" #.. "cblas128.HermitianCols"
"cblas128.HermitianBand" #.. "cblas128.HermitianBandCols"
"cblas128.Symmetric" #.. "cblas128.Hermitian"
"cblas128.Symmetric" #.. "cblas128.SymmetricCols"
"cblas128.SymmetricBand" #.. "cblas128.HermitianBand"
"cblas128.SymmetricBand" #.. "cblas128.SymmetricBandCols"
"cblas128.SymmetricPacked" #.. "cblas128.HermitianPacked"
"cblas128.Triangular" #.. "cblas128.TriangularCols"
"cblas128.TriangularBand" #.. "cblas128.TriangularBandCols"
"cblas64.Band" #.. "cblas64.BandCols"
"cblas64.General" #.. "cblas64.GeneralCols"
"cblas64.Hermitian" #.. "cblas64.HermitianCols"
"cblas64.HermitianBand" #.. "cblas64.HermitianBandCols"
"cblas64.Symmetric" #.. "cblas64.Hermitian"
"cblas64.SymmetricBand" #.. "cblas64.HermitianBand"
"cblas64.SymmetricPacked" #.. "cblas64.HermitianPacked"
"cblas64.Triangular" #.. "cblas64.TriangularCols"
"cblas64.TriangularBand" #.. "cblas64.TriangularBandCols"
"community.graphDirected" #.. "community.DirectedLayers"
"community.graphUndirected" #.. "community.UndirectedLayers"
"dynamic.[]*dStarLiteNode" #.. "dynamic.dStarLiteQueue"
"encoding.[]Attribute" #.. "encoding.Attributes"
"gexf12.timeTime" #.. "gexf12.xsdDate"
"graph.[]Edge" #.. "graph.EdgePair"
"interp.<font color=blue>func</font>(float64) float64" #.. "interp.Function"
"kdtree.<font color=blue>func</font>(Comparable, *Bounding, int) bool" #.. "kdtree.Operation"
"kdtree.[]ComparableDist" #.. "kdtree.Heap"
"kdtree.[]Point" #.. "kdtree.Points"
"layout.fontcolorbluemapfontint64r2Vec" #.. "layout.coordinatesR2"
"lexer.[]<font color=blue>func</font>(rune) int" #.. "lexer.TransitionTable"
"lexer.[]ActionRow" #.. "lexer.ActionTable"
"linear.graphNode" #.. "linear.NodeStack"
"mat.<font color=blue>func</font>(*formatter) " #.. "mat.FormatOption"
"mathext.<font color=blue>func</font>(float64, []float64) float64" #.. "mathext.objectiveFunc"
"network.[]compressedRow" #.. "network.rowCompressedMatrix"
"network.[]sparseElement" #.. "network.compressedRow"
"parser.[]ProdTabEntry" #.. "parser.ProdTab"
"parser.[]actionRow" #.. "parser.actionTable"
"parser.[]gotoRow" #.. "parser.gotoTable"
"path.fontcolorbluefuncfontgraphNodegraphNodefloat64" #.. "path.Heuristic"
"path.<font color=blue>func</font>(int64, int64) (float64, bool)" #.. "path.Weighting"
"path.<font color=blue>map</font>[int64]*dsNode" #.. "path.djSet"
"path.[]distanceNode" #.. "path.priorityQueue"
"path.graphWeightedEdge" #.. "path.byWeight"
"path.[]yenShortest" #.. "path.byPathWeight"
"r2.[]Vec" #.. "r2.Triangle"
"r2.[]Vec" #.. "r2.line"
"r3.[]Vec" #.. "r3.Triangle"
"r3.[]Vec" #.. "r3.line"
"r3.quatNumber" #.. "r3.Rotation"
"rdf.<font color=blue>func</font>(string, *issuer) <font color=blue>map</font>[string][]string" #.. "rdf.relatedHashCreator"
"rdf.<font color=blue>map</font>[string]*dsNode" #.. "rdf.djSet"
"rdf.[]*Statement" #.. "rdf.c14nStatements"
"set.<font color=blue>map</font>[int64]<font color=blue>struct</font>{}" #.. "set.Int64s"
"set.fontcolorbluemapfontint64graphNode" #.. "set.Nodes"
"set.<font color=blue>map</font>[int]<font color=blue>struct</font>{}" #.. "set.Ints"
"testgraph.fontcolorbluefuncfontgraphNodeWeightedLinefloat64float64graphGraphgraphNodeEdgefloat64float64bool" #.. "testgraph.Builder"
"testgraph.<font color=blue>map</font>[[]int64]<font color=blue>struct</font>{}" #.. "testgraph.tripleInt64s"
"testgraph.[]Edge" #.. "testgraph.lexicalEdges"
"testgraph.[]Edge" #.. "testgraph.lexicalUndirectedEdges"
"testrand.randSource" #.. "testrand.Source"
"topo.<font color=blue>map</font>[int64][]*nodeSet" #.. "topo.cliqueNodeSets"
"topo.fontcolorbluemapfontint64setInt64s" #.. "topo.sets"
"topo.graphNode" #.. "topo.Unorderable"
"topo.graphNode" #.. "topo.bronKerbosch"
"unit.[]atom" #.. "unit.unitPrinters"
"vptree.<font color=blue>func</font>(Comparable, int) bool" #.. "vptree.Operation"
"vptree.[]ComparableDist" #.. "vptree.Heap"
@enduml
